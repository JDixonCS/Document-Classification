,sentence,label,data,regex
0,To Index or not to Index: Time-Space Trade-Offs in Search Engines with Positional Ranking Functions,1,ad,True
1,Diego Arroyuelo,0,,False
2,"Dept. of Informatics, Univ. Técnica F. Santa María Yahoo! Labs Santiago, Chile",1,Yahoo,True
3,darroyue@inf.utfsm.cl,0,,False
4,Senén González ,0,,False
5,"University of Chile. Yahoo! Labs Santiago, Chile",1,Yahoo,True
6,sgonzale@dcc.uchile.cl,0,,False
7,Mauricio Marin,0,,False
8,"University of Santiago, Chile Yahoo! Labs Santiago, Chile",1,Yahoo,True
9,mmarin@yahoo-inc.com,0,,False
10,Mauricio Oyarzún,0,,False
11,"University of Santiago, Chile Yahoo! Labs Santiago, Chile",1,Yahoo,True
12,mauricio.silvaoy@usach.cl,0,,False
13,Torsten Suel §,0,,False
14,CSE Department Polytechnic Institute of NYU,0,,False
15,"Brooklyn, NY, 11201",0,,False
16,suel@poly.edu,0,,False
17,ABSTRACT,0,,False
18,"Positional ranking functions, widely used in web search engines, improve result quality by exploiting the positions of the query terms within documents. However, it is well known that positional indexes demand large amounts of extra space, typically about three times the space of a basic nonpositional index. Textual data, on the other hand, is needed to produce text snippets. In this paper, we study time-space tradeoffs for search engines with positional ranking functions and text snippet generation. We consider both index-based and non-index based alternatives for positional data. We aim to answer the question of whether one should index positional data or not.",1,ad,True
19,"We show that there is a wide range of practical time-space trade-offs. Moreover, we show that both position and textual data can be stored using about 71% of the space used by traditional positional indexes, with a minor increase in query time. This yields considerable space savings and outperforms, both in space and time, recent alternatives from the literature. We also propose several efficient compressed text representations for snippet generation, which are able to use about half of the space of current state-of-the-art alternatives with little impact in query processing time.",1,ad,True
20,Categories and Subject Descriptors,0,,False
21,H.3.3 [Information Storage and Retrieval]: Information Search and Retrieval; H.2.4 [Systems]: Textual databases,0,,False
22,Partially funded by Fondecyt Grant 1-110066. CONICYT Thesis Work Support Code 78100003. Partially supported by FONDEF D09I1185. §Supported by NFS Grants IIS-0803605 and IIS-1117829.,0,,False
23,"Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SIGIR'12, August 12­16, 2012, Portland, Oregon, USA. Copyright 2012 ACM 978-1-4503-1472-5/12/08 ...$15.00.",1,ad,True
24,General Terms,0,,False
25,"Algorithms, Experimentation, Performance",0,,False
26,Keywords,0,,False
27,"Positional indexing, text compression, index compression, wavelet trees, snippet generation.",0,,False
28,1. INTRODUCTION,1,DUC,True
29,"Web search has become an important part of day-to-day life, affecting even the way in which people think and remember things [35]. Indeed, web search engines are one of the most important tools that give access to the huge amount of information stored in the web. The success of a web search engine mostly depends on its efficiency and the quality of its ranking function. To achieve efficient processing of queries, search engines use highly optimized data structures, including inverted indexes [6, 10, 25]. State-ofthe-art ranking functions, on the other hand, combine simple term-based ranking schemes such as BM25 [10], link-based methods such as Pagerank [7] or Hits [24], and up to several hundred other features derived from documents and search query logs.",0,,False
30,"Recent work has focused on positional ranking functions [32, 27, 36, 28, 33, 40, 10] that improve result quality by considering the positions of the query terms in the documents. Thus, documents where the query terms occur close to each other might be ranked higher, as this could indicate that the document is highly relevant for the query. To support such positional ranking, the search engine must have access to the position data. This is commonly done by building an index for all term positions within documents, called a positional index. The goal is to obtain an index that is efficient in terms of both index size and access time.",0,,False
31,"As shown in [32], positional ranking can be carried out in two phases. First, a simple term-based ranking scheme (such as BM25) defined over a Boolean filter is used to determine a set of high-scoring documents, say, the top 200 documents. In the second phase, the term positions are used to rerank these documents by refining their score values. (Additional third or fourth phases may be used to do further reranking according to hundreds of additional features [38], but",1,ad,True
32,255,0,,False
33,"this is orthogonal to our work.) Once the final set of topscoring documents has been determined (say, the top 10), it is necessary to generate appropriate text snippets, typically text surrounding the term occurrences, to return as part of the result page. This requires access to the actual text in the indexed web pages. It is well known [40, 21] that storing position data requires a considerable amount of space, typically about 3 to 5 times the space of an inverted index storing only document identifiers and term frequencies. Furthermore, storing the documents for snippet generation requires significant additional space.",1,ad,True
34,"This paper focuses on alternative approaches to performing the above two-step document ranking process and the query snippet-generation phase. The aim is to optimize both space and query processing time. One important feature of position data is that it only needs to be accessed for a limited number of promising documents, say a few dozens or hundreds of documents. This access pattern differs from that for document identifiers and term frequencies, which are accessed more frequently, making access speed much more important. For position data, on the other hand, we could consider somewhat slower but smarter alternative representations without losing too much efficiency at query time [40].",0,,False
35,"In this paper, we push this idea further and consider not storing the position data (i.e, the positional index) at all. Instead, we compute positions on the fly from a compressed representation of the text collection. We will study two alternative approaches to compressing the text collection: (1) wavelet trees [23], which are succinct data structures from the combinatorial pattern matching community, and (2) compressed document representations that support fast extraction of arbitrary documents. It has been shown that, compared to positional indexes, web-scale texts can often be compressed in much less space [21]. More importantly, these representations can be used for both positional reranking and snippet generation. One concern is how these alternatives impact query processing speed, and thus we will study the resulting trade-offs between running time and space requirement.",1,ad,True
36,"Thus, to index or not to index position data, that is the research question that we hope to answer in this paper. To our knowledge, such alternative approaches for implementing positional ranking functions have not been rigorously compared before. Our main result is that we can store all the information needed for query processing (i.e., document identifiers, term frequencies, position data, and text) using space close to that of state-of-the-art positional indexes (which only store position data and thus cannot be used for snippet creation), with only a minor increase in query processing time. Thus, we provide new alternatives for practical compression of position and text data, outperforming recent approaches in [34].",0,,False
37,"Following current practice in search engines [21, 14], we assume a scenario where there is enough space to maintain index data structures completely in main memory, in compressed form. In this scenario, large text collections are usually partitioned over a number of nodes in a cluster, such that each partition fits into the memory of its node. This paper focuses on how to organize data within each partition, as also assumed in previous work such as [21, 14].",0,,False
38,2. BACKGROUND AND RELATED WORK,0,,False
39,"Let D ,"" {D1, . . . , DN } be a document collection of size N ,""",0,,False
40,"where each document is represented as a sequence Di[1..ni] of ni terms from a vocabulary  ,"" {1, . . . , V }. Notice that every term is represented by an integer, hence the documents are just arrays of integers. We also identify each document Di with a unique document identifier (docID) i. Given a term t   and a document Di  D, the in-document positions of t in Di is the set {j|Di[j] "", t}.",0,,False
41,"Throughout this paper, we assume that all term separators (like spaces, `,', `;', `.', etc.) have been removed from the text. Also, we assume that all terms in the vocabulary have been represented in a case-insensitive way. This is in order to facilitate the search operations that we need to carry out over the documents in order to compute (on the fly) the positions of a given query term. To be able to retrieve the original text (with separators and the original case) one can use the presentation layer introduced by Farin~a et al. [17, Section 4]. This also supports removing stopwords and the use of stemming, among other vocabulary techniques. This extra layer requires extra space on top of that of the compressed text, as well as extra time to obtain the original text. However, this scheme must be used on all the alternatives that we consider in this paper, and thus we disregard the overhead introduced by the presentation layer and focus only on the low-level details of compression (but keeping in mind that the original text can still be retrieved).",1,ad,True
42,2.1 Inverted Index Compression,0,,False
43,"The efficiency of query processing in search engines relies on inverted indexes. These data structures store a set of inverted lists I1, . . . , IV , which are accessed through a vocabulary table. The list It maintains a posting for each document containing the term t  . Usually, a posting in an inverted list consists of a docID, a term frequency, and the in-document positions of the term. (In real systems, the docIDs, term frequencies and in-document positions are often stored separately.) Indexes whose postings store indocument positions are called positional inverted indexes.",0,,False
44,"We assume that an inverted list It is divided into blocks of 128 documents each -- the particular choice of 128 documents per block is an implementation issue. Given a block of It, the term-position data for all the documents in that block are stored in a separate block of variable size. The inverted lists of the query terms are used to produce the result for the query. Since the query results are usually large, the result set must be ranked by relevance.",0,,False
45,"For large document collections, the data stored in inverted indexes requires considerable amounts of space. Hence, the indexes must be compressed. To support efficient query processing (such as DAAT [10], WAND [9] or BMW OR [15]) and effective compression in the inverted lists, we sort them by increasing docID. Let dt[1..|It|] denote the sorted list of docIDs for the inverted list It. Then, we replace dt[1] with dt[1] - 1, and dt[i] with dt[i] - dt[i - 1] - 1 for i ,"" 2, . . . , |It|. In the case of frequencies, every fi is replaced with fi - 1, since fi > 0 always holds. For the positions, each pi,j is replaced with pi,j - pi,j-1 - 1. Then these values are encoded with integer compression schemes that take advantage of the resulting smaller integers.""",1,ad,True
46,"There has been a lot of progress on compressing docIDs and frequencies, with many compression methods available [41, 10]. Some of them achieve, in general, a very good compression ratio, but at the expense of a lower decompression speed [10], for example Elias  and  encodings",0,,False
47,256,0,,False
48,"[16], or Golomb/Rice parametric encodings [22], interpolative encoding [30]. Other methods achieve a (slightly) lower compression ratio, though with much higher decompression speed, for example VByte [39], S9 [3], and PForDelta [42], among others [10]. The best compression method depends on the scenario at hand.",0,,False
49,2.2 Positional Indexes,0,,False
50,"Unfortunately, the scenario is not the same for compressing term positions, which is a problem where it has been difficult to make much progress. For instance, previous work [40] concludes that term positions in the documents do not follow simple distributions that could be used to improve compression (as is the case of, for instance, docIDs and frequencies). As a result, a positional index is about 3 to 5 times larger than a docID/frequency index, and becomes a bottleneck in index compression. Another important conclusion from [40] is that we may only have to access a limited amount of position data per query, and thus it might be preferable to use a method that compresses well even if its speed is slightly lower.",0,,False
51,"Positions in inverted indexes are used mainly in two applications, phrase searching and positional ranking schemes. In this paper we study positional ranking, where the positions of the query terms within the documents are used to improve the performance of a standard ranking such as BM25. The rationale is that documents where the query terms appear close together could be more relevant for the query, so they should get a better score. Although we focus only on positional ranking functions, the compression schemes used in this paper allow for phrase searching as well. This scenario is left for future work.",0,,False
52,"A recent work on positional indexing is that of Shan et al [34]. They propose to use the flat position indexes [11, 14] as an alternative of positional inverted indexes. The result is that docIDs, term frequencies and position data can be stored in space close to that of positional inverted lists, yielding a reduction of space usage. However, this index does not store the text, which makes it less suitable in scenarios where text snippets must be generated.",0,,False
53,2.3 Snippet Generation,0,,False
54,"Besides providing a ranking of the most relevant documents for a query, search engines must show query snippets and support accessing the ""in-cache"" version of the documents. Each snippet shows a portion of the result document, in order to help the user judge its likely relevance before accessing it. Turpin et al. [37] introduce a method to compress the text collection and support fast text extraction to generate snippets. However, to achieve fast extraction, they must use a compression scheme that uses more space than usual compressors. In a more recent work, Ferragina and Manzini [21] study how to store very large text collections in compressed form, such that the documents can be accessed when needed, and show how different compressors behave in such a scenario. One of their main concerns was how compressors can capture redundancies that arise very far apart in very long texts. Their results show that such large texts can often be compressed to just 5% of their original size.",0,,False
55,2.4 Compressed Text Self-Indexes,0,,False
56,Succinct or compressed data structures use as little space as possible to support operations as efficiently as possible.,0,,False
57,"Thus, large data sets (like graphs, trees, and text collections)",0,,False
58,"can be manipulated in main memory, avoiding the secondary",0,,False
59,"storage. In particular, we are interested in compressed data",0,,False
60,structures for text sequences. A compressed self-index is a,0,,False
61,"data structure that represents a text in compressed space,",0,,False
62,"supports indexed search capabilities on the text, and is able",0,,False
63,to obtain any text substring efficiently [31]. It can be seen,0,,False
64,as compression tools with indexed search capabilities.,0,,False
65,"Given a sequence T [1..n] over an alphabet  ,"" {1, . . . , V },""",0,,False
66,"we define operation rankc(T, i), for c  , as the number of",0,,False
67,"occurrences of c in T [1..i]. Operation selectc(T, j) is defined",0,,False
68,as the position of the j-th occurrence of c in T . A wavelet,0,,False
69,tree [23] (WT for short) is a succinct data structure that sup-,1,WT,True
70,"ports rank and select operations, among many virtues [19].",0,,False
71,"A WT representing a text T is a balanced binary search tree where each node v represents a contiguous interval v ,",1,WT,True
72,[i..j] of the sorted set . The tree root represents the whole,0,,False
73,"vocabulary. v is divided at node v into two subsets, such",0,,False
74,that,0,,False
75,the,0,,False
76,left,0,,False
77,child,0,,False
78,vl,0,,False
79,of,0,,False
80,v,0,,False
81,represents,0,,False
82,vl,0,,False
83,",",0,,False
84,[i..,0,,False
85,i+j 2,0,,False
86,"],",0,,False
87,and,0,,False
88,the,0,,False
89,right child vr,0,,False
90,represents vr,0,,False
91,",",0,,False
92,[,0,,False
93,i+j 2,0,,False
94,+ 1..j].,0,,False
95,Each tree leaf,0,,False
96,"represents a single vocabulary term. Hence, there are V",0,,False
97,"leaves and the tree has height O(log V ). For simplicity, in",0,,False
98,the following we assume that V is a power of two. Let T v be the subsequence of T formed by the symbols,0,,False
99,"in v. Hence, T root , T . Node v stores a bit sequence Bv such that Bv[l] ,"" 1 if T v[l]  vr , and Bv[l] "","" 0 otherwise. Given a WT node v of depth i, Bv[j] "","" 1 iff the i-th mostsignificant bit in the encoding of T v[j] is 1. In this way,""",1,WT,True
100,"given a term c  , the corresponding leaf in the tree can",0,,False
101,be found by using the binary encoding of c. Every node v stores Bv augmented with a data structure for rank/select,0,,False
102,"over bit sequences [31]. The number of bits of the vectors Bv stored at each tree level sum up to n, and including the",0,,False
103,"data structure every level requires n + o(n) bits. Thus, the",0,,False
104,"overall space is n log V + o(n log V ) bits [23, 31].",0,,False
105,"Since a WT replaces the text it represents, we must be able",1,WT,True
106,"to retrieve T [i], for 1  i  n. The idea is to navigate the",0,,False
107,"tree from the root to the leaf corresponding to the unknown T [i]. To do so, we start from the root, and check if Broot[i] ,",0,,False
108,"0. If so, the leaf of T [i] is contained in the left subtree vl",0,,False
109,"of the root. Hence, we move to vl looking for the symbol at position rank0(Broot, i). Otherwise, we move to vr looking for the symbol at position rank1(Broot, i). This process is",0,,False
110,"repeated recursively, until we reach the leaf of T [i], and runs",0,,False
111,in O(log V ) time as we can implement the rank operation,0,,False
112,"on bit vectors in constant time. To compute rankc(T, i), for",0,,False
113,"any c  , we proceed mostly as before, using the binary",0,,False
114,encoding of c to find the corresponding tree leaf. On the,0,,False
115,"other hand, to support selectc(T, j), for any c  , we must",0,,False
116,navigate the upward path from the leaf corresponding to,0,,False
117,term c. Both operations can be implemented in O(log V ),0,,False
118,time; see [31] for details.,0,,False
119,"The space required by a WT is, in practice, about 1.1­1.2",1,WT,True
120,"times the space of the text [12]. In our application to IR,",0,,False
121,"this would produce an index larger than the text itself, which",0,,False
122,"is excessive. To achieve compression, we can generate the",0,,False
123,Huffman codes for the terms in  (this is a word-oriented,0,,False
124,Huffman coding [29]) and use these codes to determine the,0,,False
125,"corresponding tree leaf for each term. Hence, the tree is not",0,,False
126,"balanced anymore, but has a Huffman tree shape [12] such",0,,False
127,that frequent terms will be closer to the tree root than less,0,,False
128,frequent ones. This achieves a total space of n(H0(T ) + 1) +,0,,False
129,"o(n(H0(T ) + 1)) bits, where H0(T )  log V is the zero-order",0,,False
130,257,0,,False
131,"empirical entropy of T [26]. In practice, the space is about 0.6 to 0.7 times the text size [12]. However, notice that we have no good worst-case bounds for the operations, as the length of the longest Huffman code assigned to a symbol could be O(V ).",0,,False
132,2.5 Self-Indexes for IR Applications,0,,False
133,"There have been some recent attempts to apply alternative indexing techniques, such as self-indexes, in large-scale IR systems. In particular, we mention the work by Brisaboa et al. [8] and Arroyuelo et al. [5, 4]. The former [8] concludes that WT are competitive when compared with an inverted index for finding all the occurrences of a given query term within a single text. The latter [5, 4] extends [8] by supporting more IR-like operations on a WT. The result is that a WT can represent a document collection using n(H0 (T ) + 1) + o(n(H0(T ) + 1)) bits while supporting all the functionality of an inverted index. The experimental results in [5] compare with an inverted index storing just docIDs, which of course yields a smaller index. However, WTs also store extra information, such as the term frequencies and, most important for us here, the compressed text and thus the term-position data.",1,WT,True
134,"Recent work [21] also tried to use (among other alternatives) a compressed self-index to compress web-scale texts, in order to allow decompression of arbitrary documents. Their conclusion is that compressed self-indexes still need a lot of progress in order to be competitive with standard compression tools, both in compression ratio and decompression speed. A contribution of our present work is a compressed self-index that is able to store web-scale texts and is competitive with the best state-of-the-art compressors. We think that this is a step forward in closing the gap between theory and practice in this area [20].",0,,False
135,3. CONTRIBUTIONS,0,,False
136,"In this paper we study what are the best ways to organize in-document positions and textual data, in order to efficiently support positional ranking and snippet generation in text search engines. One of our main conclusions is that some compressed representations of the textual data -- which are needed to support snippet generation -- can also be used to efficiently obtain the term positions needed by positional ranking methods. Therefore, no positional index is needed in many cases, thus saving considerable space at little cost in terms of running time.",0,,False
137,Our main contributions can be summarized as follows:,0,,False
138,"1. A study of several trade-offs for compressing position data. Rather than storing a positional index, we propose to compute the term positions from a compressed representation of the text. We explore and propose several compression alternatives. Our results significantly enhance current trade-offs between running time and memory space usage, enabling in this way more design choices for web search engines. One of our most interesting results is that both position and textual data can be stored in about 71% the space of current positional inverted indexes.",1,ad,True
139,"2. A study of several alternatives for compressing textual data, extending the alternatives studied in previous work [21]. In particular, we show that using the scheme",0,,False
140,"in [37] (to compress text and support efficient snippet generation) before using a standard compressor yields good time-space trade-offs, extending the alternatives introduced in [18]. It is important to note that variants of the scheme in [37] have been adopted by some commercial search engines, which makes our results of practical interest.",1,ad,True
141,"3. We propose several improvements over wavelet trees [23], in order to make them competitive for representing document collections. We show how to improve the compression ratio by compressing the sequence associated to every node of the tree with standard compressors. The result is a practical web-scale compressed self-index that is competitive with the best state-ofthe-art compressors.",0,,False
142,4. COMPRESSING TERM-POSITION AND TEXTUAL DATA,0,,False
143,"Compressing in-document positions, i.e., the positions where each term occur within a document, has been recognized as a difficult task [40, 21]. Indeed, positions have become a bottleneck for compression compared to docIDs and frequencies. Moreover, recent work shows that the textual data can be compressed better than positions [21]. There are two main reasons for this. First, positions have a different distribution than docIDs and frequencies [40]. Second, since positions are stored separately for each term (recall Section 2.1), the local context for terms that is exploited by text compression schemes is not available in the positional inverted lists. Usually, positions require about 3 to 5 times the space of an inverted index storing docIDs and frequencies. Thus, efficient compression of in-document positions is an important challenge.",0,,False
144,"Positional inverted indexes are the standard solution to this problem [25, 10, 6]. In particular, [40] shows a detailed study of alternative ways to compress positional inverted indexes. However, it is not clear that using the methods in [40] is the best one can do. Notice that the in-document position data can be obtained (at query time) by searching for the query terms in the documents -- a simple scan of the document suffices. Since textual data can be compressed much better than positions, this could decrease the space usage of positions. However, the question is how this impacts query performance. We investigate this issue in this paper. We assume that positions are used to support positional ranking as described in [10, 40].",0,,False
145,"Another important issue in web search engines is the ability to generate snippets for the query results that allow users to decide which of the result documents they should visit. In this context, snippets have been shown to improve the effectiveness of search engines. To provide snippets, a search engine must store a (simplified) version of the documents in the collection. In the case of web search engines, this means the entire textual web, which requires a considerable amount of resources. Thus, the textual data must be compressed [21].",0,,False
146,4.1 Basic Query Processing Steps for Positional Ranking and Snippet Extraction,1,Query,True
147,"From now on we assume a search engine where positional ranking is used to score documents, and where snippets must",0,,False
148,258,0,,False
149,"be generated for the top-scoring documents. Thus, solving a query involves the following steps:",0,,False
150,"1. Query Processing Step: Given a user query, use an inverted index to get the top-k1 documents according to some standard ranking function (e.g., BM25).",1,Query,True
151,"2. Positional Ranking Step: Given the top-k1 documents from the previous step, get the positions of the query terms within these documents. Then rerank the results using a positional ranking functions [10, 40].",0,,False
152,"3. Snippet Generation Step: After the re-ranking of previous step, get snippets of length s for the top-k2 documents, for a given k2  k1.",0,,False
153,"For instance, k1 , 200 (as in [40]) and k2 , 10 (as in most commercial search engines) are typical values for them. We assume s ,"" 10 in this paper. The different values for these parameters should be chosen according to the trade-off between query time and search effectiveness that we want to achieve. Step 2 is usually supported by a positional inverted index [25, 10, 40]. Step 3 is supported by compressing the document collection and supporting the extraction of arbitrary documents. Our focus here is on alternative ways to implement the last two steps.""",1,ad,True
154,4.2 The Baseline: Positional Inverted Lists and Compressed Textual Data,0,,False
155,This section describes and evaluates baseline approaches to support term positions indexing and snippet extraction.,0,,False
156,4.2.1 Positional Inverted Lists,0,,False
157,"Positional inverted lists (PILs, for short) are the standard approach for indexing in-document position data in search engines [25, 10, 6]. In particular, we assume the representation explained in Section 2.1. To obtain position data at query time, given the docIDs of the top-k1 results for a given query, we identify the PIL blocks containing the desired positional index entries. Then these blocks are fully decompressed, and the corresponding positions are obtained. A drawback here is that we need to decompress the entire PIL block, even if we only need a single entry in it. Thus, we might end up decompressing, in the worst case, k1 blocks in each of the inverted lists involved in the query. Afterwards, these positions are used to rerank the top-k1 documents, as in [40].",0,,False
158,"The access pattern for position data is much sparser than that for docIDs and frequencies, since positions must be obtained only for the top-k1 documents. Thus, just a few positions are decompressed from the PIL in each query. Given this sparse access pattern and the high space requirement of positions (as discussed above), it is better to use compression methods with a good compression ratio, like Golomb/Rice compression. These are slower to decompress, yet the fact that only a few positions are decompressed should not impact in the overall query running time.",0,,False
159,4.2.2 Compressed Textual Data,0,,False
160,"To compress the text collection and support decompressing arbitrary documents, a simple alternative that is used by several state-of-the-art search engines -- for instance Lucene [13] -- is to divide the whole collection into smaller text blocks, which are then compressed separately. The block",0,,False
161,"size offers a time-space trade-off: larger blocks yield better compression, although decompression time is increased. Given the popularity [13, 21] and simplicity of this approach, we use it as the baseline for the compressed text.",1,ad,True
162,4.2.3 Baseline Experiments,0,,False
163,Experimental Setup.,0,,False
164,"We show now experiments for the baseline approaches. For this we use an HP ProLiant DL380 G7 (589152-001) server, with a Quadcore Intel(R) Xeon(R) CPU E5620 @ 2.40GHz processor, with 128KB of L1 cache, 1MB of L2 cache, 2MB of L3 cache, and 96GB of RAM, running version 2.6.34.8-68.fc13.i686.PAE of Linux kernel.",1,HP,True
165,"We use the TREC GOV2 collection, with about 25.2 million documents and about 32.86 million terms in the vocabulary. We work just with the text content of the collection (that is, we ignore the html code from the documents). This requires about 127GB in ASCII format. When we represent the terms as integers, the resulting text uses 91,634 MB. We use a subset of 10,000 random queries from the query log provided with the TREC GOV2 collection. All methods were implemented using C++, and compiled with g++ 4.4.5, with the full optimization flag -O5.",1,TREC,True
166,Experiments for Step 1.,0,,False
167,"In Table 1 we show the average query time (in milliseconds per query) for the initial query processing step (Step 1 of Section 4.1). We show results for two types of queries: traditional AND queries (using DAAT query processing and BM25 ranking) and the BMW OR approach from [15], which is one of the most efficient current solutions for disjunctive queries (using a two-layer approach, which yields slightly faster query times [15]). The index for docIDs and frequencies required 9,739 MB of space, using PForDelta compression for docIDs and S16 for frequencies. Notice that the",1,ad,True
168,Table 1: Experimental results for the initial query processing step (Step 1) for AND and OR queries.,0,,False
169,top-k1 DAAT AND (ms/q) BMW OR [15] (ms/q),0,,False
170,50,0,,False
171,14.75,0,,False
172,100,0,,False
173,14.77,0,,False
174,150,0,,False
175,14.80,0,,False
176,200,0,,False
177,14.81,0,,False
178,300,0,,False
179,14.81,0,,False
180,35.70 43.39 47.90 51.74 58.19,0,,False
181,"query time for AND is almost constant (within two decimal digits) with respect to k1. The process to obtain the topk1 documents uses a heap (of size k1). However, operating the heap takes negligible time, compared to the decompression of docIDs and the DAAT process. BMW OR, on the other hand, is an early-termination technique, and thus k1 impacts the query time.",0,,False
182,Experiments for Step 2.,0,,False
183,"In Table 2 (first two rows) we show experimental results for obtaining positions with the baseline PILs, using two compression schemes: Rice and S16, which offer the most interesting trade-offs [40]. We also show query times for different values of k1, namely 50, 100, 150, 200 and 300 (the experiments in [40] only use k1 ,"" 200). As we can see, Rice""",1,ad,True
184,259,0,,False
185,"requires only about 90% the space of S16, but takes twice as much time. Comparing the query times of Step 2 for Rice and S16 with the query times of Step 1 in Table 1, we can see that position extraction is a small fraction of the overall time. Hence, we can use Rice to compress PILs and obtain a better space usage with only a minor increase in query time. For Rice, PILs use 2.91 times the space of the inverted index that stores docIDs and frequencies. For S16, this number is 3.22.",0,,False
186,Experiments for Step 3.,0,,False
187,"Table 3 shows experimental results for the baseline for compressed textual data. Just as in [21], we divide the text into blocks of 0.2MB, 0.5MB or 1.0MB, and compress each block using different standard text compression tools. In particular, we show results for lzma (which gives very good results in [21]) and Google's snappy compressor [1], which is an LZ77 compressor that is optimized for speed rather than compression ratio. These two compressors offer the most interesting trade-offs among the alternatives we tried. As it can be seen, lzma achieves much better compression ratios than snappy. The compressed space achieved for the whole text is 8,133 MB for lzma and 27,388 MB for snappy.",1,ad,True
188,"The differences in extraction time are also considerable, with snappy being much faster. Note that [21] reports a decompression speed of about 35MB/sec for lzma. However, to obtain a given document we must first decompress the entire block that contains it. Hence, most of the 35MB per second do not correspond to any useful data. In other words, this does not measure effective decompression speed for our scenario, and thus we report per-query times rather than MB/s for both methods.",0,,False
189,4.3 Computing Positions and Snippets from the Compressed Document Collection,0,,False
190,"We explore next the alternative of obtaining position data directly from the compressed text. This implies that in Step 2 of the query process, k1 documents must be decompressed, rather than only k2 in Step 3, as in the baseline.",0,,False
191,Using Standard Text Compressors.,0,,False
192,"Our first approach is to obtain positions using the baseline for generating snippets from Section 4.2.2. In rows 3 and 4 of Table 2 we show the time-space trade-offs for this approach, using lzma and snappy compressors, and blocks of size 0.2 MB. We conclude that using lzma we can store positions and text in about half the space of PIL(the latter just storing positions). However, this approach is two orders of magnitude slower than the positional index. If we use snappy instead, we obtain an index that is 21.86% larger than PIL (Rice), and running times to obtain positions that are about an order of magnitude slower (this might be acceptable in some cases). In the following, we try to improve on both of these techniques.",1,ad,True
193,Zero-order Compressors with Fast Text Extraction.,0,,False
194,"An alternative to compressing the text that could support faster position lookups is the approach from Turpin et al. [37]. The idea is to first sort the vocabulary according to the term frequencies, and then assign term identifiers according to this order. In this way, the term identifier 0 corresponds to the most frequent term in the collection, 1",0,,False
195,"to the second most frequent term, and so on. The document collection is then represented as a single sequence of identifiers, where each term identifier is encoded using VByte [2]. Note that the 128 most frequent terms in the collection are thus encoded in a single byte. Actually, [37] uses a move-to-front strategy to store the encodings: the first time a term appears in a document, it is encoded with the original code assigned as before; the remaining appearances are represented as an offset to the previous occurrence of the term. We also use this approach in our experiments.",0,,False
196,"By using an integer compression scheme (such as VByte) for the text, we are able to decompress any text portion very efficiently (no text blocks are needed this time). Table 2 shows the resulting trade-offs for this alternative (see the row for ""VByte""). Notice that we improve the query time significantly, making it competitive with PILs. The higher space usage is a concern, but note that we also represent the text within this space, not just the position data as in PILs. We also tried other compression schemes, such as PForDelta and S9, obtaining poorer compression ratios and similar decompression speed. The only method that improved the compression ratio is VNibble, a variant of VByte that represents any integer with a variable number of nibbles (i.e., half bytes). As in VByte, one bit of each nibble is used as a continuation bit, so only 3 bits of each nibble are used to represent the number. The results of Table 2 show space savings of about 10% over VByte. Also, notice that we are now able to use space close to that of snappy (with blocks of 0.2 MB), yet with a better query time.",1,ad,True
197,"The fast query time is due to two facts. First, methods like VByte and VNibble are able to decompress hundred of million integers (which in our case correspond to terms) per second [41]. Second, VByte and VNibble are able to decompress just the desired documents, without negative impact on compressed size. However, this is basically zeroorder compression, and hence we are still far from the space usage of, for instance, lzma. We address this next.",1,ad,True
198,Natural-Language Compression Boosters.,0,,False
199,"To obtain higher-order compression, we propose to use a so-called natural-language compression booster [18]. The idea is to use first a zero-order compressor on the text, then this compressed text is further compressed using some standard compression scheme. It has been shown that this can yield better compression ratios than just just using a standard compression scheme [18] (especially for smaller block sizes). In our case, we propose using Turpin et al's approach [37] as booster (using VByte and VNibble as we explained above) on the sequence of term identifiers, rather than Word Huffman or End-Tagged as in [18]. Our experiments indicate that the former are faster and use only slightly more space than the latter.",0,,False
200,"In Table 2 we show the trade-offs for this approach (see the rows for approach ""Compression Boosters""). We show results for blocks of size 0.001, 0.01, 0.05, and 0.2 MB of VByte and VNibble compressed text. Overall, the reduction in space usage (compared to the original VByte approach) is considerable. Compared to lzma (0.2 MB), the result is a reduction in space usage of 16.68% (12,486 MB vs 14,987 MB), but at the cost of twice the running time as the original lzma. When using smaller blocks, however, the time to obtain positions rapidly improves, while the size does not increase too much. For snappy, on the other hand, we obtain a",1,ad,True
201,260,0,,False
202,Approach,0,,False
203,Positional indexes Text compressors Zero-order Compressors Compression Boosters,0,,False
204,Compressed self-indexes,0,,False
205,Table 2: Experimental results for extracting term-position data (Step 2).,0,,False
206,Compression Scheme,0,,False
207,Space Usage,0,,False
208,Position extraction time (ms/q),0,,False
209,(MB),0,,False
210,"k1 , 50 k1 , 100 k1 , 150 k1 , 200 k1 , 300",0,,False
211,PIL(Rice) PIL(S16),0,,False
212,"28,373",0,,False
213,1.28,0,,False
214,2.22,0,,False
215,3.05,0,,False
216,3.27,0,,False
217,5.57,0,,False
218,"31,338",0,,False
219,0.74,0,,False
220,1.12,0,,False
221,1.43,0,,False
222,1.75,0,,False
223,2.51,0,,False
224,lzma (0.2 MB) snappy (0.2 MB),0,,False
225,"14,987 34,576",0,,False
226,137.60 260.36,0,,False
227,9.47,0,,False
228,18.00,0,,False
229,375.21 25.95,0,,False
230,482.09 33.49,0,,False
231,684.94 47.74,0,,False
232,VByte VNibble,0,,False
233,"38,339",0,,False
234,0.95,0,,False
235,1.91,0,,False
236,2.86,0,,False
237,3.81,0,,False
238,5.72,0,,False
239,"34,570",0,,False
240,1.86,0,,False
241,3.71,0,,False
242,5.57,0,,False
243,6.75,0,,False
244,8.10,0,,False
245,VByte + lzma (0.2 MB) VByte + lzma (0.05 MB) VByte + lzma (0.01 MB) VByte + lzma (0.001 MB),0,,False
246,"12,486 13,981 16,762 22,340",0,,False
247,256.16 70.32 19.26 6.11,0,,False
248,484.35 133.18 36.51 11.60,0,,False
249,716.41 192.09 52.67 16.80,0,,False
250,906.54 246.94 68.00 21.72,0,,False
251,"1,284.87 351.71 97.04 31.10",0,,False
252,VByte + snappy (0.2 MB) VByte + snappy (0.05 MB) VByte + snappy (0.01 MB) VByte + snappy (0.001 MB),0,,False
253,"20,158 20,366 22,086 27,919",0,,False
254,9.71,0,,False
255,18.86,0,,False
256,26.41,0,,False
257,34.01,0,,False
258,48.69,0,,False
259,2.36,0,,False
260,4.48,0,,False
261,6.47,0,,False
262,8.36,0,,False
263,11.95,0,,False
264,0.82,0,,False
265,1.56,0,,False
266,2.25,0,,False
267,2.91,0,,False
268,4.17,0,,False
269,0.45,0,,False
270,0.86,0,,False
271,1.24,0,,False
272,1.60,0,,False
273,2.30,0,,False
274,WT(7 KB) WT(1 KB),1,WT,True
275,"40,534",0,,False
276,1.94,0,,False
277,3.68,0,,False
278,5.30,0,,False
279,6.85,0,,False
280,9.80,0,,False
281,"56,917",0,,False
282,0.33,0,,False
283,0.62,0,,False
284,1.04,0,,False
285,1.15,0,,False
286,1.75,0,,False
287,WT(7 KB) + lzma WT(1 KB) + lzma,1,WT,True
288,"19,628 42,359",0,,False
289,19.25 7.22,0,,False
290,36.59 13.54,0,,False
291,52.83 19.44,0,,False
292,68.36 24.97,0,,False
293,97.71 35.57,0,,False
294,WT(7 KB) + snappy WT(1 KB) + snappy,1,WT,True
295,"25,122 46,778",0,,False
296,14.35 2.07,0,,False
297,23.76 3.61,0,,False
298,39.38 5.88,0,,False
299,51.02 7.32,0,,False
300,74.56 10.47,0,,False
301,Table 3: Experimental results for compressing the document collection (Step 3).,0,,False
302,Compressor Block size Space usage Compression Ratio Snippet extraction time (ms/q),0,,False
303,(MB),0,,False
304,(MB),0,,False
305,"k2 , 10 k2 , 30 k2 , 50",0,,False
306,lzma,0,,False
307,0.2,0,,False
308,"14,987",0,,False
309,0.5,0,,False
310,"13,489",0,,False
311,1.0,0,,False
312,"12,682",0,,False
313,16.35 14.72 13.84,0,,False
314,29,0,,False
315,84,0,,False
316,136,0,,False
317,63,0,,False
318,181,0,,False
319,292,0,,False
320,117,0,,False
321,335,0,,False
322,540,0,,False
323,snappy,0,,False
324,0.2,0,,False
325,"34,576",0,,False
326,0.5,0,,False
327,"34,426",0,,False
328,1.0,0,,False
329,"34,390",0,,False
330,37.73 37.57 37.53,0,,False
331,2,0,,False
332,6,0,,False
333,9,0,,False
334,5,0,,False
335,14,0,,False
336,23,0,,False
337,10,0,,False
338,28,0,,False
339,46,0,,False
340,"reduction of 41.69% in space for blocks of size 0.2 MB, with a very minor increase in query time. When we reduce the block size to 0.05 MB, the query time improves even more, and becomes competitive with the time to obtain positions from PIL (Rice). We note that using more advanced techniques from [40] we could obtain about 21 to 22 GB of space for PIL, making both techniques competitive in both space and time. However, VByte + snappy also contains the text within this space, allowing for use during snippet generation. Thus, we are able to store both text and positions in a representation that uses less space than PIL, which stores only positions.",1,ad,True
341,4.4 A Compressed Self-Index for Positions and Snippets,0,,False
342,"Let T be the text obtained from the concatenation (in arbitrary order) of the documents in the collection. We represent T with a WT to obtain term positions and text snippets. Given a position i in T , one can easily obtain both the docID of the document that contains T [i] and the starting",1,WT,True
343,"position of a given document j by means of operations rank and select [5], assuming a table of document lengths.",0,,False
344,Byte-Oriented Huffman WT.,1,WT,True
345,"Instead of a bit-oriented WT (as the ones explained in Section 2.4), we use the byte-oriented representation from [8], using the Plain Huffman encoder, which is the most efficient alternative reported in there. The idea is to first assign a Huffman code to each vocabulary term [29]. Then, we store the most significant byte of the encoding of each term in array Broot. That is, each WT node v stores an array of bytes Bv, instead of bit arrays as in Section 2.4. Next, each term in the text is assigned to one of the children of the root, depending on the first byte in the encodings. Notice that in this way the WT is 256-ary. See [8] for details.",1,ad,True
346,"To support rank and select, we use the simple approach from [8]. Given a WT node v, we divide the corresponding byte sequence Bv into superblocks of sb bytes each. For each superblock we store 256 superblock counters, one for each possible byte. These counters tell us how many occurrences",1,WT,True
347,261,0,,False
348,"of a given byte there are in the text up to the last position of the previous superblock. Also, each superblock is divided into blocks of b bytes each. Every such block also stores 256 block counters, similarly as before. The difference is that the values of these counters are local to the superblock, hence less bits are used for them. To compute rankc(T, i), we first compute the superblock j that contains i, and use the superblock counter for c to count how many c there are in T up to superblock j - 1. Then we compute the block i that contains i and add (to the previous value) the block counter for c. Finally, we must count the number of c within block i . This is done with a sequential scan over block i . This block/superblock structure allows for time-space trade-offs. In our experiments we use sb ,"" 216. Hence, superblock counters can be stored in 16 bits each. We consider b "","" 1 KB, b "", 3 KB and b , 7 KB. Operation select is implemented by binary searching the superblock/block counters; thus no extra information is stored for this [8].",1,ad,True
349,"To obtain position data assume that, given docID i for a top-k1 document and a query term t, we want to obtain the positions of t within Di. A simple solution could be to extract document Di from the WT, and then search for t within it (as in Section 4.3). However, the decompression speed of a WT is much slower than that of the schemes used in Section 4.3, so we must use a more efficient way. An idea is to use operation select to find every occurrence of t within Di, hence working in time proportional to the number of occurrences of the term. Let d be the starting position for document Di in T . Hence, there are r  rankt(T, d) occurrences of t before document Di, and the first occurrence of t within Di is at position j  selectt(T, r + 1), the second occurrence at position j  selectt(T, r + 2), and so on. Overall, if o is the number of occurrences of t within Di, then we need 1 rank and o + 1 selects to find them.",1,WT,True
350,"In Table 2 we show the experimental trade-offs for WT, for the different block sizes tested. As it can be seen, WT (7 KB) requires space close to (though slightly larger than) that of the VByte approach. WT (3 KB) and WT (1 KB) obtain better times, but requiring even more space. Moreover, WT (7 KB) is slower than PIL (Rice) and uses more space. The WT, on the other hand, includes the textual data, but still this space usage could leave it out of competition. Next, we introduce extra improvements to make them more competitive.",1,ad,True
351,Achieving Higher-Order Compression with the WT.,1,WT,True
352,"Basically, WTs are zero-order compressors, which explains their high space usage. To achieve higher-order compression, notice that Broot contains the most significant byte of the Huffman encodings of the original terms. Thus, the original text structure is at least partially preserved in the structure of Broot, which might thus be as compressible as the original text. A similar behavior can be observed in internal nodes. Thus, we propose to compress the blocks of Bv in each WT node v by using some standard compressor.",1,WT,True
353,"Table 2 shows results for lzma and snappy, the best compressors we tried. Notice that WT (7 KB) + lzma achieves 19,628 MB, almost half the space used by WT (7 KB). The time to obtain positions becomes, on the other hand, an order of magnitude larger. WT (7 KB) + snappy achieves slightly better times, but using more space. Also, WT (7 KB) + lzma uses slightly less space than VByte + snappy (0.2 MB), but is somewhat slower. Overall, this significant reduction in space could make WTcompetitive.",1,WT,True
354,5. EXPERIMENTAL RESULTS,0,,False
355,"We now show the time-space trade-offs for the overall solution space we explored. We use here the same basic setup as in Section 4.2.3, with the same parameters (block sizes) for each alternative. We consider the most competitive indexing alternatives from previous sections for positions and snippet generation, described in Table 4. All results include the time and space of the inverted index to carry out Step 1 of the query process, as well as of all structures used in Steps 2 and 3.",1,ad,True
356,Table 4: Glossary of the indexing schemes used in,0,,False
357,Figure 1. All schemes include the inverted index.,0,,False
358,Indexing Scheme Description,0,,False
359,Scheme 1,0,,False
360,WT for positions and text.,1,WT,True
361,Scheme 2,0,,False
362,WT compressed with lzma for,1,WT,True
363,positions and text.,0,,False
364,Scheme 3,0,,False
365,WT compressed with snappy for,1,WT,True
366,positions and text.,0,,False
367,Scheme 4,0,,False
368,Text compressed with VByte/,0,,False
369,VNibble for positions and text.,0,,False
370,Scheme 5,0,,False
371,VByte compression booster on,0,,False
372,snappy for positions and text.,0,,False
373,Scheme 6,0,,False
374,PIL (Rice) for positions and VByte/,0,,False
375,VNibble for text.,0,,False
376,"Note that only Scheme 6 stores an index for position data. Figure 1 shows the different trade-offs for DAAT AND queries with BM25 ranking. Conclusions for OR queries are similar to that for AND. We only show results for k1 ,"" 200 and k2  {10, 50}, which are representative of other values we tested.""",1,ad,True
377,"As can be seen, Scheme 6, which uses PIL for positions and Turpin et al [37] for snippets, has one of the fastest query times among all alternatives, but space usage is high compared to other methods. This is because this scheme needs to store positions and text separately. The two points for Scheme 6 that are plotted correspond to using VByte (higher space usage) and VNibble.",0,,False
378,"Scheme 1 also offers a competitive query time (among the fastest alternatives), but still uses a considerable amount of space. The time-space trade-offs for the schemes that use WT are obtained for different block sizes within the WT nodes (1 to 7 KB). Scheme 2 and Scheme 3 compress the byte sequences of each WT node (as proposed in Section 4.4). As can be seen, the space usage is improved significantly, in some cases by a factor of two. However, query time degrades, making these alternatives less compelling.",1,ad,True
379,"Scheme 4 is very competitive in query time, but again its space usage is high. Scheme 5 corresponds to the compression boosters proposed in Section 4.3, and it obtains a very impressive trade-off. One of the most interesting settings is for blocks of size 0.05 MB. In this case, the overall space usage is 1.06 times the space of PIL (Rice), with a query time 1.21 times higher than Scheme 4 and 1.23 times higher than Scheme 6 (which uses PIL). For blocks of size 0.01 MB, Scheme 5 requires 1.12 times the space of PIL (Rice), with a query time that is 0.96 times the one of Scheme 4, and 0.98 the one of Scheme 6. Thus, using only slightly more space than PIL (Rice) (recall the results in Table 2), Scheme 5 includes everything needed for query processing: docIDs, frequencies, term positions, and the text needed to gener-",1,ad,True
380,262,0,,False
381,Overall query time (ms per query) Overall query time (ms per query),0,,False
382,"Time-space trade-offs k1 ,"" 200, k2 "", 10",1,ad,True
383,200,0,,False
384,Scheme 1,0,,False
385,Scheme 2,0,,False
386,Scheme 3,0,,False
387,Scheme 4,0,,False
388,150,0,,False
389,Scheme 5,0,,False
390,Scheme 6,0,,False
391,100,0,,False
392,50,0,,False
393,"Time-space trade-offs k1 ,"" 200, k2 "", 50",1,ad,True
394,250 200 150 100,0,,False
395,50,0,,False
396,0 25 30 35 40 45 50 55 60 65 70 75 80,0,,False
397,Index size (GB),0,,False
398,0 25 30 35 40 45 50 55 60 65 70 75 80,0,,False
399,Index size (GB),0,,False
400,"Figure 1: Time-space trade-offs for the overall query process for the GOV2 collection, including positional ranking and snippet generation. The size of each alternative includes the size of inverted index with docIDs and frequencies, which for the TREC GOV2 collection requires 9,739MB.",1,ad,True
401,"ate snippets. This is one of the most important conclusions in this paper, that ""not to index"" can be a real alternative for positional data in practical scenarios. As stated in Section 4.3, the space usage of PILs can be reduced to about 21 GB­22 GB for the TREC GOV2 collection [40]. However, we would still need to add the inverted index and the compressed text to that space in order to support all query processing steps.",1,TREC,True
402,"Finally, the smallest space alternatives we tested (which are not shown in Figure 1) are the ones that use the inverted index for query processing and lzma compression for positions and snippets. This achieves about 22,225 MB of space. This scheme includes everything needed for query processing, and uses only 78% the space of PIL. However, query processing time increases significantly, to more than 400 ms per query. This scheme could be useful in some cases where the available memory space is very restricted, such that a larger index would mean going to disk.",0,,False
403,"A recent alternative [34] proposes to use flat positional indexes [11, 14] to support phrase querying; this index could also be used for positional ranking. This is basically a positional index from which docID and frequency information can also be obtained. The results reported for the GOV2 collection in [34] give an index of size 30,310 MB that includes docIDs and frequencies, but not the text needed for snippet generation, making this approach uncompetitive for our scenario.",0,,False
404,6. CONCLUSIONS,0,,False
405,"From our study we can conclude that there exists a wide range of practical time-space trade-offs, other than just the classical positional inverted indexes. We studied several alternatives, trying to answer the question of whether it is necessary to index position data or not. As one of the most relevant points in the trade-off, we propose a compressed document representation based on the approach in [37] combined with Google's snappy compression [1]. This allows us to compute position and snippet data using less space than a standard positional inverted index that only stores position data. Even if we include the space used for document identifiers and term frequencies, this approach uses just 1.12",1,ad,True
406,"times the space of a positional inverted index, with the same or slightly better query time.",0,,False
407,"This means that in many practical cases, ""not to index"" position data may be the most efficient approach. This provides new practical alternatives for positional index compression, a problem that has been considered difficult to address in previous work [40, 21]. Finally, we also showed that compressed self-indexes such as wavelet trees [23] can be competitive with the best solutions in some scenarios.",1,ad,True
408,7. REFERENCES,0,,False
409,[1] http://code.google.com/p/snappy/. [2] V. N. Anh and A. Moffat. Compressed inverted files,0,,False
410,"with reduced decoding overheads. In Proc. of 21st Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 290­297, 1998. [3] V. N. Anh and A. Moffat. Inverted index compression using word-aligned binary codes. Inf. Retr., 8(1):151­166, 2005. [4] D. Arroyuelo, V. Gil-Costa, S. Gonz´alez, M. Marin, and M. Oyarzu´n. Distributed search based on self-indexed compressed text. Information Processing and Management, 2012. To appear. [5] D. Arroyuelo, S. Gonz´alez, and M. Oyarzu´n. Compressed self-indices supporting conjunctive queries on document collections. In SPIRE, LNCS 6393, pages 43­54, 2010. [6] R. Baeza-Yates and B. Ribeiro-Neto. Modern Information Retrieval - the Concepts and Technology Behind Search, Second Edition. Pearson Education Ltd., Harlow, England, 2011. [7] S. Brin and L. Page. The anatomy of a large-scale hypertextual web search engine. J. of Computer Networks, 30(1­7):107­117, 1998. [8] N. Brisaboa, A. Farin~a, S. Ladra, and G. Navarro. Implicit indexing of natural language text by reorganizing bytecodes. Information Retrieval, 2012. To appear. [9] A. Z. Broder, D. Carmel, M. Herscovici, A. Soffer, and J. Zien. Efficient query evaluation using a two-level",1,ad,True
411,263,0,,False
412,"retrieval process. In Proc. of 12th International Conference on Information and Knowledge Management, pages 426­434. ACM, 2003. [10] S. Bu¨ttcher, C. Clarke, and G. Cormack. Information Retrieval: Implementing and Evaluating Search Engines. MIT Press, 2010. [11] C. Clarke, G. Cormack, and F. Burkowski. An algebra for structured text search and a framework for its implementation. Computer Journal, 38(1):43­56, 1995.",0,,False
413,"[12] F. Claude and G. Navarro. Practical rank/select queries over arbitrary sequences. In SPIRE, LNCS 5280, pages 176­187. Springer, 2008.",0,,False
414,[13] D. Cutting. Apache Lucene. http://lucene.apache.org/.,0,,False
415,"[14] J. Dean. Challenges in building large-scale information retrieval systems: invited talk. In WSDM, page 1, 2009.",0,,False
416,"[15] S. Ding and T. Suel. Faster top-k document retrieval using block-max indexes. In Proc. of 34th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 993­1002, 2011.",0,,False
417,"[16] P. Elias. Universal codeword sets and representations of the integers. IEEE Transactions on Information Theory, 21(2):194­203, 1975.",0,,False
418,"[17] A. Farin~a, N. Brisaboa, G. Navarro, F. Claude, A. Places, and E. Rodr´iguez. Word-based self-indexes for natural language text. ACM Transactions on Information Systems (TOIS), 30(1):article 1, 2012.",0,,False
419,"[18] A. Farin~a, G. Navarro, and J. Parama´. Boosting text compression with word-based statistical encoding. Computer Journal, 55(1):111­131, 2012.",0,,False
420,"[19] P. Ferragina, R. Giancarlo, and G. Manzini. The myriad virtues of wavelet trees. Information and Computation, 207(8):849­866, 2009.",1,ad,True
421,"[20] P. Ferragina, R. Gonz´alez, G. Navarro, and R. Venturini. Compressed text indexes: From theory to practice. ACM Journal of Experimental Algorithmics, 13, 2008.",0,,False
422,"[21] P. Ferragina and G. Manzini. On compressing the textual web. In WSDM, pages 391­400, 2010.",0,,False
423,"[22] S. Golomb. Run-length encoding. IEEE Transactions on Information Theory, 12(3):399­401, 1966.",0,,False
424,"[23] R. Grossi, A. Gupta, and J. S. Vitter. High-order entropy-compressed text indexes. In SODA, pages 841­850, 2003.",0,,False
425,"[24] J. M. Kleinberg. Authoritative sources in a hyperlinked environment. J. of ACM, 46(5):604­632, 1999.",0,,False
426,"[25] C. Manning, P. Raghavan, and H. Schu¨tze. Introduction to Information Retrieval. Cambridge University Press, 2008.",0,,False
427,"[26] G. Manzini. An analysis of the Burrows-Wheeler transform. J. ACM, 48(3):407­430, 2001.",0,,False
428,"[27] D. Metzler and W. B. Croft. A markov random field model for term dependencies. In Proc. of 28th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, 2005.",0,,False
429,"[28] G. Mishne and M. Rijke. Boosting web retrieval through query operations. In Proc. of 27th European Conference on IR Research, 2005.",0,,False
430,"[29] A. Moffat. Word-based text compression. Software, Practice, and Experience, 19(2):185­198, 1989.",0,,False
431,"[30] A. Moffat and L. Stuiver. Binary interpolative coding for effective index compression. Inf. Retr., 3(1):25­47, 2000.",0,,False
432,"[31] G. Navarro and V. M¨akinen. Compressed full-text indexes. ACM Computing Surveys, 39(1), 2007.",0,,False
433,"[32] Y. Rasolofo and J. Savoy. Term proximity scoring for keyword-based retrieval systems. In Proc. of 25th European Conference on IR Research, 2003.",0,,False
434,"[33] R. Schenkel, A. Broschart, S. Hwang, M. Theobald, and G. Weikum. Efficient text proximity search. In 14th String Processing and Information Retrieval Symposium, 2007.",0,,False
435,"[34] D. Shan, W. X. Zhao, J. He, R. Yan, H. Yan, and X. Li. Efficient phrase querying with flat position index. In CIKM, pages 2001­2004, 2011.",0,,False
436,"[35] B. Sparrow, J. Liu, and M. Wegner. Google effects on memory: Cognitive consequences of having information at our fingerprints. Science, 333(6043):776­778, 2011.",0,,False
437,"[36] T. Tao and C. Zhai. An exploration of proximity measures in information retrieval. In Proc. of 30th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, 2007.",0,,False
438,"[37] A. Turpin, Y. Tsegay, D. Hawking, and H. Williams. Fast generation of result snippets in web search. In Proc. of 30th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 127­134, 2007.",0,,False
439,"[38] L. Wang, J. J. Lin, and D. Metzler. A cascade ranking model for efficient ranked retrieval. In Proc. of 34th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 105­114, 2011.",1,ad,True
440,"[39] H. Williams and J. Zobel. Compressing integers for fast file access. Computer Journal, 42(3):193­201, 1999.",0,,False
441,"[40] H. Yan, S. Ding, and T. Suel. Compressing term positions in web indexes. In Proc. of 32nd Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 147­154, 2009.",0,,False
442,"[41] H. Yan, S. Ding, and T. Suel. Inverted index compression and query processing with optimized document ordering. In WWW, pages 401­410, 2009.",0,,False
443,"[42] M. Zukowski, S. H´eman, N. Nes, and P. Boncz. Super-scalar ram-cpu cache compression. In ICDE, page 59, 2006.",0,,False
444,264,0,,False
445,,0,,False
