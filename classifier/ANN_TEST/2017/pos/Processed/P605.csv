,sentence,label,data,regex
0,Session 5C: Efficiency and Scalability,1,Session,True
1,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
2,BitFunnel: Revisiting Signatures for Search,0,,False
3,Bob Goodwin,0,,False
4,Microsoft,0,,False
5,Alex Clemmer,0,,False
6,Heptio,0,,False
7,Michael Hopcroft,0,,False
8,Microsoft,0,,False
9,Mihaela Curmei,0,,False
10,Microsoft,0,,False
11,Dan Luu,0,,False
12,Microsoft,0,,False
13,Sameh Elnikety,0,,False
14,Microsoft,0,,False
15,Yuxiong He,0,,False
16,Microsoft,0,,False
17,ABSTRACT,0,,False
18,"Since the mid-90s there has been a widely-held belief that signature files are inferior to inverted files for text indexing. In recent years the Bing search engine has developed and deployed an index based on bit-sliced signatures. This index, known as BitFunnel, replaced an existing production system based on an inverted index. The driving factor behind the shift away from the inverted index was operational cost savings. This paper describes algorithmic innovations and changes in the cloud computing landscape that led us to reconsider and eventually field a technology that was once considered unusable. The BitFunnel algorithm directly addresses four fundamental limitations in bit-sliced block signatures. At the same time, our mapping of the algorithm onto a cluster offers opportunities to avoid other costs associated with signatures. We show these innovations yield a significant efficiency gain versus classic bit-sliced signatures and then compare BitFunnel with Partitioned Elias-Fano Indexes, MG4J, and Lucene.",1,ad,True
19,CCS CONCEPTS,0,,False
20,· Information systems  Search engine indexing; Probabilistic retrieval models; Distributed retrieval; · Theory of computation  Bloom filters and hashing;,0,,False
21,KEYWORDS,0,,False
22,Signature Files; Search Engines; Inverted Indexes; Intersection; Bitvector; Bloom Filters; Bit-Sliced Signatures; Query Processing,1,Query,True
23,1 INTRODUCTION,1,DUC,True
24,"Commercial search engines [2, 5, 19, 24] traditionally employ inverted indexes. In this work, we show how to use signatures, or bit-strings based on Bloom filters [1], in a large-scale commercial search engine for better performance. Prior work comparing inverted files to signature files established that inverted files outperformed signature files by almost every criterion [28]. However, recent software and hardware trends (e.g., large Web corpora with",1,ad,True
25,"Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. SIGIR '17, August 07-11, 2017, Shinjuku, Tokyo, Japan © 2017 Copyright held by the owner/author(s). Publication rights licensed to Association for Computing Machinery. ACM ISBN 978-1-4503-5022-8/17/08. . . $15.00 https://doi.org/10.1145/3077136.3080789",1,ad,True
26,"of billions of documents, large main memory systems) motivated us to reconsider signature files.",0,,False
27,"In our signature-based approach, known as BitFunnel, we use a Bloom filter to represent the set of terms in each document as a fixed sequence of bits called a signature. Bloom filters are reasonably space efficient and allow for fast set membership, forming the basis for query processing.",0,,False
28,"Using this approach, however, poses four major challenges. First, determining the matches for a single term requires examining one signature for each document in the corpus. This involves considerably more CPU and memory cycles than the equivalent operation on an inverted index. Second, term frequency follows a Zipfian distribution, implying that signatures must be long to yield an acceptable false positive rate when searching for the rarest terms. Third, the size of web documents varies substantially, implying that signatures must be long to accommodate the longest documents. Fourth, the configuration of signature-based schemes is not a well-understood problem.",0,,False
29,We develop a set of techniques to address these challenges: (1) we introduce higher rank rows to reduce query execution time; (2) we employ frequency-conscious signatures to reduce the memory footprint; (3) we shard the corpus to reduce the variability in document size; (4) we develop a cost model for system performance; and (5) we use this model to formulate a constrained optimization to configure the system for efficiency.,1,ad,True
30,"These techniques are used in the Microsoft Bing search engine, which has been running in production for the last four years on thousands of servers. Compared to an earlier production search engine based on inverted lists that it replaced, BitFunnel improved server query capacity by a factor of 10.",0,,False
31,2 BACKGROUND AND PRIOR WORK,0,,False
32,We focus on the problem of identifying those documents in a corpus that match a conjunctive query of keywords. We call this the Matching Problem.,0,,False
33,"Let corpus C be a set of documents, each of which consists of a set of text terms:",0,,False
34,"C , {documents D} D , {terms t }",0,,False
35,Define query Q as a set of text terms:,0,,False
36,"Q , {terms t }",0,,False
37,605,0,,False
38,Session 5C: Efficiency and Scalability,1,Session,True
39,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
40,"Query Q is said to match document D when every term t  Q is also an element of D. This happens when Q  D or Q , Q  D. Define match set M as the set of documents matching Q:",1,Query,True
41,"M , {D  C | Q , D  Q}",0,,False
42,"The goal of the Matching Problem is to identify the match set M, given corpus C and query Q.",0,,False
43,"In Sections 2.2-2.4 we examine conservative probabilistic algorithms that never miss a match, but might falsely report matches. The goal for these algorithms is to identify a conservative filter set M ",0,,False
44,"M  M  C where the false positive set F , M  \ M is small.",0,,False
45,2.1 Inverted Indexes,0,,False
46,"Perhaps the most common approach to the Matching Problem is the inverted index [4, 11]. This approach maintains a mapping from each term in the lexicon to the the set of documents containing the term. In other words,",0,,False
47,"Postins(t) , {D  C | t  D}",0,,False
48,"With this approach, M can be formed by intersecting the posting sets associated with the terms in the query:",0,,False
49,"M , Postins(t)",0,,False
50,t Q,0,,False
51,"In practice, the posting sets are usually sorted, allowing fast intersection. They also draw on a large bag of tricks [4, 20] to compress and decompress posting sets [17, 23] while improving intersection time [6, 7]. This is a rich area with ongoing research into novel data structures such as treaps [16] and semi-bitvectors [13].",0,,False
52,"Inverted indexes find the exact match set, M, every time. Signaturebased approaches [8­10, 15, 25], on the other hand, use probabilistic algorithms, based on superimposed coding [1, 21, 22] and newer approaches, like TopSig [12] to identify a conservative filter set M . BitFunnel is based on classical bit-sliced signatures which are, in turn, based on bit-string signatures.",0,,False
53,2.2 Bit-String Signatures,0,,False
54,"The key idea is that each document in the corpus is represented by its signature. In BitFunnel, the signature is essentially the sequence of bits that make up a Bloom filter representing the set of terms in the document. In constructing the Bloom filter, each term in the document is hashed to a few bit positions, each of which is set to 1.",0,,False
55,"Let n denote the number of bit positions in the Bloom filter. Define H (n, t) as a function that returns the set of bit positions in the range [0..n) corresponding to the hashes of term t. Define s#»t , the signature of term t, as the bit-vector of length-n where bit position i is set to 1 iff i  H (n, t). We can then define the signature of document D as the logical-or of the signatures of its terms:",0,,False
56,"s#D» , s#»t",0,,False
57,t D,0,,False
58,"In a similar manner, we can define the signature of query Q as the logical-or of the signatures of its terms:",0,,False
59,"s#Q» , s#»t",0,,False
60,t Q,0,,False
61,"Document D is said to be a member of M  when s#Q»  s#D» , s#Q»",0,,False
62,"Given the signatures of the documents in the corpus, one can easily compute M  by identifying those documents whose signatures match the query's signature:",0,,False
63,"M  , {D  C | s#Q»  s#D» , s#Q»}",0,,False
64,Here's the pseudocode to search a corpus for documents matching,0,,False
65,a query:,0,,False
66,"M ,",0,,False
67,for,0,,False
68,all D if s#D»,0,,False
69,"s#CQ»d,os#Q»",0,,False
70,then,0,,False
71,"M  , M   {D}",0,,False
72,end if end for,0,,False
73,"Bit-string signatures are elegant, but their uniform encoding of terms, independent of frequency, leads to poor memory utilization. Section 4.2 explains how BitFunnel uses Frequency Conscious Signatures to improve memory efficiency in signatures.",1,ad,True
74,2.3 Bit-Sliced Signatures,0,,False
75,If all of the signatures have the same length and share a common,0,,False
76,"hashing scheme, H (n, t), one can achieve significant performance",0,,False
77,"gains by using a bit-sliced arrangement [9, 26, 27]. This approach",0,,False
78,transposes signature vectors from rows to columns in order to,0,,False
79,allow multiple documents to be searched simultaneously while,0,,False
80,eliminating the bit masks and shifting necessary to perform Boolean,0,,False
81,operations on individual bits.,0,,False
82,"Suppose we have a corpus C , {A..P } and a query Q. The matrix",0,,False
83,in Figure 1 shows these documents and the query encoded as bit-,0,,False
84,sliced signatures. Each document corresponds to a column which,0,,False
85,holds its 16-bit signature. Each row corresponds to a bit position in,0,,False
86,the document signature.,0,,False
87,"In this example the signature for document B has bit positions 2,",0,,False
88,"5, 9, and 13 set. The signature for the query Q has bit positions 2, 5,",0,,False
89,"and 9 set. Therefore, document B will match the query. It turns out",0,,False
90,that document F also matches the query.,0,,False
91,"With the bit-sliced layout, we need only inspect the rows corre-",0,,False
92,"sponding to bit positions in Q that are set. These rows, which we",0,,False
93,"call the query's rows, are shaded in Figure 1 and isolated in Figure",1,ad,True
94,2. Each bit position in the query's rows corresponds to a document.,0,,False
95,The document matches if its bit position is set in all of the query's,0,,False
96,rows. We determine which documents match by intersecting the,0,,False
97,"query's rows and looking for set bits. In Figure 2, columns B and F",0,,False
98,are the only columns without zeros. Therefore documents B and F,0,,False
99,are the only matches.,0,,False
100,Here's the bit-sliced algorithm:,0,,False
101,"#a» , 0",0,,False
102,for,0,,False
103,"all i #a» ,",0,,False
104,w#a»h&erre#osw#Q»»i[i],0,,False
105,",,",0,,False
106,1,0,,False
107,do,0,,False
108,"end for M  , {i | #a»[i] 0}",0,,False
109,606,0,,False
110,Session 5C: Efficiency and Scalability,1,Session,True
111,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
112,Q,0,,False
113,00 10 21 30 40 51 60 70 80 91 10 0 11 0 12 0 13 0 14 0 15 0,0,,False
114,0A B 0C D 0E F 0G H 0I J 0K L M0 N 0O P 0 0 0 01 0 0 01 0 01 0 0 0 0 01 01 0 01 1 01 0 0 0 01 0 0 0 0 01 0 0 0 0 0 01 2 0 01 0 0 0 01 0 0 01 0 0 0 01 0 0 0 3 0 0 0 01 0 0 01 0 0 0 01 0 0 0 01 0 4 0 0 0 0 01 0 0 01 0 01 0 0 0 01 0 0 5 01 01 0 0 0 01 0 01 0 0 01 0 0 0 0 01 6 0 0 01 0 0 0 0 0 0 0 0 0 0 01 0 0 7 01 0 0 01 0 0 01 0 01 0 0 01 0 0 01 0 8 0 0 0 0 0 0 0 01 0 01 0 01 0 0 0 0 9 0 01 0 01 0 01 0 0 0 0 0 0 0 01 0 01 10 0 0 01 0 01 0 0 0 01 0 0 0 01 0 0 0 11 01 0 01 0 0 0 01 0 0 0 0 01 0 0 0 0 12 0 0 0 01 0 0 0 01 01 0 0 0 0 0 01 0 13 0 01 0 0 0 01 0 0 0 0 01 0 0 0 0 0 14 0 0 01 0 0 0 01 0 0 0 0 0 01 01 0 01 15 01 0 0 0 0 0 0 0 01 0 0 01 0 0 0 0,0,,False
115,"Figure 1: Layout with bit-sliced signatures, in which each column is a document signature. Q is the signature of the query.",0,,False
116,0A B 0C D 0E F 0G H 0I J 0K L M0 N 0O P 2 0 01 0 0 0 01 0 0 01 0 0 0 01 0 0 0 5 01 01 0 0 0 01 0 01 0 0 01 0 0 0 0 01 9 0 01 0 01 0 01 0 0 0 0 0 0 0 01 0 01,0,,False
117,2  5  9 0 01 0 0 0 01 0 0 0 0 0 0 0 0 0 0 0A B 0C D 0E F 0G H 0I J 0K L M0 N 0O P,0,,False
118,"Figure 2: Bit-sliced signature layout. Rows 2, 5, and 9 yield documents B and F .",0,,False
119,2.4 Bit-Sliced Blocked Signatures,0,,False
120,"While bit-sliced signatures offer a significant performance advantage over bit-string signatures, they still suffer from poor performance when searching for rare terms. The problem is that every document's bit position must be scanned, even in the case where only a handful of documents actually match.",1,ad,True
121,"The idea behind blocked signatures [14] is to create shorter rows by assigning multiple documents to each column in the signature matrix. The number of documents that share a column is called the blocking factor. Shorter rows improve performance because they can be scanned more quickly, but they introduce noise which increases the false positive rate.",0,,False
122,"Prior to BitFunnel, bit-sliced block signatures were used primarily as a single-level index into a set of bit-string signature files on disk. At the time the main concern with this approach was reducing the probability of an unsuccessful block match which occurred when a column signature matched the query but none of the documents contained all the terms in the query. Suppose, for example, a column held two documents, one containing the word ""dog"" and the other containing the word ""cat"". This column would match the query {""do"", ""cat""} even though neither document contains both terms. At least one paper proposed a solution to the problem of unsuccessful block matches [14], however [28] argued that blocking increases",0,,False
123,"complexity while offering little benefit. In Section 4.1, we introduce Higher Rank Rows to address these problems.",1,ad,True
124,3 THE BITFUNNEL SYSTEM,0,,False
125,"For the past 4 years, BitFunnel has powered Bing's fresh index of recently crawled documents. During this time the system, which runs on thousands of machines, spread across several data centers, has processed the entire query load sent to Bing.",1,ad,True
126,3.1 Architectural Overview,0,,False
127,"Bing maintains multiple, georeplicated copies of the web index, each of which is sharded across a cluster of BitFunnel nodes. Figure 3 shows a single cluster. Queries are distributed, round robin, across the cluster. A node, upon receiving a query, parses it into an abstract syntax tree, rewrites the tree into an execution plan and then compiles the plan locally before broadcasting the compiled plan to the rest of the cluster. The nodes in the cluster run the compiled plan in parallel, returning results to the planning node for aggregation. These results are then passed on to other systems that score the matching documents and generate captions to display on the search results web page.",1,ad,True
128,Query,1,Query,True
129,Parse Plan Compile,0,,False
130,Execute Execute Execute,0,,False
131,Execute,0,,False
132,Aggregate,0,,False
133,Figure 3: BitFunnel cluster.,0,,False
134,Rank &,0,,False
135,Capon,0,,False
136,3.2 The Cost of False Positives,0,,False
137,"One criticism specific to the signature file approach is the introduction of false positives into the result set. For scenarios like database queries where the identifying exact match set is the goal, the cost of filtering out the false positives can be prohibitive. In the case of web search, the cost of filtering out false positives is negligible. To see why, it is important to understand that the goal of web search is not to find documents matching Boolean expressions of keywords ­ rather it is to find the documents that best match the user's intent when issuing a query. In Bing, we employ a ranking system that, given a document and a query, will generate a score predicting how well the document matches the user's intent for the query. This system relies on many signals beyond keywords and to some extent its inner workings are opaque to us because it is configured by machine learning.",0,,False
138,"If we had unlimited resources, we could process each query by submitting every single document in the corpus to our ranking oracle and then return the top-n ranked documents. Since we don't have unlimited resources, we insert inexpensive filters upstream of the oracle to discard documents that the oracle would score low. The filters are designed to reject, with high probability, those",1,ad,True
139,607,0,,False
140,Session 5C: Efficiency and Scalability,1,Session,True
141,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
142,documents that score low while never rejecting documents that score high. BitFunnel is such a filter.,0,,False
143,"In this context, the performance of BitFunnel is judged by its impact on the end-to-end system. BitFunnel wins when its time savings in the Boolean matching phase is greater than the time the oracle spends scoring false positives.",0,,False
144,We turn our attention now to a single BitFunnel node to describe the techniques that enable fast query processing.,0,,False
145,4 BITFUNNEL INNOVATIONS,0,,False
146,"In this section, we describe three innovations that address speed and space problems associated with bit-string and bit-sliced signatures.",1,ad,True
147,4.1 Higher Rank Rows,0,,False
148,BitFunnel generalizes the idea of blocking so that each term simultaneously hashes to multiple bit-sliced signatures with different blocking factors. The key to making this approach work is the ability to efficiently intersect rows with different blocking factors.,0,,False
149,"4.1.1 Mapping Columns Across Ranks. In BitFunnel, we restrict",0,,False
150,"blocking factors to be powers of 2. We define a concept of row rank, where a row of rank r  0 has a blocking factor of 2r .",0,,False
151,The BitFunnel blocking scheme is specific to the size of the,0,,False
152,"machine word used for the bit-slice operations. Let w be the log2 of the number of bits in a machine word, so for example, a 64-bit",0,,False
153,"processor would have w , 6. Then the document in column i0 at rank 0 will be associated with column ir at rank r as follows:",0,,False
154,ir,0,,False
155,",",0,,False
156,i0 2r +w,0,,False
157,+ (i0 mod 2r ),0,,False
158,(1),0,,False
159,"Figure 4 gives a small example for a 4-bit machine word (w , 2) and",0,,False
160,"ranks 0, 1, and 2. We can see that position 4 at rank 1 is associated with documents {4, 12} while position 0 at rank 2 is associated with documents {0, 4, 8, 12}.",0,,False
161,Rank 0 0 01 0 0 0 01 0 0 01 0 0 0 01 0 0 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
162,Rank 1 01 01 0 0 01 01 0 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
163,Rank 2 01 01 0 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
164,Figure 4: Forming higher rank equivalents of a single row.,0,,False
165,"Note that higher rank rows will, in general, magnify the bit density of their lower rank equivalents. This is because the value of each bit at a higher rank is the logical-or of multiple bits at a lower rank. In order to maintain a constant bit density of d across all signatures in BitFunnel, we must use longer signatures at higher ranks. Therefore, a single row at rank 0 will translate into multiple shorter rows at a higher rank. In most cases, a rank zero row and its higher rank equivalents will consume roughly the same amount of",0,,False
166,memory. We will derive an expression for the memory consumption in higher rank rows in Section 5.4.,0,,False
167,"Now suppose we have a query, Q, that maps to the three rows shown in Figure 5. To evaluate the query, we need some way of intersecting rows with different ranks. The mapping in Equation (1) is designed to make this operation easy and efficient.",0,,False
168,Rank 2 01 0 01 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
169,Rank 1 0 01 0 0 01 0 0 01 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
170,Rank 0 01 0 0 0 01 0 0 01 0 0 0 0 01 0 0 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
171,Figure 5: Intersecting different rows with different ranks.,0,,False
172,Logically we convert each row to its rank-0 equivalent by concatenating 2r copies of the row as shown in Figure 6. Then we are free to intersect the rank-0 equivalent rows to produce the result vector.,0,,False
173,0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15 Rank 2 01 0 01 0 01 0 01 0 01 0 01 0 01 0 01 0 Rank 1 0 01 0 0 01 0 0 01 0 1 0 0 1 0 0 1 Rank 0 01 0 0 0 01 0 0 01 0 0 0 0 01 0 0 0,0,,False
174,Matches 0 0 0 0 01 0 0 0 0 0 0 0 01 0 0 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
175,Figure 6: Rank-0 equivalent rows.,0,,False
176,"4.1.2 Optimizing Higher Rank Row Intersection. At a logical level, our approach is to intersect rank-0 equivalent rows. Were we to generate rank-0 equivalents for intersection, we would lose all of the performance gains that come from scanning shorter rows at higher ranks. Mapping (1) was structured specifically to provide opportunities to reuse intermediate results at every rank. As an example, in Figure 6, bits [0..3] of the rank 2 row need only be read once, even though they will be used for positions [4..7], [8..11], and [12..15]. Similarly, the intersection of the first two rows in positions [0..3] will be computed once and used again for positions [8..11]. We will leverage this insight in Section 5.3 where we derive an expression for the expected number of operations required to combine a set of rows with different ranks.",1,ad,True
177,"In BitFunnel, each term in a query maps to a set of rows that may include higher rank rows.",0,,False
178,4.2 Frequency Conscious Signatures,0,,False
179,We saw in Section 2.2 how Bloom filter signatures can be used to encode the set of terms in a document. One shortcoming with this,0,,False
180,608,0,,False
181,Session 5C: Efficiency and Scalability,1,Session,True
182,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
183,approach is inefficient memory usage when terms in the lexicon,0,,False
184,have widely varying frequencies in the corpus.,0,,False
185,"The problem stems from the fact that, in its classical formulation [1], the Bloom filter is configured with an integer constant, k, which represents the number of hashes for each term1. This value of k is the same for all terms in lexicon L. In other words",0,,False
186,"|H (n, t)| ,"" k, t L""",0,,False
187,"To get an intuition for the problem of the one-size-fits-all k, it",0,,False
188,"helps to think of the quantity of false positives in terms of signalto-noise ratio. Let's consider a single set membership test for t  D. In the context of the test, define the signal s to be the probability that term t is actually a member of document D. This is just the frequency of t in the corpus.",0,,False
189,Define noise  to be the probability that the Bloom filter will incorrectly report t as a member. Assume the Bloom filter has been configured to have an average bit density of d. Since d is the fraction,0,,False
190,"of the bits expected to be set, we can treat it as the probability that a random bit is set. A set membership test involves probing k bit positions. If all k probes find bits that are set to one, the algorithm",0,,False
191,will report a match. Therefore the noise is just the probability that k probes all hit ones when t D:,0,,False
192," , (1 - s)dk",0,,False
193,The signal-to-noise ratio  is then,0,,False
194,",",0,,False
195,(1,0,,False
196,s - s)dk,0,,False
197,"We can rearrange this and take the ceiling to get an expression for k as a function of d, s, and :",0,,False
198,"k,",0,,False
199,lod,0,,False
200,s (1 - s),0,,False
201,This is the minimum value of k that will ensure a signal-to-noise ratio of at least . The main take away is that k increases as s,0,,False
202,"decreases. In other words, rare terms require more hashes to ensure a given signal-to-noise level. The following table shows values of k without the ceiling, for select values of s when d , 0.1 and  , 10:",0,,False
203,signal (s) 0.1 0.01 0.001 0.0001 0.00001,0,,False
204,hashes (k) 1.954242509 2.995635195 3.999565488 4.999956568 5.999995657,0,,False
205,"Now consider a Bloom filter that stores a typical document from the Gov2 corpus2. If we were to configure the Bloom filter with k ,"" 2 we could just barely maintain a signal-to-noise ratio of 10 when testing for the term """"picture"""" which appears with frequency 0.1. To test for the term """"rotisserie"""", which appears with frequency 0.0001, we would need k "", 5 to drive the noise down to a tenth of the signal.",1,Gov,True
206,"With classical Bloom filters, one must configure for the rarest term in the lexicon, even though the vast majority of common terms could be stored more efficiently. Recent work in Weighted Bloom",0,,False
207,1In Bloom's original paper [1] this constant was the letter d ; more contemporary,0,,False
208,descriptions [3] use the letter k . 2Term frequencies are from Corpus D described in Section 6.,0,,False
209,Filters [3] shows that it is possible to adjust the number of hash functions on a term-by-term basis within the same Bloom filter.,1,ad,True
210,BitFunnel applies these ideas to reduce memory usage and determine the number of rows needed for each term.,0,,False
211,4.3 Sharding by Document Length,0,,False
212,"Bit-sliced signatures have another one-size-fits-all problem resulting from the requirement that all of the document signatures have the same configuration (i.e. their bit lengths, n, must all be the same, and they must all use the same hashing scheme H (n, t)).",0,,False
213,"The problem is that real world documents vary greatly in length. In Wikipedia, for example, the shortest documents have just a handful of unique terms while the longest ones may have many thousands of terms. The dynamic range of document lengths on the internet is even higher because of files containing DNA sequences, phone numbers, and GUIDs. To avoid overfilling our Bloom filters and generating excessive false positives, it is necessary to configure the Bloom filters for the longest document expected, even if such a document is very rare. Unfortunately, such a configuration would waste enough memory as to offset all of the other benefits of the bit-sliced arrangement.",1,Wiki,True
214,"A workaround [28] suggested in the late 90s was to shard the index into pieces containing documents with similar lengths. This approach was rejected at the time because, on a single machine, the introduction of length sharding would multiply the number of disk seeks by the number of shards.",0,,False
215,"This concern is not a factor when the index is many times larger than the capacity of a single machine. As soon as the index is sharded across a large cluster, one must pay for the overhead of sharding. At this point sharding by document length costs the same as sharding by any arbitrary factor.",1,ad,True
216,"Even on a single machine, the cost of length sharding is greatly reduced on modern hardware where the index can be stored in RAM or on SSD because the access cost is dominated by fixed-sized block transfers (512-bit cache line for RAM, 4096 byte block for SSD), rather than hard disk seeks.",0,,False
217,"In BitFunnel, we partition the corpus according to the number of unique terms in each document such that each instance of BitFunnel manages a shard in which documents have similar sizes.",0,,False
218,5 PERFORMANCE MODEL AND OPTIMIZATION,0,,False
219,"Signature-based approaches have historically been hard to configure because of a large number of design parameters that impact performance [10, 26, 28]. In this section we present an algorithm that optimizes the BitFunnel configuration, given a desired signalto-noise ratio. The algorithm performs a constrained optimization, over relevant configuration parameters, of a cost function that expresses the system efficiency as DQ, the product of the corpus size D and query processing rate Q. The configuration parameters include the mapping from terms with various frequencies to their corresponding number of rows at each rank. The constraint is a lower limit on the allowable signal-to-noise ratio, .",0,,False
220,"In order to develop the cost function and constraint, we derive expressions for the signal-to-noise ratio, query processing speed, and memory consumption in BitFunnel. We then combine these",0,,False
221,609,0,,False
222,Session 5C: Efficiency and Scalability,1,Session,True
223,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
224,"expressions into a cost function and constraint used by the algorithm that identifies an optimized set of blocking factors and hash functions for each equivalence class of terms, based on frequency in the lexicon.",0,,False
225,5.1 Prerequisites,0,,False
226,"Before deriving these fundamental equations, we discuss the impact of row rank on bit densities and noise. We then characterize two different components of noise in rank-0 equivalent rows. This will form the basis for the noise, speed, and storage equations in Sections 5.2, 5.3, and 5.4.",0,,False
227,5.1.1 Signal in a Higher Rank Row. Because each bit in a higher,0,,False
228,"rank row corresponds to multiple documents, the bit density con-",0,,False
229,tributed by a single term will nearly always be greater in higher,0,,False
230,rank rows. We can see this in Figure 4 where densities in the rank-0,0,,False
231,row,0,,False
232,and,0,,False
233,its,0,,False
234,rank,0,,False
235,1,0,,False
236,equivalent,0,,False
237,are,0,,False
238,4 16,0,,False
239,and,0,,False
240,8 16,0,,False
241,",",0,,False
242,respectively.,0,,False
243,Let s0 denote the signal in a rank-0 row and sr denote the signal,0,,False
244,at rank r . We can express sr as a function of s0 and r . The probability,0,,False
245,that a bit at rank r is set due to signal is the probability that at least,0,,False
246,one of the 2r corresponding rank-0 bits is signal. This is just one,0,,False
247,minus the probability that all of the 2r rank-0 bits are zero:,0,,False
248,"sr , 1 - (1 - s0)2r",0,,False
249,(2),0,,False
250,5.1.2 Noise in a Rank-0 Equivalent Row. Processing a query in,0,,False
251,BitFunnel is logically equivalent to intersecting the rank-0 equiva-,0,,False
252,lents of each row associated with the query. Converting a rank-r,0,,False
253,row to its rank-0 equivalent increases noise. The intuition behind,0,,False
254,this is simple -- each bit set in a rank-r row means that at least one of 2r documents is a match. It could be one document or all 2r --,0,,False
255,we can't tell and this is the source of higher noise.,0,,False
256,Let's look at a simple example. Suppose we have a corpus of,0,,False
257,16 documents and would like to search for a term that happens,0,,False
258,to appear in documents 4 and 8. We hash our term to find its,0,,False
259,"corresponding rows, and we get the set of rows R ,"" {R2, R1, R0} with ranks 2, 1, and 0, respectively. We define the signal, s0 as the""",0,,False
260,fraction of the bit positions at rank-0 corresponding to a match. In,0,,False
261,"the case of a term that appears in only 2 documents, s0",0,,False
262,",",0,,False
263,2 16,0,,False
264,.,0,,False
265,In,0,,False
266,"Figure 7, the green squares labeled 'S' correspond to the signal.",0,,False
267,R2 0S 0 0N 0 R1 0S 0N 0 0 0S 0 0 0N R0 0 0N 0N 0 0S 0 0N 0 0S 0N 0 0 0N 0 0N 0,0,,False
268,S0 0 0 0 0 0S 0 0 0 0S 0 0 0 0 0 0 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
269,"Figure 7: A term maps to three rows with different ranks. Since a row is shared with other terms, it contains signal and noise bits but has constant bit density.",0,,False
270,R2,0,,False
271,"has one signal bit, so its signal is",0,,False
272,1 4,0,,False
273,",",0,,False
274,4 16,0,,False
275,.,0,,False
276,We've,0,,False
277,arbitrarily,0,,False
278,"added one noise bit, marked with an 'N' and shaded black. This bit",1,ad,True
279,is contributed from another term that also maps to R2. The density,0,,False
280,of R2,0,,False
281,is,0,,False
282,2 4,0,,False
283,",",0,,False
284,8 16,0,,False
285,.,0,,False
286,Row R1 has two signal bits and two arbitrary noise bits so its,0,,False
287,signal is,0,,False
288,2 8,0,,False
289,",",0,,False
290,4 16,0,,False
291,and its density is,0,,False
292,4 8,0,,False
293,",",0,,False
294,8 16,0,,False
295,.,0,,False
296,"Finally, in row R0, the signal is equal to s0 because each signal",0,,False
297,"bit maps directly to a single document. As with the other rows, R0",0,,False
298,contains,0,,False
299,random,0,,False
300,noise,0,,False
301,bits,0,,False
302,from,0,,False
303,other,0,,False
304,"terms,",0,,False
305,yielding,0,,False
306,8 16,0,,False
307,density.,0,,False
308,"To process our query, we intersect the rank-0 equivalents of",0,,False
309,rows R2 and R1 with R0. Figure 8 shows how the process of creating,0,,False
310,rank-0 equivalents increases noise.,0,,False
311,0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15 R2 0C 0 0U 0 0S 0 0U 0 S0 0 0U 0 0C 0 0U 0 R1 0C 0U 0 0 0S 0 0 0U S0 U 0 0 C 0 0U R0 0 0U 0U 0 0S 0 0U 0 S0 0U 0 0 0U 0 0U 0,0,,False
312,Results 0 0 0 0 0S 0 0 0 0S 0 0 0 0U 0 0 0 0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15,0,,False
313,Figure 8: Noise in rank-0 equivalent rows.,0,,False
314,"Continuing with our example, the signal bit from position 0 in",0,,False
315,"R2 maps to bit positions 0, 4, 8, and 12 at rank 0. Of these four",0,,False
316,"positions, only positions 4 and 8 correspond to signal bits. The",0,,False
317,others are noise bits introduced by the construction of the rank-0,0,,False
318,"equivalent, and they are colored yellow and marked with the letter",0,,False
319,"'C'. In a similar manner, R2 bit position 2 introduces noise in rank-0",0,,False
320,"positions 2, 6, 10, and 14. These bits are colored black and marked",0,,False
321,"with the letter 'U'. In the case of R2, we went from a rank-2 row",0,,False
322,with,0,,False
323,1 4,0,,False
324,signal,0,,False
325,and,0,,False
326,1 4,0,,False
327,noise,0,,False
328,to,0,,False
329,a,0,,False
330,rank-0,0,,False
331,row,0,,False
332,with,0,,False
333,2 16,0,,False
334,signal,0,,False
335,and,0,,False
336,6 16,0,,False
337,noise. The noise increase is entirely due to the signal bits in R2. In,0,,False
338,"contrast, the noise bits in R2 contribute their same density without",0,,False
339,"amplification, and therefore do not increase noise in the rank-0",0,,False
340,equivalent row.,0,,False
341,Now let's look at the rank-0 equivalent of R1. We go from a rank-,0,,False
342,1 row,0,,False
343,with,0,,False
344,2 8,0,,False
345,signal,0,,False
346,and,0,,False
347,2 8,0,,False
348,noise,0,,False
349,to a rank-0,0,,False
350,row,0,,False
351,with,0,,False
352,2 16,0,,False
353,signal,0,,False
354,and,0,,False
355,6 16,0,,False
356,noise.,0,,False
357,As,0,,False
358,with,0,,False
359,"R2,",0,,False
360,the,0,,False
361,noise,0,,False
362,increase,0,,False
363,is,0,,False
364,due,0,,False
365,entirely,0,,False
366,to,0,,False
367,signal,0,,False
368,in,0,,False
369,rank-1 row.,0,,False
370,"5.1.3 Correlated and Uncorrelated Noise. We turn to computing the noise resulting from the intersection of a set of the rows. The noise in any rank-0 row is the difference between the row's density and the signal s0. If row R has density d, then its rank-0 equivalent has density d because it consists of the concatenation of 2r copies of the R. Therefore, the noise in R's rank-0 equivalent is d - s0.",0,,False
371,"Noise is made up of two components, one which is correlated and one which is not. In Figure 8, uncorrelated noise bits are shaded black while correlated noise bits are colored yellow. Row intersections are very effective at reducing uncorrelated noise, but they have less impact on correlated noise.",1,ad,True
372,"To better illustrate this, let's look at a simple, but extreme example. Suppose our query matches documents 2 and 13 and consists of the three rank-1 rows depicted in Figure 9. In the rank-0 equivalent",0,,False
373,Ra 0 0 0S 0 0 0S 0N 0 Rb 0 0N 0S 0 0 0S 0 0 Rc 0 0 0S 0N 0 0S 0 0,0,,False
374,Figure 9: Three rank-2 rows.,0,,False
375,"rows, shown in Figure 10, noise has two components: correlated and",0,,False
376,610,0,,False
377,Session 5C: Efficiency and Scalability,1,Session,True
378,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
379,0 1 02 3 04 5 06 7 08 9 100 11 102 13 104 15 R2 0 0 0S 0 0 0C 0U 0 0 0 0C 0 0 S0 0U 0 R1 0 0U 0S 0 0 0C 0 0 0 U 0C 0 0 S0 0 0 R0 0 0 0S 0U 0 0C 0 0 0 0 0C N0U 0 S0 0 0,0,,False
380,RaRbRc 0 0 0S 0 0 0C 0 0 0 0 0C 0 0 0S 0 0,0,,False
381,Figure 10: Correlated and uncorrelated noise in rank-0 equivalent rows.,0,,False
382,"uncorrelated. The uncorrelated noise, shown in black and marked",0,,False
383,"with the letter 'U', is completely eliminated in three row intersec-",0,,False
384,"tions, but the correlated noise, shown in yellow and marked with",0,,False
385,the letter 'C' remains at the same level despite the intersections.,0,,False
386,Effectively managing the impact of higher rank rows requires,0,,False
387,an understanding of the correlated noise in rank-0 equivalent rows.,0,,False
388,In the following we derive expressions for noise components. Let nr denote noise in a rank-r row R and n0 denote noise in,0,,False
389,"its rank-0 equivalent. We express n0 as a function of r , s0, and nr . Row R will contribute nr density due to noise already in R and sr in density due to signal in R. A portion of the density in sr corresponds to bonified signal. The remaining density is correlated",1,ad,True
390,noise introduced by the conversion to rank-0. Thus we compute noise at rank-0 by subtracting s0 from the density contributed by R:,0,,False
391,"n0 , nr + sr - s0",0,,False
392,"To compute the correlated noise, we subtract nr from n0 and substitute sr , 1 - (1 - s0)2r :",0,,False
393,"n0 - nr , sr - s0 , 1 - (1 - s0)2r - s0",0,,False
394,(3),0,,False
395,"Note that the number of correlated noise bits in a rank-0 equivalent is a function of the original rank. The higher the row rank, the greather the contribution in correlated noise to its rank-0 equivalent. Also, correlated noise remaining after intersecting a set of rank-0 equivalents is the correlated noise of the lowest rank row in the set. The other correlated noise is converted to uncorrelated noise.",0,,False
396,It is important to note that the correlated noise bits in a lower rank equivalent always form a subset of the correlated noise bits in a higher rank equivalent. Our equations for noise and speed in Sections 5.2 and 5.3 make use of this fact.,0,,False
397,5.2 Signal-to-Noise Ratio,0,,False
398,"We're now ready to write expressions for the noise components after a sequence of row intersections. For this derivation, we will perform the intersections in order from high rank to low rank. We will start with an accumulator, a, which has an initial bit density of 1.0 and then intersect in each row in turn.",1,ad,True
399,"Let ai denote the total noise in the accumulator at the end of iteration i. Let ci and ui denote the amount of correlated and uncorrelated noise, respectively, on iteration i and let ri denote the rank. The first iteration is effectively loading the first row into the accumulator so, u1 ,"" n1. The correlated noise in the accumulator is always equal to the correlated noise in the last row intersected, so""",1,ad,True
400,"ci , 1 - (1 - s0)2ri - s0",0,,False
401,"Since the rows are ordered by non-increasing rank, subsequent rows will never have more correlated noise. In the case where the rank decreases, the amount of correlated noise will decrease. When this happens, some of the correlated noise in the accumulator will become uncorrelated noise, moving forward. This new amount of uncorrelated noise in the accumulator will then be multiplied by the current row's total noise density ni+1:",0,,False
402,"ui+1 , (ui + ci - ci+1)ni+1",0,,False
403,"At any given point, the total accumulator noise ai is just the sum of the correlated and uncorrelated noise:",0,,False
404,"ai , ci + ui",0,,False
405,"The signal-to-noise ratio, , on iteration i is then",0,,False
406,i,0,,False
407,",",0,,False
408,s0 ai,0,,False
409,",",0,,False
410,s0 ci + ui,0,,False
411,(4),0,,False
412,5.3 Query Execution Time,1,Query,True
413,"When modelling running time, we use the number of machine word accesses of unique memory addresses as our proxy for time. On a real computer, row intersections are typically performed in chunks that match the machine register size. As an example, if the machine register size is 64 bits, and the rank-0 rows are 256 bits long, a pairwise row intersection would require 4 register-sized logical-and operations. When intersecting a set of rows, the outer loop is typically over the register-sized chunks in each row and the inner loop is over the set of rows.",1,ad,True
414,"This ordering of the loops is desirable because intermediate results of row intersections can reside in the accumulator instead of being written to memory. In many cases, the accumulator will become zero in the inner loop before all of the rows have been examined. Since additional intersections cannot change the result, it is possible to break out of the inner loop at this point.",1,ad,True
415,"In practice, breaking out of the inner loop offers a significant performance improvement. To quantify this impact, we'll focus on the innermost loop which intersects a set of n machine words that reside in memory. Our goal is to write an expression for the expected number of machine words loaded from memory.",1,ad,True
416,"If we know the probability that a bit remains set after intersecting the first n rows, we can derive a formula for the expected number of machine words accessed when intersecting a set of rows.",0,,False
417,Let N be a random variable denoting the machine words intersected and define PBZ (N > i) to be the probability that a random bit in the accumulator is zero after iteration i. PBZ (N > i) is the probability that the bit was not set by noise and not set by signal:,0,,False
418,"PBZ (N > i) , 1 - s0 - ai",0,,False
419,Define PA(N > i) to be the probability that at least one bit in the accumulator remains set after i intersections If b denotes the number of bits in a machine word then,0,,False
420,"PA(N > i) , 1 - (PBZ (N > i))b",0,,False
421,If we were to actually perform intersections on the rank-0 equiv-,0,,False
422,"alent rows, the expected number of machine words accessed during",0,,False
423,one iteration of the outer loop would be,0,,False
424,n,0,,False
425,n,0,,False
426,"E(N ) , PA(N > i) , 1 - (1 - s0 - ai )b",0,,False
427,"i ,1",0,,False
428,"i ,1",0,,False
429,611,0,,False
430,Session 5C: Efficiency and Scalability,1,Session,True
431,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
432,"As we saw in Section 4.1.2, the mapping of columns across ranks",0,,False
433,is structured in such a way that intermediate results from higher,0,,False
434,"rank intersections can be reused. Since each rank-0 equivalent is just the concatenation of 2r copies of a rank-r original, we need only load the accumulator once for each of the 2r machine word",1,ad,True
435,positions in the rank-0 equivalent. This reduces the number of machine words accessed in each row by a factor of 2ri :,0,,False
436,E(N ),0,,False
437,",",0,,False
438,"n i ,1",0,,False
439,1,0,,False
440,-,0,,False
441,(1,0,,False
442,- s0 2ri,0,,False
443,-,0,,False
444,ai )b,0,,False
445,(5),0,,False
446,"A similar approach can be used to model block devices like CPU cache and SSD block transfers, but it is somewhat more involved than substituting a different value for b.",0,,False
447,5.4 Space Consumption,0,,False
448,We express memory consumption as the number of bits per docu-,0,,False
449,"ment required to store a term. Suppose we have a corpus, C, with",0,,False
450,"target bit density, d, and we wish to store a term with signal, s0, in some row, q, that has rank r .",0,,False
451,"Since the corpus has |C| documents, row q must have |C|2-r bit",0,,False
452,"positions. Equation (2) shows that a term with frequency s0 will set sr of these bits. Therefore the term contributes b1 , sr |C|2-r set bits to row q. Let b0 denote the number of zero bits in row q. By",0,,False
453,"definition,",0,,False
454,d,0,,False
455,",",0,,False
456,b1 b1 + b0,0,,False
457,"Rearranging, we get",0,,False
458,b0,0,,False
459,",",0,,False
460,b1 d,0,,False
461,- b1,0,,False
462,"Therefore, the total number of bits required in row q to maintain density of d with a signal of s0 is",0,,False
463,b0,0,,False
464,+ b1,0,,False
465,",",0,,False
466,b1 d,0,,False
467,",",0,,False
468,sr |C| d 2r,0,,False
469,Dividing by the corpus size |C| gives the number of bits per docu-,0,,False
470,ment signature: sr d 2r,0,,False
471,"For a set of rows, Q, the total memory consumption per document",0,,False
472,is therefore,0,,False
473,sr (q) q Q d2r,0,,False
474,(6),0,,False
475,5.5 Choosing Term Configurations,0,,False
476,"Given expressions for signal-to-noise ratio, machine word reads, and storage consumed, we can now develop an approach for identifying the optimal row configuration for each term. The problem is a constrained optimization over a cost function parameterized by speed and space. Our constraint is that the signal-to-noise ratio, , must exceed some fixed threshold. The cost function is proportional to DQ, the product of the number of documents per unit storage and the number of queries processed per unit of compute.",1,ad,True
477,D is inversely proportional to the amount of storage required per document. Q is inversely proportional to the number of machine,0,,False
478,words accessed while processing a query. Therefore,0,,False
479,DQ ,0,,False
480,1,0,,False
481,(7),0,,False
482,n 1-(1-s0-ai )b,0,,False
483,"i ,1",0,,False
484,2ri,0,,False
485,sr (q) q Q d,0,,False
486,"Given the small number of possible row configurations, it is easy",0,,False
487,"to enumerate all configurations and choose the one with the highest DQ where  exceeds the signal-to-noise threshold. For example,",0,,False
488,"when considering configurations of 0 to 9 rows at each of seven ranks from 0 to 6, we need to examine 107 configurations for each s0 value. If we group s0 values into, say, 100 buckets correspondiong to IDF values from 0.1 to 10.0 in 0.1 increments, the entire optimization involves 109 evaluations of Equation 7. A modern multi-core",0,,False
489,processor can perform this optimization in a matter of seconds.,0,,False
490,6 EXPERIMENATAL EVALUATION,0,,False
491,"Our experiments are based on the TREC Gov2 corpus. Apache Tikka3 was used to extract terms, which were then converted to lower case, but not stemmed. Since BitFunnel shards its index by document term count, we selected five representative shards for our tests. Shard A has relatively short documents with term counts ranging from 64 to 127. Shards B, C, D and E have progressively larger documents.",1,TREC,True
492,Min terms Max terms Documents (M) Total terms (M) Postings (M) Matches/query Input text (GB),0,,False
493,Table 1: Corpora. ABC 64 128 256,0,,False
494,127 255 511 5.870 7.545 3.726 4.181 6.524 6.647,0,,False
495,"563 1,411 1,268 1,115 3,561 5,124 6.85 25.48 21.02",0,,False
496,"D 1,024 2,047 0.494 10.109",0,,False
497,"687 3,728 22.89",0,,False
498,"E 2,048 4,095 0.157 9.697",0,,False
499,"432 3,688 20.26",0,,False
500,Our query log is based the TREC 2006 Efficiency Topics. We removed punctuations from each query and then filtered out those queries that contained terms not in the corpus.4 The resulting query log contains about 98k queries.,1,TREC,True
501,"BitFunnel was implemented in C++14 and compiled with GCC 5.4.1 with the highest optimization level. Experiments were performed on a 4.0GHz 4-core i7-6700 with 32GB of 3.2GHz DDR4 RAM with Ubuntu 14.04 LTS on Windows Subsystem for Linux. BitFunnel was configured with lower bound signal-to-noise ratio  , 10.",0,,False
502,The source code to replicate our experiments is available at http://bitfunnel.org/sigir2017.,0,,False
503,6.1 Match Time vs. Quadwords,1,ad,True
504,"In Section 5.3 we developed a model for the number of machine words of row data accessed while processing a query. To verify that our model has predictive power, we examined the relationship between row intersection time and the number of quadwords accessed. Since BitFunnel has a significant per-match overhead that",1,ad,True
505,3 https://tika.apache.org/ 4This filtering was necessary because the Partitioned Elias-Fano index we used requires all query terms be in the index.,0,,False
506,612,0,,False
507,Session 5C: Efficiency and Scalability,1,Session,True
508,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
509,Median Intersection Time (µs),0,,False
510,200,0,,False
511,150,0,,False
512,IDF,0,,False
513,3,0,,False
514,100,0,,False
515,4,0,,False
516,5 50,0,,False
517,0,0,,False
518,0,0,,False
519,20000,0,,False
520,40000,0,,False
521,60000,0,,False
522,Quadwords Accessed,1,ad,True
523,Figure 11: Intersection time increases with quadwords.,1,ad,True
524,"is not part of the row intersection cost model, we modified the code to perform row intersections, but not report matches. A sample of 5000 queries with I DF > 3 were chosen, at random, from our TREC query log, and these queries were run, single-threaded, against corpus D. To control for system variances not in the model, we ran each query 10 times and recorded the median row intersection time. The scatterplot in Figure 11 shows that row intersection time tends to grow as the number of quadwords increases. The correlation is more pronounced at higher IDF values.",1,TREC,True
525,6.2 Impact of Frequency Conscious Signatures and Higher Rank Rows,0,,False
526,"This experiment compares the time and space characteristics of (a) bit-sliced signatures configured with classical Bloom filters (BSS); (b) the same, but with Frequency Conscious Signatures as described in Section 4.2 (BSS-FC); and (c) Higher Ranked Rows as described in Section 4.1 and optimized per Section 5.5 (BTFNL).5",0,,False
527,"Table 2 examines Corpus D, comparing the three configurations at each of 5 bit densities. The DQ values measure overall system efficiency, expressed as the ratio of QPS to Bits/Posting. We use DQ because it is inversely proportional to the number of servers required, given a particular corpus and a desired QPS",0,,False
528,Table 2: Impact of BitFunnel Innovations.,0,,False
529,Treatment Density Bits/Posting kQPS DQ,0,,False
530,BSS,0,,False
531,0.05,0,,False
532,80.0,0,,False
533,14.0 175,0,,False
534,BSS,0,,False
535,0.10,0,,False
536,50.0,0,,False
537,11.3 225,0,,False
538,BSS,0,,False
539,0.15,0,,False
540,46.7,0,,False
541,9.1 194,0,,False
542,BSS,0,,False
543,0.20,0,,False
544,40.0,0,,False
545,8.2 204,0,,False
546,BSS,0,,False
547,0.25,0,,False
548,36.0,0,,False
549,6.9 191,0,,False
550,BSS-FC 0.05,0,,False
551,23.4,0,,False
552,"29.5 1,263",0,,False
553,BSS-FC 0.10,0,,False
554,16.8,0,,False
555,"25.5 1,515",0,,False
556,BSS-FC 0.15,0,,False
557,14.7,0,,False
558,"24.0 1,632",0,,False
559,BSS-FC 0.20,0,,False
560,13.1,0,,False
561,"21.4 1,634",0,,False
562,BSS-FC 0.25,0,,False
563,12.6,0,,False
564,"19.4 1,547",0,,False
565,BTFNL 0.05,0,,False
566,22.1,0,,False
567,"65.2 2,954",0,,False
568,BTFNL 0.10,0,,False
569,16.0,0,,False
570,"57.7 3,595",0,,False
571,BTFNL 0.15,0,,False
572,13.7,0,,False
573,"57.0 4,163",0,,False
574,BTFNL 0.20,0,,False
575,12.5,0,,False
576,"46.7 3,746",0,,False
577,BTFNL 0.25,0,,False
578,11.9,0,,False
579,"41.6 3,510",0,,False
580,"5The BSS Bloom filter targeted  , 0.1 for terms with IDF 4. The BSS-FC and BTFNL configurations set  ,"" 0.1 for all terms, regardless of frequency.""",0,,False
581,Frequency consciousness reduces storage consumption while,0,,False
582,"increasing speed. For example, at d ,"" 0.15, the BSS configuration""",0,,False
583,uses 46.7 bits per posting while the BSS-FC configuration uses only,0,,False
584,14.7. This 3.2x reduction in storage is achieved while yielding a,0,,False
585,2.6x increase in speed. The intuition behind the improvement is,0,,False
586,that frequency consciousness allows each term to have the right,0,,False
587,"number of rows. With classical Bloom filters, every term has the",0,,False
588,"same number of rows, meaning that more common terms get excess",0,,False
589,rows as a side effect of providing sufficient rows to ensure the target,0,,False
590,signal-to-noise level for rare terms.,0,,False
591,"Higher Rank Rows mainly impact speed. For example, when",0,,False
592,"d ,"" 0.15, BSS-FC runs at 24K queries per second, while BTFNL""",0,,False
593,"runs at 57.0K, a 2.4x improvement. The intuition behind the speed",0,,False
594,up is that higher rank rows can be scanned more quickly than,0,,False
595,"rank-0 rows. Generally speaking, processing a rank-r row involves",0,,False
596,scanning,0,,False
597,1 2r,0,,False
598,of the quadwords necessary to process a rank-0 row.,1,ad,True
599,The DQ column captures the tradeoff between space and speed.,1,ad,True
600,"BSS-FC has a DQ of 1,632, while BTFNL has a DQ of 4,163, a 2.6x",0,,False
601,improvement. Combining frequency consciousness with higher,0,,False
602,rank rows yields a 21x improvement over that BSS DQ of 194.,0,,False
603,"We found that a density of 0.15 yielded the best DQ for Corpora B,",0,,False
604,"C, and D, while A and E performed best at 0.05 and 0.20, respectively.",0,,False
605,6.3 Comparison with Contemporary Indexes,0,,False
606,"The version of BitFunnel used by Bing includes a forward index with term frequencies used for BM25F ranking. Because this ranking code was not available to us at the time we designed our experiment, we limited our comparison to conjunctive boolean matching.",0,,False
607,"Our primary comparison system was Partitioned Elias-Fano or PEF[23]. This system is considered state-of-the-art, has excellent performance, and, like BitFunnel, is implemented in C++. We also compared with MG4J's Java implementation of PEF6. This implementation was the second fastest system in the SIGIR 2015 RIGOR workshop[18]. Our final comparison was with Lucene7, a popular Java-based search engine that outperformed MG4J at the RIGOR workshop, in an apples-to-apples comparison using BM25F.",0,,False
608,"Each of these systems was configured to use a memory-mapped index that was non-positional, with scoring disabled. In this configuration, PEF and MG4J pay no runtime penalty associated with term frequencies because the frequencies are stored in a separate data structure that is never consulted. It is unclear whether Lucene pays a cost associated with stepping past term frequency values.",0,,False
609,"For each system we used 8 threads to process the entire 98k query log twice, back-to-back, measuring performance on the second pass. This ensured that relevant portions of the index were paged in, as they would be under continuous production load.",1,ad,True
610,"We can see from Table 3 that BitFunnel is faster than PEF in all cases, but sometimes this comes at a significant cost, for example in Corpus A, BitFunnel uses 5x as many bits per posting while yielding a false positive rate of 1.62%. Across the 5 corpora, MG4J is slower than PEF, as expected since it implements the same algorithm, but in Java. MG4J is faster than Lucene in all but Corpus C.",1,corpora,True
611,"BitFunnel's overall performance relative to PEF improves as document lengths increase. It first surpasses PEF in Corpus C, where it",0,,False
612,6 http://mg4j.di.unimi.it/ 7 https://lucene.apache.org/,0,,False
613,613,0,,False
614,Session 5C: Efficiency and Scalability,1,Session,True
615,"SIGIR'17, August 7-11, 2017, Shinjuku, Tokyo, Japan",0,,False
616,"shows 3.2x the QPS of PEF while using only 2.6x the space. Examining DQ, the ratio of QPS to bits-per-posting, we see that BitFunnel outperforms PEF by factors of 1.3, 3.1, and 4.2 in Corpora C, D, and E, respectively, while PEF outperforms BitFunnel by factors of 3.4 and 1.6 in Corpora A and B.",0,,False
617,Table 3: Query Processing Performance.,1,Query,True
618,BitFunnel PEF MG4J Lucene,0,,False
619,QPS,0,,False
620,"21,427 14,675 6,866 6,310",0,,False
621,False positives (%),0,,False
622,1.62 0.00 0.00 0.00,0,,False
623,A Bits per posting,0,,False
624,38.43 7.64 7.85,0,,False
625,­,0,,False
626,DQ,0,,False
627,"558 1,921 875",0,,False
628,­,0,,False
629,QPS,0,,False
630,"8,674 5,049 3,636 3,011",0,,False
631,False positives (%),0,,False
632,4.32 0.00 0.00 0.00,0,,False
633,B Bits per posting,0,,False
634,20.72 7.33 7.59,0,,False
635,­,0,,False
636,DQ,0,,False
637,419 689 479,0,,False
638,­,0,,False
639,QPS,0,,False
640,"12,722 3,959 3,096 4,120",0,,False
641,False positives (%),0,,False
642,3.88 0.00 0.00 0.00,0,,False
643,C Bits per posting,0,,False
644,16.91 6.63 6.88,0,,False
645,­,0,,False
646,DQ,0,,False
647,752 598 450,0,,False
648,­,0,,False
649,QPS,0,,False
650,"57,014 8,268 5,900 3,632",0,,False
651,False positives (%),0,,False
652,2.43 0.00 0.00 0.00,0,,False
653,D Bits per posting,0,,False
654,13.69 6.25 6.28,0,,False
655,­,0,,False
656,DQ,0,,False
657,"4,163 1,322 939",0,,False
658,­,0,,False
659,QPS,0,,False
660,"105,782 13,151 7,349 4,991",0,,False
661,False positives (%),0,,False
662,2.64 0.00 0.00 0.00,0,,False
663,E Bits per posting,0,,False
664,11.69 6.15 6.15,0,,False
665,­,0,,False
666,DQ,0,,False
667,"9,047 2,139 1,195",0,,False
668,­,0,,False
669,"These results are consistent with the interpretation that the biggest factor in BitFunnel performance is row length, which is directly proportional to the number of documents in the corpus. As document lengths increase and the corpus size drops, BitFunnel performance improves relative to PEF.",0,,False
670,"It is unclear from these results, the extent to which BitFunnel's performance gains are the result of a careful implementation versus actual algorithmic gains. We can see from PEF vs MG4J that choice of implementation language can have a significant impact on performance. Since BitFunnel compiles each query into x64 machine code, it is likely that some of BitFunnel's gains come from highly optimized query code.",0,,False
671,7 CONCLUSION,0,,False
672,"This work revisits bit-sliced signatures and describes their use in a commercial search engine, which previously used inverted files. Signature-based approaches introduce several challenges and we develop a set of techniques to reduce the memory footprint and to process queries quickly. Furthermore, we derive a performance model that allows expressing the system configuration as an optimization problem. We evaluate the key techniques behind BitFunnel experimentally, and we provide the source code publicly to accelerate advances in this area.",1,ad,True
673,8 ACKNOWLEDGMENTS,0,,False
674,"We thank the following colleagues for their contributions to BitFunnel: Andrija Antonijevic, Tanj Bennett, Denis Deyneko, Utkarsh",0,,False
675,"Jain, and Fan Wang. We also thank the anonymous reviewers for",0,,False
676,their feedback which led to an improved experimental section.,0,,False
677,REFERENCES,0,,False
678,"[1] Burton H Bloom. 1970. Space/time trade-offs in hash coding with allowable errors. Commun. ACM 13, 7 (1970), 422­426.",1,ad,True
679,"[2] Sergey Brin and Lawrence Page. 1998. The Anatomy of a Large-Scale Hypertextual Web Search Engine. Computer Networks 30, 1-7 (1998), 107­117.",0,,False
680,"[3] Jehoshua Bruck, Jie Gao, and Anxiao Jiang. 2006. Weighted bloom filter. In 2006 IEEE International Symposium on Information Theory. IEEE.",0,,False
681,"[4] Stefan Büttcher, Charles LA Clarke, and Gordon V Cormack. 2016. Information retrieval: Implementing and evaluating search engines. Mit Press.",0,,False
682,[5] Berkant Barla Cambazoglu and Ricardo A. Baeza-Yates. 2015. Scalability Challenges in Web Search Engines. Morgan & Claypool Publishers.,0,,False
683,"[6] J Shane Culpepper and Alistair Moffat. 2010. Efficient set intersection for inverted indexing. ACM Transactions on Information Systems (TOIS) 29, 1 (2010), 1.",0,,False
684,"[7] Bolin Ding and Arnd Christian König. 2011. Fast set intersection in memory. Proceedings of the VLDB Endowment 4, 4 (2011), 255­266.",0,,False
685,"[8] Chris Faloutsos. 1985. Access methods for text. ACM Computing Surveys (CSUR) 17, 1 (1985), 49­74.",0,,False
686,"[9] Christos Faloutsos. 1992. Information retrieval: data structures and algorithms. Prentice Hall PTR, 44­65.",0,,False
687,[10] Christos Faloutsos and Stavros Christodoulakis. 1985. Design of a Signature File Method that Accounts for Non-Uniform Occurrence and Query Frequencies.. In VLDB. 165­170.,1,Query,True
688,"[11] Edward Fox, Donna Harman, w. Lee, and Ricardo Baeza-Yates. 1992. Information retrieval: data structures and algorithms. Prentice Hall PTR, 28­43.",0,,False
689,"[12] Shlomo Geva and Christopher M De Vries. 2011. Topsig: Topology preserving document signatures. In Proceedings of the 20th ACM international conference on Information and knowledge management. ACM, 333­338.",0,,False
690,"[13] Andrew Kane and Frank Wm Tompa. 2014. Skewed partial bitvectors for list intersection. In Proceedings of the 37th international ACM SIGIR conference on Research & development in information retrieval. ACM, 263­272.",0,,False
691,"[14] A Kent, Ron Sacks-Davis, and Kotagiri Ramamohanarao. 1990. A signature file scheme based on multiple organizations for indexing very large text databases. Journal of the American Society for Information Science 41, 7 (1990), 508.",0,,False
692,"[15] Donald E Knuth. 1998. The Art of Computer Programming, Vol. 3, Sorting and Searching (2nd ed.). Vol. 3. Addison-Wesley, 567­573.",0,,False
693,"[16] Roberto Konow, Gonzalo Navarro, Charles LA Clarke, and Alejandro López-Ortíz. 2013. Faster and smaller inverted indices with treaps. In Proceedings of the 36th international ACM SIGIR conference on Research and development in information retrieval. ACM, 193­202.",0,,False
694,"[17] Daniel Lemire and Leonid Boytsov. 2015. Decoding billions of integers per second through vectorization. Software: Practice and Experience 45, 1 (2015), 1­29.",0,,False
695,"[18] Jimmy Lin, Matt Crane, Andrew Trotman, Jamie Callan, Ishan Chattopadhyaya, John Foley, Grant Ingersoll, Craig Macdonald, and Sebastiano Vigna. 2016. Toward reproducible baselines: The open-source ir reproducibility challenge. In European Conference on Information Retrieval. Springer, 408­420.",1,ad,True
696,"[19] Sergey Melnik, Sriram Raghavan, Beverly Yang, and Hector Garcia-Molina. 2001. Building a distributed full-text index for the Web. In Proceedings of the Tenth International World Wide Web Conference, WWW 10, Hong Kong, China, May 1-5, 2001. 396­406.",0,,False
697,"[20] Alistair Moffat and Justin Zobel. 1996. Self-indexing inverted files for fast text retrieval. ACM Transactions on Information Systems (TOIS) 14, 4 (1996), 349­379.",0,,False
698,[21] Calvin N Mooers. 1948. Application of random codes to the gathering of statistical information. Ph.D. Dissertation. Massachusetts Institute of Technology.,0,,False
699,"[22] Calvin N Mooers. 1951. Zatocoding applied to mechanical organization of knowledge. American documentation 2, 1 (1951), 20­32.",0,,False
700,"[23] Giuseppe Ottaviano and Rossano Venturini. 2014. Partitioned elias-fano indexes. In Proceedings of the 37th international ACM SIGIR conference on Research & development in information retrieval. ACM, 273­282.",0,,False
701,"[24] Knut Magne Risvik, Trishul M. Chilimbi, Henry Tan, Karthik Kalyanaraman, and Chris Anderson. 2013. Maguro, a system for indexing and searching over very large text collections. In Sixth ACM International Conference on Web Search and Data Mining, WSDM 2013, Rome, Italy, February 4-8, 2013. 727­736.",0,,False
702,"[25] Charles S Roberts. 1979. Partial-match retrieval via the method of superimposed codes. Proc. IEEE 67, 12 (1979), 1624­1642.",0,,False
703,"[26] Ron Sacks-Davis, A Kent, and Kotagiri Ramamohanarao. 1987. Multikey access methods based on superimposed coding techniques. ACM Transactions on Database Systems (TODS) 12, 4 (1987), 655­696.",0,,False
704,"[27] Harry KT Wong, Hsiu-Fen Liu, Frank Olken, Doron Rotem, and Linda Wong. 1985. Bit Transposed Files.. In VLDB, Vol. 85. Citeseer, 448­457.",0,,False
705,"[28] Justin Zobel, Alistair Moffat, and Kotagiri Ramamohanarao. 1998. Inverted files versus signature files for text indexing. ACM Transactions on Database Systems (TODS) 23, 4 (1998), 453­490.",0,,False
706,614,0,,False
707,,0,,False
