Collaborative Filtering Bandits

Shuai Li
University of Insubria, Italy
shuaili.sli@gmail.com

Alexandros Karatzoglou

Claudio Gentile

Telefónica Research, Spain

University of Insubria, Italy

alexk@tid.es

claudio.gentile@uninsubria.it

ABSTRACT
Classical collaborative filtering, and content-based filtering methods try to learn a static recommendation model given training data. These approaches are far from ideal in highly dynamic recommendation domains such as news recommendation and computational advertisement, where the set of items and users is very fluid. In this work, we investigate an adaptive clustering technique for content recommendation based on exploration-exploitation strategies in contextual multi-armed bandit settings. Our algorithm takes into account the collaborative effects that arise due to the interaction of the users with the items, by dynamically grouping users based on the items under consideration and, at the same time, grouping items based on the similarity of the clusterings induced over the users. The resulting algorithm thus takes advantage of preference patterns in the data in a way akin to collaborative filtering methods. We provide an empirical analysis on medium-size real-world datasets, showing scalability and increased prediction performance (as measured by click-through rate) over state-of-the-art methods for clustering bandits. We also provide a regret analysis within a standard linear stochastic noise setting.
Keywords
Filtering and Recommending; Recommender Systems; Online Learning; Collaborative Filtering; Clustering; Bandits; Regret; Computational Advertising
1. INTRODUCTION
Recommender Systems are an essential part of many successful on-line businesses, from e-commerce to on-line streaming, and beyond. Moreover, Computational Advertising can be seen as a recommendation problem where the user preferences highly depend on the current context. In fact, many recommendation domains such as Youtube video recommendation or news recommendation do not fit the classical description of a recommendation scenario, whereby a set of users with essentially fixed preferences interact with a fixed
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. SIGIR '16, July 17-21, 2016, Pisa, Italy
c 2016 ACM. ISBN 978-1-4503-4069-4/16/07. . . $15.00 DOI: http://dx.doi.org/10.1145/2911451.2911548

set of items. In this classical setting, the well-known coldstart problem, namely, the lack of accumulated interactions by users on items, needs to be addressed, for instance, by turning to hybrid recommendation methods (e.g., [19]). In practice, many relevant recommendation domains are dynamic, in the sense that user preferences and the set of active users change with time. Recommendation domains can be distinguished by how much and how often user preferences and content universe change (e.g., [24]). In highly dynamic recommendation domains, such as news, ads and videos, active users and user preferences are fluid, hence classical collaborative filtering-type methods, such as Matrix or Tensor-Factorization break down. In these settings, it is essential for the recommendation method to adapt to the shifting preference patterns of the users.
Exploration-exploitation methods, a.k.a. multi-armed bandits, have been shown to be an excellent solution for these dynamic domains (see, e.g., the news recommendation evidence in [23]). While effective, standard contextual bandits do not take collaborative information into account, that is, users who have interacted with similar items in the past will not be deemed to have similar taste based on this fact alone, while items that have been chosen by the same group of users will also not be considered as similar. It is this significant limitation in the current bandit methodology that we try to address in this work. Past efforts on this problem were based on using online clustering-like algorithms on the graph or network structure of the data in conjunction with multi-armed bandit methods (see Section 3).
Commercial large scale search engines and information retrieval systems are examples of highly dynamic environments where users and items could be described in terms of their membership in some preference cluster. For instance, in a music recommendation scenario, we may have groups of listeners (the users) clustered around music genres, with the clustering changing across different genres. On the other hand, the individual songs (the items) could naturally be grouped by sub-genre or performer based on the fact that they tend to be preferred by the same group of users. Evidence has been collected which suggests that, at least in specific recommendation scenarios, like movie recommendation, data are well modeled by clustering at both user and item sides (e.g., [31]).
In this paper, we introduce a Collaborative Filtering based stochastic multi-armed bandit method that allows for a flexible and generic integration of information of users and items interaction data by alternatively clustering over both user and item sides. Specifically, we describe and analyze an

539

adaptive and efficient clustering of bandit algorithm that can perform collaborative filtering, named COFIBA (pronounced as "coffee bar"). Importantly enough, the clustering performed by our algorithm relies on sparse graph representations, avoiding expensive matrix factorization techniques. We adapt COFIBA to the standard setting of sequential content recommendation known as (contextual) multi-armed bandits (e.g., [5]) for solving the canonical exploration vs. exploitation dilemma.
Our algorithm works under the assumption that we have to serve content to users in such a way that each content item determines a clustering over users made up of relatively few groups (compared to the total number of users), within which users tend to react similarly when that item gets recommended. However, the clustering over users need not be the same across different items. Moreover, when the universe of items is large, we also assume that the items might be clustered as a function of the clustering they determine over users, in such a way that the number of distinct clusterings over users induced by the items is also relatively small compared to the total number of available items.
Our method aims to exploit collaborative effects in a bandit setting in a way akin to the way co-clustering techniques are used in batch collaborative filtering. Bandit methods also represent one of the most promising approaches to the research community of recommender systems, for instance in tackling the cold-start problem (e.g., [25]), whereby the lack of data on new users leads to suboptimal recommendations. An exploration approach in these cases seems very appropriate.
We demonstrate the efficacy of our dynamic clustering algorithm on three benchmark and real-world datasets. Our algorithm is scalable and exhibits significant increased prediction performance over the state-of-the-art of clustering bandits. We also provide a regret analysis of the T -style holding with high probability in a standard stochastically linear noise setting.
2. LEARNING MODEL
We assume that the user behavior similarity is encoded by a family of clusterings depending on the specific feature (or context, or item) vector x under consideration. Specifically, we let U = {1, . . . , n} represent the set of n users. Then, given x  Rd, set U can be partitioned into a small number m(x) of clusters U1(x), U2(x), . . . , Um(x)(x), where m(x) is upper bounded by a constant m, independent of x, with m being much smaller than n. (The assumption m << n is not strictly required but it makes our algorithms more effective, and this is actually what we expect our datasets to comply with.) The clusters are such that users belonging to the same cluster Uj(x) tend to have similar behavior w.r.t. feature vector x (for instance, they both like or both dislike the item represented by x), while users lying in different clusters have significantly different behavior. The mapping x  {U1(x), U2(x), . . . , Um(x)(x)} specifying the actual partitioning of the set of users U into the clusters determined by x (including the number of clusters m(x) and its upper bound m), as well as the common user behavior within each cluster are unknown to the learning system, and have to be inferred based on user feedback.
For the sake of simplicity, this paper takes the simple viewpoint that clustering over users is determined by linear functions x  ui x, each one parameterized by an un-

known vector ui  Rd hosted at user i  U , in such a way that if users i and i are in the same cluster w.r.t. x then ui x = ui x, while if i and i are in different clusters w.r.t. x then |ui x - ui x|  , for some (unknown) gap parameter  > 0, independent of x.1 As in the standard linear bandit setting (e.g., [5, 23, 12, 3, 13, 21, 30, 34, 16, 1], and references therein), the unknown vector ui determines the (average) behavior of user i. More concretely, upon receiving context vector x, user i "reacts" by delivering a payoff value
ai(x) = ui x + i(x) ,

where i(x) is a conditionally zero-mean and bounded vari-

ance noise term so that, conditioned on the past, the quan-

tity ui x is indeed the expected payoff observed at user i for context vector x. Notice that the unknown parameter

vector ui we associate with user i is supposed to be time invariant in this model.2

Since we are facing sequential decision settings where the

learning system needs to continuously adapt to the newly

received information provided by users, we assume that the

learning process is broken up into a discrete sequence of

rounds: In round t = 1, 2, . . . , the learner receives a user

index it  U to serve content to, hence the user to serve

may change at every round, though the same user can re-

cur many times. We assume the sequence of users i1, i2, . . .

is determined by an exogenous process that places nonzero

and independent probability to each user being the next one

to serve. Together with it, the system receives in round t a set of feature vectors Cit = {xt,1, xt,2, . . . , xt,ct }  Rd
encoding the content which is currently available for rec-

ommendation to user it. The learner is compelled to pick

some x¯t = xt,kt  Cit to recommend to it, and then observes it's feedback in the form of payoff at  R whose

(conditional) expectation is uit x¯t. The goal of the learn-

ing system is to maximize its total payoff

T t=1

at

over T

rounds. When the user feedback at our disposal is only the

click/no-click behavior, the payoff at is naturally interpreted

as a binary feedback, so that the quantity

T t=1

at

T

becomes a

clickthrough rate (CTR), where at = 1 if the recommended

item was clicked by user it, and at = 0, otherwise. CTR

is the measure of performance adopted by our comparative

experiments in Section 5.

From a theoretical standpoint (Section 6), we are instead

interested in bounding the cumulative regret achieved by our

algorithms. More precisely, let the regret rt of the learner at

time t be the extent to which the average payoff of the best

choice in hindsight at user it exceeds the average payoff of

the algorithm's choice, i.e.,

rt =

max
xCit

uit x

-uit x¯t .

We are aimed at bounding with high probability the cumu-

lative regret

T t=1

rt

,

the

probability

being

over

the

noise

variables it (x¯t), and any other possible source of random-

ness, including it ­ see Section 6.

1As usual, this assumption may be relaxed by assuming the existence of two thresholds, one for the within-cluster dis-
tance of ui x to ui x, the other for the between-cluster distance. 2It would in fact be possible to lift this whole machinery to time-drifting user preferences by combining with known techniques (e.g., [11, 28]).

540

The kind of regret bound we would like to contrast to is one where the latent clustering structure over U (w.r.t. the feature vectors x) is somehow known beforehand (see Section 6 for details). When the content universe is large but known a priori, as is frequent in many collaborative filtering applications, it is often desirable to also group the items into clusters based on similarity of user preferences, i.e., two items are similar if they are preferred by many of the same users. This notion of "two-sided" clustering is well known in the literature; when the clustering process is simultaneously grouping users based on similarity at the item side and items based on similarity at the user side, it goes under the name of "co-clustering" (see, e.g., [14, 15]). Here, we consider a computationally more affordable notion of collaborate filtering based on adaptive two-sided clustering.
Unlike previous existing clustering techniques on bandits (e.g., [1, 29]), our clustering setting only applies to the case when the content universe is large but known a priori (yet, see the end of Section 4). Specifically, let the content universe be I = {x1, x2, . . . , x|I|}, and P (xh) = {U1(xh), U2(xh), . . . , Um(xh)(xh)} be the partition into clusters over the set of users U induced by item xh. Then items xh, xh  I belong to the same cluster (over the set of items I) if and only if they induce the same partition of the users, i.e., if P (xh) = P (xh ). We denote by g the number of distinct partitions so induced over U by the items in I, and work under the assumption that g is unknown but significantly smaller than |I|. (Again, the assumption g << |I| is not strictly needed, but it both makes our algorithms effective and is expected to be satisfied in relevant practical scenarios.)
Finally, in all of the above, an important special case is when the items to be recommended do not possess specific features (or do not possess features having significant predictive power). In this case, it is common to resort to the more classical non-contextual stochastic multiarmed bandit setting (e.g., [6, 4]), which is recovered from the contextual framework by setting d = |I|, and assuming the content universe I is made up of the d-dimensional vectors eh, h = 1, . . . , d, of the canonical basis of Rd, As a consequence, the expected payoff of user i on item h is simply the h-th component of vector ui, and two users i and i belong to the same cluster w.r.t. to h if the h-th component of ui equals the h-th component of ui . Because the lack of useful annotation on data was an issue with all datasets at our disposal, it is this latter modeling assumption that motivates the algorithm we actually implemented for the experiments reported in Section 5.
3. RELATED WORK
Batch collaborative filtering neighborhood methods rely on finding similar groups of users and items to the target user-item pair, e.g., [33], and thus in effect rely on a dynamic form of grouping users and items. Collaborative Filteringbased methods have also been integrated with co-clustering techniques, whereby preferences in each co-cluster are modeled with simple statistics of the preference relations in the co-cluster, e.g., rating averages [18].
Beyond the general connection to co-clustering (e.g., [14, 15]), our paper is related to the research on multi-armed bandit algorithms for trading off exploration and exploitation through dynamic clustering. We are not aware of any specific piece of work that combines bandits with co-clustering

based on the scheme of collaborative filtering; the papers which are most closely related to ours are [16, 27, 29, 8, 22, 1, 2]. In [16], the authors work under the assumption that users are defined using a feature vector, and try to learn a low-rank hidden subspace assuming that variation across users is low-rank. The paper combines low-rank matrix recovery with high-dimensional Gaussian Process Bandits, but it gives rise to algorithms which do not seem practical for sizeable problems. In [27], the authors analyze a non-contextual stochastic bandit problem where model parameters are assumed to be clustered in a few (unknown) types. Yet, the provided solutions are completely different from ours. The work [29] combines (k-means-like) online clustering with a contextual bandit setting, but clustering is only made at the user side. The paper [8] also relies on bandit clustering at the user side (as in [27, 29]), with an emphasis on diversifying recommendations to the same user over time. In [22], the authors propose cascading bandits of user behavior to identify the k most attractive items, and formulate it as a stochastic combinatorial partial monitoring problem. Finally, the algorithms in [1, 2, 26] can be seen as a special case of COFIBA when clustering is done only at the user side, under centralized [1, 26] or decentralized [2] environments.
Similar in spirit are also [7, 9, 10, 20]: In [7], the authors define a transfer learning problem within a stochastic multiarmed bandit setting, where a prior distribution is defined over the set of possible models over the tasks; in [9], the authors rely on clustering Markov Decision Processes based on their model parameter similarity. In [10], the authors discuss how to choose from n unknown distributions the k ones whose means are largest by a certain metric; in [20] the authors study particle Thompson sampling with RaoBlackwellization for online matrix factorization, exhibiting a regret bound in a very specific case of n×m rank-1 matrices. Yet, in none of above cases did the authors make a specific effort towards item-dependent clustering models applied to stochastic multi-armed bandits.
Further work includes [25, 32]. In [25], an ensemble of contextual bandits is used to address the cold-start problem in recommender systems. A similar approach is used in [32] to deal with cold-start in recommender systems but based on the probability matching paradigm in a parameter-free bandit strategy, which employs online bootstrap to derive the distribution of the estimated models. In contrast to our work, in neither [25] nor [32] are collaborative effects explicitly taken into account.
4. THE ALGORITHM
COFIBA, relies on upper-confidence-based tradeoffs between exploration and exploitation, combined with adaptive clustering procedures at both the user and the item sides. COFIBA stores in round t an estimate wi,t of vector ui associated with user i  U . Vectors wi,t are updated based on the payoff feedback, as in a standard linear least-squares approximation to the corresponding ui. Every user i  U hosts such an algorithm which operates as a linear bandit algorithm (e.g., [12, 3, 1]) on the available content Cit . More specifically, wi,t-1 is determined by an inverse correlation matrix Mi-,t1-1 subject to rank-one adjustments, and a vector bi,t-1 subject to additive updates. Matrices Mi,t are initialized to the d × d identity matrix, and vectors bi,t are initialized to the d-dimensional zero vector. Matrix Mi-,t1-1 is also

541

used to define an upper confidence bound cbi,t-1(x) in the approximation of wi,t-1 to ui along direction x. Based on the local information encoded in the weight vectors wi,t-1 and the confidence bounds cbi,t-1(x), the algorithm also maintains and updates a family of clusterings of the set of
users U, and a single clustering over the set of items I. On
both sides, such clusterings are represented through con-
nected components of undirected graphs (this is in the same
vein as in [1]), where nodes are either users or items. A
pseudocode description of our algorithm is contained in Fig-
ures 1, 2, and 3, while Figure 4 illustrates the algorithm's
behavior through a pictorial example.
At time t, COFIBA receives the index it of the current user to serve, along with the available item vectors
xt,1, . . . , xt,ct , and must select one among them. In order to do so, the algorithm computes the ct neighborhood sets Nk, one per item xt,k  Cit based on the current aggregation of users (clusters "at the user side") w.r.t. item xt,k. Set Nk should be regarded as the current approximation to the cluster (over the users) it belongs to when the clustering criterion is defined by item xt,k. Each neighborhood set then defines a compound weight vector w¯ Nk,t-1 (through the aggregation of the corresponding matrices Mi,t-1 and vectors bi,t-1) which, in turn, determines a compound confidence bound3 cbNk,t-1(xt,k). Vector w¯ Nk,t-1 and confidence bound cbNk,t-1(xt,k) are combined through an upperconfidence exploration-exploitation scheme so as to commit to the specific item x¯t  Cit for user it. Then, the payoff at is received, and the algorithm uses x¯t to update Mit,t-1 to Mit,t and bit,t-1 to bit,t. Notice that the update is only performed at user it, though this will affect the calculation of neighborhood sets and compound vectors for other users
in later rounds.
After receiving payoff at and computing Mit,t and bit,t, COFIBA updates the clusterings at the user side and the (unique) clustering at the item side. In round t, there are multiple graphs GUt,h = (U , EtU,h) at the user side (hence many clusterings over U, indexed by h), and a single graph GIt = (I, EtI ) at the item side (hence a single clustering over I). Each clustering at the user side corresponds to a
single cluster at the item side, so that we have gt clusters I^1,t, . . . , I^gt,t over items and gt clusterings over users ­ see Figure 4 for an example. On both user and item sides, up-
dates take the form of edge deletions. Updates at the user side are only performed on the graph GU pointed to by
t,ht
the selected item x¯t = xt,kt . Updates at the item side are only made if it is likely that the neighborhoods of user it has significantly changed when considered w.r.t. two previously
deemed similar items. Specifically, if item xh was directly connected to item x¯t at the beginning of round t and, as a consequence of edge deletion at the user side, the set of users
that are now likely to be close to it w.r.t. xh is no longer the same as the set of users that are likely to be close to it w.r.t. x¯t, then this is taken as a good indication that item xh is not inducing the same partition over users as x¯t does, hence edge (x¯t, xh) gets deleted. Notice that this need not imply that, as a result of this deletion, the two items are
now belonging to different clusters over I, since these two
items may still be indirectly connected.
3The one given in Figure 1 is the confidence bound we use in our experiments. In fact, the theoretical counterpart to cb is significantly more involved, same efforts can also be found in order to close the gap, e.g., in [4, 1].

Input:
· Set of users U = {1, . . . , n}; · set of items I = {x1, . . . , x|I|}  Rd; · exploration parameter  > 0, and edge deletion param-
eter 2 > 0.

Init: · bi,0 = 0  Rd and Mi,0 = I  Rd×d, i = 1, . . . n; · User graph GU1,1 = (U , E1U,1), GU1,1 is connected over U ; · Number of user graphs g1 = 1; · No. of user clusters mU1,1 = 1; · Item clusters I^1,1 = I, no. of item clusters g1 = 1; · Item graph GI1 = (I, E1I ), GI1 is connected over I.

for t = 1, 2, . . . , T do Set wi,t-1 = Mi-,t1-1bi,t-1,

i = 1, . . . , n ;

Receive it  U , and get items Cit = {xt,1, . . . , xt,ct }  I; For each k = 1, . . . , ct, determine which cluster (within the
current user clustering w.r.t. xt,k) user it belongs to, and denote this cluster by Nk; Compute, for k = 1, . . . , ct, aggregate quantities

M¯ Nk,t-1 = I +

(Mi,t-1 - I),

iNk

b¯Nk,t-1 =

bi,t-1 ,

iNk

w¯ Nk,t-1 = M¯ N-k1,t-1b¯Nk,t-1 ;

Set

kt = argmax
k=1,...,ct

w¯ Nk,t-1xt,k + cbNk,t-1(xt,k)

,

where cbNk,t-1(x) =  x M¯ N-k1,t-1x log(t + 1) ; Set for brevity x¯t = xt,kt ; Observe payoff at  R, and update weights Mi,t and bi,t as follows:
· Mit,t = Mit,t-1 + x¯tx¯t ,
· bit,t = bit,t-1 + atx¯t,
· Set Mi,t = Mi,t-1, bi,t = bi,t-1 for all i = it ,

Determine ht  {1, . . . , gt} such that kt  I^ht,t;

Update user clusters at graph GU = (U , EU ) by per-

t,ht

t,ht

forming the steps in Figure 2;

For all h = ht, set GUt+1,h = GUt,h;

Update item clusters at graph GIt = (I, EtI ) by performing the steps in Figure 3 .

end for

Figure 1: The COFIBA algorithm.

Update user clusters at graph GU as follows:

t,ht

·

Delete from EU
t,ht

all (it, j) such that

|wit,tx¯t - wj,tx¯t| > cbit,t(x¯t) + cbj,t(x¯t) ,

where cbi,t(x) = 2 x Mi-,t1x log(t + 1) ;

· Let EU

be the resulting set of edges, set

t+1,ht

GU

= (U , EU ), and compute associated clus-

t+1,ht

t+1,ht

ters

U^1,t+1,ht

,

U^2,t+1,ht

,

.

.

.

,

U^mU t+1,ht

,t+1,ht

as

the

con-

nected components of GU .

t+1,ht

Figure 2: User cluster update in the COFIBA

542

Update item clusters at graph GIt as follows:

· For all such that (x¯t, x )  EtI build neighborhood

N

U ,t+1

(it

)

as:

N

U ,t+1

(it

)

=

j : j = it , |wit,tx - wj,tx |

 cbit,t(x ) + cbj,t(x ) ;

· Delete from EtI all (x¯t, x ) such that N U,t+1(it) =

NkUt,t+1(it), where NkUt,t+1(it) is the neighborhood of

node

it

w.r.t.

graph

GU

;

t+1,ht

· Let EtI+1 be the resulting set of edges, set

GIt+1 = (I, EtI+1), compute associated item clus-

ters I^1,t+1, I^2,t+1, . . . , I^gt+1,t+1 through the connected

components of GIt+1;

· For each new item cluster created, allocate a new con-

nected graph over users representing a single (degener-

ate) cluster U .

Figure 3: Item cluster update in the COFIBA

It is worth stressing that a naive implementation of COFIBA would require memory allocation for maintaining |I|-many n-node graphs, i.e., O(n2 |I|). Because this would be prohibitive even for moderately large sets of users, we make full usage of the approach of [1], where instead of starting off with complete graphs over users each time a new cluster over items is created, we randomly sparsify the complete graph by drawing an Erdos-Renyi initial graph, still retaining with high probability the underlying clusterings {U1(xh), . . . , Um(xh)(xh)}, h = 1, . . . , |I|, over users. This works under the assumption that the latent clusters Ui(xh) are not too small ­ see the argument in [1], where it is shown that in practice the initial graphs can have O(n log n) edges instead of O(n2). Moreover, because we modify the item graph by edge deletions only, one can show that with high probability (under the modeling assumptions of Section 2) the number gt of clusters over items remains upper bounded by g throughout the run of COFIBA, so that the actual storage required by the algorithm is indeed O(ng log n). This also brings a substantial saving in running time, since updating connected components scales with the number of edges of the involved graphs. It is this graph sparsification techniques that we used and tested along the way in our experimentation parts.
Finally, despite we have described in Section 2 a setting where I and U are known a priori (the analysis in Section 6 currently holds only in this scenario), nothing prevents in practice to adapt COFIBA to the case when new content or new users show up. This essentially amounts to adding new nodes to the graphs at either the item or the user side, by maintaining data-structures via dynamic memory allocation. In fact, this is precisely how we implemented our algorithm in the case of very big item or user sets (e.g., the Telefonica and the Avazu dataset in the next section).

5. EXPERIMENTS
We compared our algorithm to standard bandit baselines on three real-world datasets: one canonical benchmark dataset on news recommendations, one advertising dataset from a living production system, and one publicly available advertising dataset. In all cases, no features on the items have been used. We closely followed the same experimen-

Figure 4: In this example, U = {1, . . . 6} and I =

{x1, . . . , x8} (the items are depicted here as 1, 2, . . . , 8).

(a) At the beginning we have g1 = 1, with a single item cluster I^1,1 = I and, correspondingly, a

single (degenerate) clustering over U, made up of

the unique cluster U. (b) In round t we have the

gt = 3 item clusters I^1,t = {x1, x2}, I^2,t = {x3, x4, x5}, I^3,t = {x6, x7, x8}. Corresponding to each one of them

are the three clusterings over U depicted on the left, so that mUt,1 = 3, mUt,2 = 2, and mUt,3 = 4. In this

example, it = 4, and x¯t = x5, hence ht = 2, and we focus on graph GUt,2, corresponding to user clustering {{1, 2, 3}, {4, 5, 6}}. Suppose in GUt,2 the only neighbors
of user 4 are 5 and 6. When updating such user clus-

tering, the algorithm considers therein edges (4, 5)

and (4, 6) to be candidates for elimination. Suppose

edge (4, 6) is eliminated, so that the new clustering over U induced by the updated graph GUt+1,2 becomes
{{1, 2, 3}, {4, 5}, {6}}. After user graph update, the al-

gorithm considers the item graph update. Suppose x5 is only connected to x4 and x3 in GIt , and that
x4 is not connected to x3, as depicted. Both edge

(x5, x4) and edge (x5, x3) are candidates for elimi-

nation. The algorithm computes the neighborhood

N of it = 4 according to GUt+1,2, and compares it to

the

the

neighborhoods

N

U ,t+1

(it

),

for

= 3, 4. As-

sume N = N3U,t+1(it), because the two neighborhoods

of user 4 are now different, the algorithm deletes

edge (x5, x3) from the item graph, splitting the item

cluster {x3, x4, x5} into the two clusters {x3} and

{x4, x5}, hence allocating a new cluster at the item

side corresponding to a new degenerate clustering

{{1, 2, 3, 4, 5, 6}} at the user side. (c) The resulting

clusterings at the beginning of round t + 1. (In

this picture it is assumed that edge (x5, x4) was not

deleted from the item graph at time t.)

tal setting as in previous work [12, 1], thereby evaluating prediction performance by click-through rate.

5.1 Datasets
Yahoo!. The first dataset we use for the evaluation is the

543

freely available benchmark dataset which was released in the "ICML 2012 Exploration & Exploitation Challenge"4. The aim of the challenge was to build state-of-the-art news article recommendation algorithms on Yahoo! data, by building an algorithm that learns efficiently a policy to serve news articles on a web site. The dataset is made up of random traffic records of user visits on the "Today Module" of Yahoo!, implying that both the visitors and the recommended news article are selected randomly. The available options (the items) correspond to a set of news articles available for recommendation, one being displayed in a small box on the visited web page. The aim is to recommend an interesting article to the user, whose interest in a given piece of news is asserted by a click on it. The data has 30 million visits over a two-week time stretch. Out of the logged information contained in each record, we used the user ID in the form of a 136-dimensional boolean vector containing his/her features (index it), the set of relevant news articles that the system can recommend from (set Cit ); a randomly recommended article during the visit; a boolean value indicating whether the recommended article was clicked by the visiting user or not (payoff at). Because the displayed article is chosen uniformly at random from the candidate article pool, one can use an unbiased off-line evaluation method to compare bandit algorithms in a reliable way. We refer the reader to [1] for a more detailed description of how this dataset was collected and extracted. We picked the larger of the two datasets considered in [1], resulting in n  18K users, and d = 323 distinct items. The number of records ended up being 2.8M , out of which we took the first 300K for parameter tuning, and the rest for testing.
Telefonica. This dataset was obtained from Telefonica S.A., which is the number one Spanish broadband and telecommunications provider, with business units in Europe and South America. This data contains clicks on ads displayed to user on one of the websites that Telefonica operates on. The data were collected from the back-end server logs, and consist of two files: the first file contains the ads interactions (each record containing an impression timestamp, a user-ID, an action, the ad type, the order item ID, and the click timestamp); the second file contains the ads metadata as item-ID, type-ID, type, order-ID, creative type, mask, cost, creator-ID, transaction key, cap type. Overall, the number n of users was in the scale of millions, while the number d of items was approximately 300. The data contains 15M records, out of which we took the first 1, 5M for parameter tuning, and the rest for testing. Again, the only available payoffs are those associated with the items served by the system. Hence, in order to make the procedure be an effective estimator in a sequential decision process (e.g., [13, 17, 1, 23]), we simulated random choices by the system by generating the available item sets Cit as follows: At each round t, we stored the ad served to the current user it and the associated payoff value at (1 ="clicked", 0 ="not clicked"). Then we created Cit by including the served ad along with 9 extra items (hence ct = 10 t) which were drawn uniformly at random in such a way that, for any item eh  I, if eh occurs in some set Cit , this item will be the one served by the system 1/10 of the times. The random selection was done independent of the available payoff val-
4https://explochallenge.inria.fr/category/challenge

ues at. All our experiments on this dataset were run on a machine with 64GB RAM and 32 Intel Xeon cores.
Avazu. This dataset was prepared by Avazu Inc,5 which is a leading multinational corporation in the digital advertising business. The data was provided for the challenge to predict the click-through rate of impressions on mobile devices, i.e., whether a mobile ad will be clicked or not. The number of samples was around 40M , out of which we took the first 4M for parameter tuning, and the remaining for testing. Each line in the data file represents the event of an ad impression on the site or in a mobile application (app), along with additional context information. Again, payoff at is binary. The variables contained in the dataset for each sample are the following: ad-ID; timestamp (date and hour); click (boolean variable); device-ID; device IP; connection type; device type; ID of visited App/Website; category of visited App/Website; connection domain of visited App/Website; banner position; anonymized categorical fields (C1, C14-C21). We pre-processed the dataset as follows: we cleaned up the data by filtering out the records having missing feature values, and removed outliers. We identified the user with device-ID, if it is not null. The number of users on this dataset is in the scale of millions. Similar to the Telefonica dataset, we generated recommendation lists of length ct = 20 for each distinct timestamp. We used the first 4M records for tuning parameters, and the remaining 36M for testing. All data were transferred to Amazon S3, and all jobs were run through the Amazon EC2 Web Service.
5.2 Algorithms
We compared COFIBA to a number of state-of-the-art bandit algorithms:
· LINUCB-ONE is a single instance of the ucb1 [6] algorithm, which is a very popular and established algorithm that has received a lot of attention in the research community over the past years;
· DYNUCB is the dynamic ucb algorithm of [29]. This algorithm adopts a "K-means"-like clustering technique so as to dynamically re-assign the clusters on the fly based on the changing contexts and user preferences over time;
· LINUCB-IND [1] is a set of independent ucb1 instances, one per user, which provides a fully personalized recommendation for each user;
· CLUB [1] is the state-of-the-art online clustering of bandits algorithm that dynamically cluster users based on the confidence ellipsoids of their models;
· LINUCB-V [4] is also a single instance of ucb1, but with a more sophisticated confidence bound; this algorithm turned out to be the winner of the "ICML 2012 Challenge" where the Yahoo! dataset originates from.
We tuned the optimal parameters in the training set with a standard grid search as indicated in [13, 1], and used the test set to evaluate the predictive performance of the algorithms. Since the system's recommendation need not coincide with the recommendation issued by the algorithms we tested, we only retained the records on which the two recommendations were indeed the same. Because records are discarded on
5https://www.kaggle.com/c/avazu-ctr-prediction

544

CTR

0.08 0.07 0.06 0.05 0.04 0.03 0.02 0.01
0 1

Yahoo Dataset

LINUCB-ONE DYNUCB LINUCB-IND CLUB LINUCB-V COFIBA

2

3

4

5

6

7

Rounds

x 104

Figure 5: Results on the Yahoo dataset.

the fly, the actual number T of retained records ("Rounds" in the plots of the next subsection) changes slightly across algorithms; T was around 70K for the Yahoo! data, 350K for the Telefonica data, and 900K for the Avazu data. All experimental results we report were averaged over 3 runs (but in fact the variance we observed across these runs was fairly small).
5.3 Results
Our results are summarized in Figures 5, 6, and 7. Further evidence is contained in Figure 8. In Figures 5­7, we plotted click-through rate ("CTR") vs. retained records so far ("Rounds"). All these experiments are aimed at testing the performance of the various bandit algorithms in terms of prediction performance, also in cold-start regimes (i.e., the first relatively small fraction of the time horizon in the xaxis). Our experimental setting is in line with previous ones (e.g., [12, 1]) and, by the way the data have been prepared, gives rise to a reliable estimation of actual CTR behavior under the same experimental conditions as in [12, 1]. Figure 8 is aimed at supporting the theoretical model of Section 2, by providing some evidence on the kind of clustering statistics produced by COFIBA at the end of its run.
Whereas the three datasets we took into consideration are all generated by real online web applications, it is worth pointing out that these datasets are indeed different in the way customers consume the associated content. Generally speaking, the longer the lifecycle of one item the fewer the items, the higher the chance that users with similar preferences will consume it, and hence the bigger the collaborative effects contained in the data. It is therefore reasonable to expect that our algorithm will be more effective in datasets where the collaborative effects are indeed strong.
The users in the Yahoo! data (Figure 5), are likely to span a wide range of demographic characteristics; on top of this, this dataset is derived from the consumption of news that are often interesting for large portions of these users and, as such, do not create strong polarization into subcommunities. This implies that more often than not, there are quite a few specific hot news that all users might express interest in, and it is natural to expect that these pieces of news are intended to reach a wide audience of consumers. Given this state of affairs, it is not surprising that on the Yahoo! dataset both LINUCB-ONE and LINUCB-V (serving the same news to all users) are already performing quite well, thereby making the clustering-of-users effort somewhat less useful. This also explains the poor performance of LINUCB-IND, which is

CTR

0.05 0.045
0.04 0.035
0.03 0.025
0.02 0.015
0.01 0.005
0

Telefonica Dataset
LINUCB-ONE DYNUCB LINUCB-IND CLUB LINUCB-V COFIBA

0.5

1

1.5

2

2.5

3

Rounds

5
x 10

Figure 6: Results on the Telefonica dataset.

Avazu Dataset 0.25

0.2

0.15

CTR

0.1

LINUCB-ONE

DYNUCB

LINUCB-IND

0.05

CLUB

LINUCB-V

COFIBA

0 123456789

Rounds

x 105

Figure 7: Results on the Avazu dataset.

not performing any clustering at all. Yet, even in this nontrivial case, COFIBA can still achieve a significant increased prediction accuracy compared, e.g., to CLUB, thereby suggesting that simultaneous clustering at both the user and the item (the news) sides might be an even more effective strategy to earn clicks in news recommendation systems.
Most of the users in the Telefonica data are from a diverse sample of people in Spain, and it is easy to imagine that this dataset spans a large number of communities across its population. Thus we can assume that collaborative effects will be much more evident, and that COFIBA will be able to leverage these effects efficiently. In this dataset, CLUB performs well in general, while DYNUCB deteriorates in the initial stage and catches-up later on. COFIBA seems to surpass all other algorithms, especially in the cold-start regime, all other algorithms being in the same ballpark as CLUB. Finally, the Avazu data is furnished from its professional digital advertising solution platform, where the customers click the ad impressions via the iOS/Android mobile apps or through websites, serving either the publisher or the advertiser which leads to a daily high volume internet traffic. In this dataset, neither LINUCB-ONE nor LINUCB-IND displayed a competitive cold-start performance. DYNUCB is underperforming throughout, while LINUCB-V demonstrates a relatively high CTR. CLUB is strong at the beginning, but then its CTR performance degrades. On the

545

0.4 0.3

0.2 0.1

0

0

2

4

6

8

10

12

14

16

18

0.8

0.6

0.4

0.2

0

0

2

4

6

8

10

12

14

16

18

0.8

0.6

0.4

0.2

0

0

2

4

6

8

10

12

14

16

18

0.5

0.4

0.3

0.2

0.1

0

0

2

4

6

8

10

12

14

16

18

0.5

0.4

0.3

0.2

0.1

0

0

2

4

6

8

10

12

14

16

18

Figure 8: A typical distribution of cluster sizes over users for the Yahoo dataset. Each bar plot corresponds to a cluster at the item side. We have 5 plots since this is the number of clusters over the items that COFIBA ended up with after sweeping once over this dataset in the run at hand. Each bar represents the fraction of users contained in the corresponding cluster. For instance, the first cluster over the items generated 16 clusters over the users (bar plot on top), with relative sizes 31%, 15%, 12%, etc. The second cluster over the items generated 10 clusters over the users (second bar plot from top) with relative sizes 61%, 12%, 9%, etc. The relative size of the 5 clusters over the items is as follows: 83%, 10%, 4%, 2%, and 1%, so that the clustering pattern depicted in the top plot applies to 83% of the items, the second one to 10% of the items, and so on.

other hand, COFIBA seems to work extremely well during the cold-start, and comparatively best in all later stages.
In Figure 8 we give a typical distribution of cluster sizes produced by COFIBA after at the end of its run.6 The emerging pattern is always the same: we have few clusters over the items with very unbalanced sizes and, corresponding to each item cluster, we have few clusters over the users, again with very unbalanced sizes. This recurring pattern is in fact the motivation behind our theoretical assumptions (Section 2), and a property of data that the COFIBA algorithm can provably take advantage of (Section 6). These bar plots, combined with the comparatively good performance of COFIBA, suggest that our datasets do actually possess clusterability properties at both sides.
To summarize, despite the differences in the three
6Without loss of generality, we take the first Yahoo dataset to provide statistics, for similar shapes of the bar plots can be established for the remaining ones.

datasets, the experimental evidence we collected on them is quite consistent, in that in all the three cases COFIBA significantly outperforms all other competing methods we tested. This is especially noticeable during the cold-start period, but the same relative behavior essentially shows up during the whole time window of our experiments. COFIBA is a bit involved to implement, as contrasted to its competitors, and is also somewhat slower to run (unsurprisingly slower than, say, LINUCB-ONE and LINUCB-IND). On the other hand, COFIBA is far more effective in exploiting the collaborative effects embedded in the data, and still amenable to be run on large datasets.
6. REGRET ANALYSIS
The following theorem is the theoretical guarantee of COFIBA, where we relate the cumulative regret of COFIBA to the clustering structure of users U w.r.t. items I. For simplicity of presentation, we formulate our result in the one-hot encoding case, where ui  Rd, i = 1, . . . , n, and I = {e1, . . . , ed}. In fact, a more general statement can be proven which holds in the case when I is a generic set of feature vectors I = {x1, . . . , x|I|}, and the regret bound depends on the geometric properties of such vectors.7
In order to obtain a provable advantage from our clusterability assumptions, extra conditions are needed on the way it and Cit are generated. The clusterability assumptions we can naturally take advantage of are those where, for most partitions P (eh), the relative sizes of clusters over users are highly unbalanced. Translated into more practical terms, cluster unbalancedness amounts to saying that the universe of items I tends to influence users so as to determine a small number of major common behaviors (which need neither be the same nor involve the same users across items), along with a number of minor ones. As we saw in our experiments, this seems like a frequent behavior of users in some practical scenarios.
Theorem 1. Let the COFIBA algorithm of Figure 1 be run on a set of users U = {1, . . . , n} with associated profile vectors u1, . . . , un  Rd, and set of items I = {e1, . . . , ed} such that the h-th induced partition P (eh) over U is made up of mh clusters of cardinality vh,1, vh,2, . . . , vh,mh , respectively. Moreover, let g be the number of distinct partitions so obtained. At each round t, let it be generated uniformly at random8 from U . Once it is selected, the number ct of items in Cit is generated arbitrarily as a function of past indices i1, . . . , it-1, payoffs a1, . . . , at-1, and sets Ci1 , . . . , Cit-1 , as well as the current index it. Then the sequence of items in Cit is generated i.i.d. (conditioned on it, ct and all past indices i1, . . . , it-1, payoffs a1, . . . , at-1, and sets Ci1 , . . . , Cit-1 ) according to a given but unknown distribution D over I. Let payoff at lie in the interval [-1, 1], and be generated as described in Section 2 so that, conditioned on history, the expectation of at is uit x¯t. Finally, let parameters  and 2 be suitable functions of log(1/). If ct  c t then, as T grows large, with probability at least
7In addition, the function cb should be modified so as to incorporate these properties. 8Any distribution having positive probability on each i  U would suffice here.

546

1 -  the cumulative regret satisfies9

T
rt = O
t=1

 E[S] + c mn var(S) + 1

dT ,
n

where S = S(h) =

mh j=1

vh,j

,

h

is

a

random

index

such

that eh  D, and E[·] and var(·) denote, respectively, the

expectation and the variance w.r.t. this random index.

To get a feeling of how big (or small) E[S] and var[S] can be, let us consider the case where each partition over users has a single big cluster and a number of small ones. To make it clear, consider the extreme scenario where each P (eh) has one cluster of size vh,1 = n- (m - 1), and m - 1 clusters of size vh,j = 1, with m < n. Then it is easy to see that
E[S] = n - (m - 1) + m - 1, and var(S) =0, so that the resulting regret bound essentially becomes O( dT ), which is the standard regret bound one achieves for learning a single d-dimensional user (aka, the standard noncontextual bandit bound with d actions and no gap assumptions among them). At the other extreme lies the case when each partition P (eh) has n-many clusters, so that E[S] = n, var(S) = 0, and the resulting bound is O( dnT ). Looser upper bounds can be achieved in the case when var(S) > 0, where also the interplay with c starts becoming relevant. Finally, observe that the number g of distinct partitions influences the bound only indirectly through var(S). Yet, it is worth repeating here that g plays a crucial role in the computational (both time and space) complexity of the whole procedure.

Proof of Theorem 1. The proof sketch builds on the

analysis in [1]. Let the true underlying clusters over the

users be Vh,1, Vh,2, . . . , Vh,mh , with |Vh,j | = vh,j . In [1], the authors show that, because each user i has probability 1/n

to be the one served in round t, we have, with high prob-

ability, wi,t  ui for all i, as t grows large. Moreover,

because of the gap assumption involving parameter , all

edges connecting users belonging to different clusters at the

user side will eventually be deleted (again, with high prob-

ability),

after

each

user

i

is

served

at

least

O(

1 2

)

times.

By

the way edges are disconnected at the item side, the above

is essentially independent (up to log factors due to union

bounds) of which graph at the user side we are referring to.

In turn, this entails that the current user clusters encoded

by the connected components of graph GUt,h will eventually converge to the mh true user clusters (again, independent

of h, up to log factors), so that the aggregate weight vectors

w¯ Nk,t-1 computed by the algorithm for trading off exploration vs. exploitation in round t will essentially converge to uit at a rate of the form10

1

E

,

(1)

1 + Tht,jt,t-1/d

where ht is the index of the true cluster over items that x¯t belongs to, jt is the index of the true cluster over users that it belongs to (according to the partition of U determined

9The O-notation hides logarithmic factors in n, m, g, T , d, 1/, as well as terms which are independent of T . 10Because I = {e1, . . . , ed}, the minimal eigenvalue  of the
process correlation matrix E[X X ] in [1] is here 1/d. Moreover, compared to [1], we do not strive to capture the geometry of the user vectors ui in the regret bound, hence we do not have the extra m factor occurring in their bound.

by ht), Tht,jt,t-1 is the number of rounds so far where we happened to "hit" cluster Vht,jt , i.e.,

Tht,jt,t-1 = |{s  t - 1 : is  Vht,jt }| ,

and the expectation is w.r.t. both the (uniform) distribution of it, and distribution D generating the items in Cit , conditioned on all past events. Since, by the Azuma-Hoeffding inequality, Tht,jt,t-1 concentrates as
t-1 Tht,jt,t-1  n vht,jt ,

we have

(1)



ED

mht 

vht ,j n

j=1



1 .

1

+

t-1 dn

vht ,j

It is the latter expression that rules the cumulative regret of COFIBA in that, up to log factors:

T

rt 

T

mht ED 

vht ,j n

t=1

t=1

j=1



1

.

1

+

t-1 dn

vht ,j

(2)

Eq. (2) is essentially (up to log factors and omitted additive terms) the regret bound one would obtain by knowning beforehand the latent clustering structure over U.
Because ht  Cit is itself a function of the items in Cit , we can eliminate the dependence on ht by the following simple stratification argument. First of all, notice that

v mht
ht ,j
n
j=1

1



1

+

t-1 dn

vht ,j

d mht 

nt

vht,j .

j=1

Then, we set for brevity S(h) =

mh j=1

vh,j ,

and

let

ht,k

be

the index of the true cluster over items that xt,k belongs to

(recall that ht,k is a random variable since so is xt,k). Since S(ht,k)  mn, a standard argument shows that

ED [S(ht)]  ED max S(ht,k)
k=1,...,ct
  ED[S(ht,1)] + c mn varD(S(ht,1)) + 1 ,

so that, after some overapproximations, we conclude that

T t=1

rt

is

upper

bounded

with

high

probability

by

 O ED[S(h)] + c mn varD(S(h)) + 1

dT ,
n

the expectation and the variance being over the random index h such that eh  D.

7. CONCLUSIONS
We have initiated an investigation of collaborative filtering bandit algorithms operating in relevant scenarios where multiple users can be grouped by behavior similarity in different ways w.r.t. items and, in turn, the universe of items can possibly be grouped by the similarity of clusterings they induce over users. We carried out an extensive experimental comparison with very encouraging results, and have also given a regret analysis which operates in a simplified scenario. Our algorithm can in principle be modified so as to be combined with any standard clustering (or co-clustering) technique. However, one advantage of encoding clusters as connected components of graphs (at least at the user side) is

547

that we are quite effective in tackling the so-called cold start problem, for the newly served users are more likely to be connected to the old ones, which makes COFIBA in a position to automatically propagate information from the old users to the new ones through the aggregate vectors w¯ Nk,t. In fact, so far we have not seen any other way of adaptively clustering users and items which is computationally affordable on sizeable datasets and, at the same time, amenable to a regret analysis that takes advantage of the clustering assumption.
All our experiments have been conducted in the setup of one-hot encoding, since the datasets at our disposal did not come with reliable/useful annotations on data. Yet, the algorithm we presented can clearly work when the items are accompanied by (numerical) features. One direction of our future research is to compensate for the lack of features in the data by first inferring features during an initial training phase through standard matrix factorization techniques, and subsequently applying our algorithm to a universe of items I described through such inferred features. Another line of experimental research would be to combine different bandit algorithms (possibly at different stages of the learning process) so as to roughly get the best of all of them in all stages. This would be somewhat similar to the metabandit construction described in [25]. Another one would be to combine with matrix factorization techniques as in, e.g., [20].
8. ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their helpful and constructive comments. The first author thanks the support from MIUR and QCRI-HBKU. Also, the first and the third author acknowledge the support from Amazon AWS Award in Machine Learning Research Grant. The work leading to these results has received funding from the European Union's Seventh Framework Programme (FP7/ 2007-2013) under CrowdRec Grant Agreement n 610594.
9. REFERENCES
[1] C. Gentile, S. Li, and G. Zappella. Online clustering of bandits. In ICML, 2014.
[2] N. Korda, B. Szorenyi, and S. Li, Distributed Clustering of Linear Bandits in Peer to Peer Networks. In ICML, 2016.
[3] Y. Abbasi-Yadkori, D. P´al, and C. Szepesv´ari. Improved algorithms for linear stochastic bandits. 2011.
[4] J.-Y. Audibert, R. Munos, and C. Szepesv´ari. Exploration-exploitation tradeoff using variance estimates in multi-armed bandits. Theoretical Computer Science, 410(19):1876­1902, 2009.
[5] P. Auer. Using confidence bounds for exploration-exploitation trade-offs. Journal of Machine Learning Research, 3:397­422, 2002.
[6] P. Auer, N. Cesa-Bianchi, and P. Fischer. Finite-time analysis of the multiarmed bandit problem. Machine Learning, 2001.
[7] M. G. Azar, A. Lazaric, and E. Brunskill. Sequential transfer in multi-armed bandit with finite set of models. In NIPS, pages 2220­2228, 2013.
[8] G. Bresler, G. Chen, and S. D. A latent source model for online collaborative filtering. In NIPS. MIT Press, 2014.
[9] E. Brunskill and L. Li. Sample complexity of multi-task reinforcement learning. In UAI, 2013.
[10] W. Cao, J. Li, Y. Tao, and Z. Li. On top-k selection in multi-armed bandits and hidden bipartite graphs. In NIPS, 2015.

[11] G. Cavallanti, N. Cesa-Bianchi, and C. Gentile. Tracking the best hyperplane with a simple budget perceptron. Machine Learning, 69/2:143­167, 2007.
[12] W. Chu, L. Li, L. Reyzin, and R. E. Schapire. Contextual bandits with linear payoff functions. In AISTATS, 2011.
[13] K. Crammer and C. Gentile. Multiclass classification with bandit feedback using adaptive regularization. In ICML, 2011.
[14] I. S. Dhillon. Co-clustering documents and words using bipartite spectral graph partitioning. In 7th KDD, pages 269­274. ACM, 2001.
[15] I. S. Dhillon, S. Mallela, and D. S. Modha. Information-theoretic co-clustering. In 9th KDD, pages 89­98, New York, NY, USA, 2003. ACM.
[16] J. Djolonga, A. Krause, and V. Cevher. High-dimensional gaussian process bandits. In NIPS, pages 1025­1033, 2013.
[17] M. Dudik, D. Erhan, J. Langford, and L. Li. Sample-efficient nonstationary-policy evaluation for contextual bandits. In UAI, 2012.
[18] T. George and S. Merugu. A scalable collaborative filtering framework based on co-clustering. In 5th ICDM, pages 625­628. IEEE Computer Society, 2005.
[19] F. Hao, S. Li, G. Min, H. Kim, S. Yau, and L. Yang, An Efficient Approach to Generating Location-Sensitive Recommendations in Ad-hoc Social Network Environments. IEEE Transactions on Services Computing, 8:3, pp. 520­533, 2015.
[20] J. Kawale, H. Bui, B. Kveton, L. Thanh, and S. Chawla. Efficient thompson sampling for online matrix-factorization recommendation. In NIPS, 2015.
[21] A. Krause and C. Ong. Contextual gaussian process bandit optimization. In 25th NIPS, 2011.
[22] B. Kveton, C. Szepesvari, Z. Wen, and A. Ashkan. Cascading bandits: Learning to rank in the cascade model. In ICML, 2015.
[23] L. Li, W. Chu, J. Langford, and R. Schapire. A contextual-bandit approach to personalized news article recommendation. In WWW, pages 661­670, 2010.
[24] S. Li, F. Hao, M. Li, and H.C. Kim. Medicine Rating Prediction and Recommendation in Mobile Social Networks. In International Conference on Green, Pervasive and Cloud Computing, 2013.
[25] L. Tang, Y. Jiang, L. Li, and T. Li. Ensemble contextual bandits for personalized recommendation. In RecSys, 2014.
[26] S. Li, C. Gentile, and A. Karatzoglou. Graph clustering bandits for recommendation. arXiv:1605.00596.
[27] O. Maillard and S. Mannor. Latent bandits. In ICML, 2014.
[28] E. Moroshko, N. Vaits, and K. Crammer. Second-order non-stationary online learning for regression. Journal of Machine Learning Research, 16:1481­1517, 2015.
[29] T. T. Nguyen and H. W. Lauw. Dynamic clustering of contextual multi-armed bandits. In 23rd CIKM, pages 1959­1962. ACM, 2014.
[30] Y. Seldin, P. Auer, F. Laviolette, J. Shawe-Taylor, and R. Ortner. Pac-bayesian analysis of contextual bandits. In NIPS, pages 1683­1691, 2011.
[31] I. Sutskever, R. Salakhutdinov, and J. Tenenbaum. Modelling relational data using bayesian clustered tensor factorization. In NIPS, pages 1821­1828. MIT Press, 2009.
[32] L. Tang, Y. Jiang, L. Li, C. Zeng, and T. Li. Personalized recommendation via parameter-free contextual bandits. In SIGIR. ACM, 2015.
[33] K. Verstrepen and B. Goethals. Unifying nearest neighbors collaborative filtering. In RecSys, 2014.
[34] Y. Yue, S. A. Hong, and C. Guestrin. Hierarchical exploration for accelerating contextual bandits. In ICML, 2012.

548

