arXiv:1906.10025v2 [cs.LG] 6 Jul 2019

Moscow State University Faculty of Computational Mathematics and Cybernetics
Department of Mathematical Methods of Forecasting
Modern Deep Reinforcement Learning Algorithms
Written by: Sergey Ivanov qbrick@mail.ru Scientific advisor: Alexander D'yakonov djakonov@mail.ru
Moscow, 2019

Contents

1 Introduction

4

2 Reinforcement Learning problem setup

5

2.1 Assumptions of RL setting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.2 Environment model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

2.3 Objective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

2.4 Value functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

2.5 Classes of algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.6 Measurements of performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

3 Value-based algorithms

10

3.1 Temporal Difference learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

3.2 Deep Q-learning (DQN) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.3 Double DQN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.4 Dueling DQN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

3.5 Noisy DQN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3.6 Prioritized experience replay . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3.7 Multi-step DQN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

4 Distributional approach for value-based methods

20

4.1 Theoretical foundations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

4.2 Categorical DQN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

4.3 Quantile Regression DQN (QR-DQN) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

4.4 Rainbow DQN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

5 Policy Gradient algorithms

29

5.1 Policy Gradient theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

5.2 REINFORCE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

5.3 Advantage Actor-Critic (A2C) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

5.4 Generalized Advantage Estimation (GAE) . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

5.5 Natural Policy Gradient (NPG) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

5.6 Trust-Region Policy Optimization (TRPO) . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

5.7 Proximal Policy Optimization (PPO) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

6 Experiments

41

6.1 Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

6.2 Cartpole . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

6.3 Pong . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

6.4 Interaction-training trade-off in value-based algorithms . . . . . . . . . . . . . . . . . . 43

6.5 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

7 Discussion

47

A Implementation details

50

B Hyperparameters

51

C Training statistics on Pong

52

D Playing Pong behaviour

54

2

Abstract Recent advances in Reinforcement Learning, grounded on combining classical theoretical results with Deep Learning paradigm, led to breakthroughs in many artificial intelligence tasks and gave birth to Deep Reinforcement Learning (DRL) as a field of research. In this work latest DRL algorithms are reviewed with a focus on their theoretical justification, practical limitations and observed empirical properties.
3

1. Introduction
During the last several years Deep Reinforcement Learning proved to be a fruitful approach to many artificial intelligence tasks of diverse domains. Breakthrough achievements include reaching human-level performance in such complex games as Go [22], multiplayer Dota [16] and real-time strategy StarCraft II [26]. The generality of DRL framework allows its application in both discrete and continuous domains to solve tasks in robotics and simulated environments [12].
Reinforcement Learning (RL) is usually viewed as general formalization of decision-making task and is deeply connected to dynamic programming, optimal control and game theory. [23] Yet its problem setting makes almost no assumptions about world model or its structure and usually supposes that environment is given to agent in a form of black-box. This allows to apply RL practically in all settings and forces designed algorithms to be adaptive to many kinds of challenges. Latest RL algorithms are usually reported to be transferable from one task to another with no task-specific changes and little to no hyperparameters tuning.
As an object of desire is a strategy, i. e. a function mapping agent's observations to possible actions, reinforcement learning is considered to be a subfiled of machine learning. But instead of learning from data, as it is established in classical supervised and unsupervised learning problems, the agent learns from experience of interacting with environment. Being more "natural" model of learning, this setting causes new challenges, peculiar only to reinforcement learning, such as necessity of exploration integration and the problem of delayed and sparse rewards. The full setup and essential notation are introduced in section 2.
Classical Reinforcement Learning research in the last third of previous century developed an extensive theoretical core for modern algorithms to ground on. Several algorithms are known ever since and are able to solve small-scale problems when either environment states can be enumerated (and stored in the memory) or optimal policy can be searched in the space of linear or quadratic functions of state representation features. Although these restrictions are extremely limiting, foundations of classical RL theory underlie modern approaches. These theoretical fundamentals are discussed in sections 3.1 and 5.1­5.2.
Combining this framework with Deep Learning [5] was popularized by Deep Q-Learning algorithm, introduced in [14], which was able to play any of 57 Atari console games without tweaking network architecture or algorithm hyperparameters. This novel approach was extensively researched and significantly improved in the following years. The principles of value-based direction in deep reinforcement learning are presented in section 3.
One of the key ideas in the recent value-based DRL research is distributional approach, proposed in [1]. Further extending classical theoretical foundations and coming with practical DRL algorithms, it gave birth to distributional reinforcement learning paradigm, which potential is now being actively investigated. Its ideas are described in section 4.
Second main direction of DRL research is policy gradient methods, which attempt to directly optimize the objective function, explicitly present in the problem setup. Their application to neural networks involve a series of particular obstacles, which requested specialized optimization techniques. Today they represent a competitive and scalable approach in deep reinforcement learning due to their enormous parallelization potential and continuous domain applicability. Policy gradient methods are discussed in section 5.
Despite the wide range of successes, current state-of-art DRL methods still face a number of significant drawbacks. As training of neural networks requires huge amounts of data, DRL demonstrates unsatisfying results in settings where data generation is expensive. Even in cases where interaction is nearly free (e. g. in simulated environments), DRL algorithms tend to require excessive amounts of iterations, which raise their computational and wall-clock time cost. Furthermore, DRL suffers from random initialization and hyperparameters sensitivity, and its optimization process is known to be uncomfortably unstable [9]. Especially embarrassing consequence of these DRL features turned out to be low reproducibility of empirical observations from different research groups [6]. In section 6, we attempt to launch state-of-art DRL algorithms on several standard testbed environments and discuss practical nuances of their application.
4

2. Reinforcement Learning problem setup
2.1. Assumptions of RL setting
Informally, the process of sequential decision-making proceeds as follows. The agent is provided with some initial observation of environment and is required to choose some action from the given set of possibilities. The environment responds by transitioning to another state and generating a reward signal (scalar number), which is considered to be a ground-truth estimation of agent's performance. The process continues repeatedly with agent making choices of actions from observations and environment responding with next states and reward signals. The only goal of agent is to maximize the cumulative reward.
This description of learning process model already introduces several key assumptions. Firstly, the time space is considered to be discrete, as agent interacts with environment sequentially. Secondly, it is assumed that provided environment incorporates some reward function as supervised indicator of success. This is an embodiment of the reward hypothesis, also referred to as Reinforcement Learning hypothesis:
Proposition 1. (Reward Hypothesis) [23] «All of what we mean by goals and purposes can be well thought of as maximization of the expected value of the cumulative sum of a received scalar signal (reward).»
Exploitation of this hypothesis draws a line between reinforcement learning and classical machine learning settings, supervised and unsupervised learning. Unlike unsupervised learning, RL assumes supervision, which, similar to labels in data for supervised learning, has a stochastic nature and represents a key source of knowledge. At the same time, no data or «right answer» is provided to training procedure, which distinguishes RL from standard supervised learning. Moreover, RL is the only machine learning task providing explicit objective function (cumulative reward signal) to maximize, while in supervised and unsupervised setting optimized loss function is usually constructed by engineer and is not «included» in data. The fact that reward signal is incorporated in the environment is considered to be one of the weakest points of RL paradigm, as for many real-life human goals introduction of this scalar reward signal is at the very least unobvious.
For practical applications it is also natural to assume that agent's observations can be represented by some feature vectors, i. e. elements of Rd. The set of possible actions in most practical applications is usually uncomplicated and is either discrete (number of possible actions is finite) or can be represented as subset of Rm (almost always [-1, 1]m or can be reduced to this case)1. RL algorithms are usually restricted to these two cases, but the mix of two (agent is required to choose both discrete and continuous quantities) can also be considered.
The final assumption of RL paradigm is a Markovian property:
Proposition 2. (Markovian property) Transitions depend solely on previous state and the last chosen action and are independent of all previous interaction history.
Although this assumption may seem overly strong, it actually formalizes the fact that the world modeled by considered environment obeys some general laws. Giving that the agent knows the current state of the world and the laws, it is assumed that it is able to predict the consequences of his actions up to the internal stochasticity of these laws. In practice, both laws and complete state representation is unavailable to agent, which limits its forecasting capability.
In the sequel we will work within the setting with one more assumption of full observability. This simplification supposes that agent can observe complete world state, while in many real-life tasks only a part of observations is actually available. This restriction of RL theory can be removed by considering Partially observable Markov Decision Processes (PoMDP), which basically forces learning algorithms to have some kind of memory mechanism to store previously received observations. Further on we will stick to fully observable case.
1this set is considered to be permanent for all states of environment without any loss of generality as if agent chooses invalid action the world may remain in the same state with zero or negative reward signal or stochastically select some valid action for him.
5

2.2. Environment model
Though the definition of Markov Decision Process (MDP) varies from source to source, its essential meaning remains the same. The definition below utilizes several simplifications without loss of generality.2

Definition 1. Markov Decision Process (MDP) is a tuple (S, A, T, r, s0), where:
· S  Rd -- arbitrary set, called the state space.
· A -- a set, called the action space, either
­ discrete: |A| < +, or ­ continuous domain: A = [-1, 1]m.
· T -- transition probability p(s | s, a), where s, s  S, a  A.
· r : S  R -- reward function.
· s0  S -- starting state.
It is important to notice that in the most general case the only things available for RL algorithm beforehand are d (dimension of state space) and action space A. The only possible way of collecting more information for agent is to interact with provided environment and observe s0. It is obvious that the first choice of action a0 will be probably random. While the environment responds by sampling s1  p(s1 | s0, a0), this distribution, defined in T and considered to be a part of MDP, may be unavailable to agent's learning procedure. What agent does observe is s1 and reward signal r1 := r(s1) and it is the key information gathered by agent from interaction experience.

Definition 2. The tuple (st, at, rt+1, st+1) is called transition. Several sequential transitions are usually referred to as roll-out. Full track of observed quantities

is called a trajectory.

s0, a0, r1, s1, a1, r2, s2, a2, r3, s3, a3 . . .

In general case, the trajectory is infinite which means that the interaction process is neverend-
ing. However, in most practical cases the episodic property holds, which basically means that the interaction will eventually come to some sort of an end3. Formally, it can be simulated by the envi-
ronment stucking in the last state with zero probability of transitioning to any other state and zero
reward signal. Then it is convenient to reset the environment back to s0 to initiate new interaction. One such interaction cycle from s0 till reset, spawning one trajectory of some finite length T , is called an episode. Without loss of generality, it can be considered that there exists a set of terminal states S+, which mark the ends of interactions. By convention, transitions (st, at, rt+1, st+1) are accompanied with binary flag donet+1  {0, 1}, whether st+1 belongs to S+. As timestep t at which the transition was gathered is usually of no importance, transitions are often denoted as
(s, a, r , s , done) with primes marking the «next timestep».
Note that the length of episode T may vary between different interactions, but the episodic property holds if interaction is guaranteed to end after some finite time T max. If this is not the case, the task is called continuing.

2.3. Objective
In reinforcement learning, the agent's goal is to maximize a cumulative reward. In episodic case, this reward can be expressed as a summation of all received reward signals during one episode and
2the reward function is often introduced as stochastic and dependent on action a, i. e. R(r | s, a) : S × A  P(R), while instead of fixed s0 a distribution over S is given. Both extensions can be taken into account in terms of presented definition by extending the state space and incorporating all the uncertainty into transition probability T.
3natural examples include the end of the game or agent's failure/success in completing some task.

6

is called the return:
T

R := rt

(1)

t=1

Note that this quantity is formally a random variable, which depends on agent's choices and the

outcomes of environment transitions. As this stochasticity is an inevitable part of interaction process,

the underlying distribution from which rt is sampled must be properly introduced to set rigorously the task of return maximization.

Definition 3. Agent's algorithm for choosing a by given current state s, which in general can be viewed as distribution (a | s) on domain A, is called a policy (strategy).
Deterministic policy, when the policy is represented by deterministic function  : S  A, can be viewed as a particular case of stochastic policy with degenerated policy (a | s), when agent's output is still a distribution with zero probability to choose an action other than (s). In both cases it is considered that agent sends to environment a sample a  (a | s).
Note that given some policy (a | s) and transition probabilities T, the complete interaction process becomes defined from probabilistic point of view:

Definition 4. For given MDP and policy , the probability of observing

s0, a0, s1, a1, s2, a2 . . . is called trajectory distribution and is denoted as T:

T := p(st+1 | st, at)(at | st)
t=0

It is always substantial to keep track of what policy was used to collect certain transitions (roll-outs
and episodes) during the learning procedure, as they are essentially samples from corresponding
trajectory distribution. If the policy is modified in any way, the trajectory distribution changes either. Now when a policy induces a trajectory distribution, it is possible to formulate a task of expected
reward maximization:

T

ET

rt



max


t=1

To ensure the finiteness of this expectation and avoid the case when agent is allowed to gather infinite reward, limit on absolute value of rt can be assumed:

|rt|  Rmax

Together with the limit on episode length T max this restriction guarantees finiteness of optimal (maximal) expected reward.
To extend this intuition to continuing tasks, the reward for each next interaction step is multiplied
on some discount coefficient   [0, 1), which is often introduced as part of MDP. This corresponds to the logic that with probability 1 -  agent «dies» and does not gain any additional reward, which models the paradigm «better now than later». In practice, this discount factor is set very close to 1.

Definition 5. For given MDP and policy  the discounted expected reward is defined as

J () := ET trt+1
t=0

Reinforcement learning task is to find an optimal policy , which maximizes the discounted

expected reward:

J ()  max

(2)



7

2.4. Value functions
Solving reinforcement learning task (2) usually leads to a policy, that maximizes the expected reward not only for starting state s0, but for any state s  S. This follows from the Markov property: the reward which is yet to be collected from some step t does not depend on previous history and for agent staying at state s the task of behaving optimal is equivalent to maximization of expected reward with current state s as a starting state. This is the particular reason why many reinforcement learning algorithms do not seek only optimal policy, but additional information about usefulness of each state.

Definition 6. For given MDP and policy  the value function under policy  is defined as

V (s) := ET|s0=s

 t rt+1

t=0

This value function estimates how good it is for agent utilizing strategy  to visit state s and generalizes the notion of discounted expected reward J () that corresponds to V (s0).
As value function can be induced by any policy, value function V  (s) under optimal policy  can also be considered. By convention4, it is denoted as V (s) and is called an optimal value function.
Obtaining optimal value function V (s) doesn't provide enough information to reconstruct some optimal policy  due to unknown world dynamics, i. e. transition probabilities. In other words, be-
ing blind to what state s may be the environment's response on certain action in a given state makes
knowing optimal value function unhelpful. This intuition suggests to introduce a similar notion com-
prising more information:

Definition 7. For given MDP and policy  the quality function (Q-function) under policy  is

defined as

Q(s, a) := ET|s0=s,a0=a

 t rt+1

t=0

It directly follows from the definitions that these two functions are deeply interconnected:

Q(s, a) = Es p(s |s,a) [r(s ) + V (s )]

(3)

V (s) = Ea(a|s)Q(s, a)

(4)

The notion of optimal Q-function Q(s, a) can be introduced analogically. But, unlike value function, obtaining Q(s, a) actually means solving a reinforcement learning task: indeed,

Proposition 3. If Q(s, a) is a quality function under some optimal policy, then
(s) = argmax Q(s, a)
a
is an optimal policy.
This result implies that instead of searching for optimal policy , an agent can search for optimal Q-function and derive the policy from it.

Proposition 4. For any MDP existence of optimal policy leads to existence of deterministic optimal policy.
4though optimal policy may not be unique, the value functions under any optimal policy that behaves optimally from any given state (not only s0) coincide. Yet, optimal policy may not know optimal behaviour for some states if it knows how to avoid them with probability 1.

8

2.5. Classes of algorithms
Reinforcement learning algorithms are presented in a form of computational procedures specifying a strategy of collecting interaction experience and obtaining a policy with as higher J () as possible. They rarely include a stopping criterion like in classic optimization methods as the stochasticity of given setting prevents any reasonable verification of optimality; usually the number of iterations to perform is determined by the amount of computational resources. All reinforcement learning algorithms can be roughly divided into four5 classes:
· meta-heuristics: this class of algorithms treats the task as black-box optimization with zerothorder oracle. They usually generate a set of policies 1 . . . P and launch several episodes of interaction for each to determine best and worst policies according to average return. After that they try to construct more optimal policies using evolutionary or advanced random search techniques [17].
· policy gradient: these algorithms directly optimize (2), trying to obtain  and no additional information about MDP, using approximate estimations of gradient with respect to policy parameters. They consider RL task as an optimization with stochastic first-order oracle and make use of interaction structure to lower the variance of gradient estimations. They will be discussed in sec. 5.
· value-based algorithms construct optimal policy implicitly by gaining an approximation of optimal Q-function Q(s, a) using dynamic programming. In DRL, Q-function is represented with neural network and an approximate dynamic programming is performed using reduction to supervised learning. This framework will be discussed in sec. 3 and 4.
· model-based algorithms exploit learned or given world dynamics, i. e. distributions p(s | s, a) from T. The class of algorithms to work with when the model is explicitly provided is represented by such algorithms as Monte-Carlo Tree Search; if not, it is possible to imitate the world dynamics by learning the outputs of black box from interaction experience [10].
2.6. Measurements of performance
Achieved performance (score) from the point of average cumulative reward is not the only one measure of RL algorithm quality. When speaking of real-life robots, the required number of simulated episodes is always the biggest concern. It is usually measured in terms of interaction steps (where step is one transition performed by environment) and is referred to as sample efficiency.
When the simulation is more or less cheap, RL algorithms can be viewed as a special kind of optimization procedures. In this case, the final performance of the found policy is opposed to required computational resources, measured by wall-clock time. In most cases RL algorithms can be expected to find better policy after more iterations, but the amount of these iterations tend to be unjustified.
The ratio between amount of interactions and required wall-clock time for one update of policy varies significantly for different algorithms. It is well-known that model-based algorithms tend to have the greatest sample-efficiency at the cost of expensive update iterations, while evolutionary algorithms require excessive amounts of interactions while providing massive resources for parallelization and reduction of wall-clock time. Value-based and policy gradient algorithms, which will be the focus of our further discussion, are known to lie somewhere in between.
5in many sources evolutionary algorithms are bypassed in discussion as they do not utilize the structure of RL task in any way.
9

3. Value-based algorithms
3.1. Temporal Difference learning
In this section we consider temporal difference learning algorithm [23, Chapter 6], which is a classical Reinforcement Learning method in the base of modern value-based approach in DRL.
The first idea behind this algorithm is to search for optimal Q-function Q(s, a) by solving a system of recursive equations which can be derived by recalling interconnection between Q-function and value function (3):

Q(s, a) = Es p(s |s,a) [r(s ) + V (s )] = = {using (4)} = Es p(s |s,a) r(s ) + Ea (a |s )Q(s , a )
This equation, named Bellman equation, remains true for value functions under any policies including optimal policy :

Q(s, a) = Es p(s |s,a) r(s ) + Ea (a |s )Q(s , a )

(5)

Recalling proposition 3, optimal (deterministic) policy can be represented as (s) = argmax
a
Q(s, a). Substituting this for (s) in (5), we obtain fundamental Bellman optimality equation:

Proposition 5. (Bellman optimality equation)

Q(s, a) = Es p(s |s,a) r(s ) +  max Q(s , a )

(6)

a

The straightforward utilization of this result is as follows. Consider the tabular case, when both state space S and action space A are finite (and small enough to be listed in computer memory). Let us also assume for now that transition probabilities are available to training procedure. Then Q(s, a) : S × A  R can be represented as a finite table with |S||A| numbers. In this case (6) just gives a set of |S||A| equations for this table to satisfy.
Addressing the values of the table as unknown variables, this system of equations can be solved using basic point iteration method: let Q0(s, a) be initial arbitrary values of table (with the only exception that for terminal states s  S+, if any, Q0(s, a) = 0 for all actions a). On each iteration t the table is updated by substituting current values of the table to the right side of equation until the
process converges:

Qt+1(s, a) = Es p(s |s,a)

r(s

)

+



max
a

Qt (s

,

a

)

(7)

This straightforward approach of learning the optimal Q-function, named Q-learning, has been extensively studied in classical Reinforcement Learning. One of the central results is presented in
the following convergence theorem:

Proposition 6. Let by B denote an operator (S × A  R)  (S × A  R), updating Qt as in (7):
Qt+1 = BQt for all state-action pairs s, a.
Then B is a contraction mapping, i. .e. for any two tables Q1, Q2  (S × A  R)
BQ1 - BQ2    Q1 - Q2 
Therefore, there is a unique fixed point of the system of equations (7) and the point iteration method converges to it.
The contraction mapping property is actually of high importance. It demonstrates that the point iteration algorithm converges with exponential speed and requires small amount of iterations. As the true Q is a fixed point of (6), the algorithm is guaranteed to yield a correct answer. The trick is
10

that each iteration demands full pass across all state-action pairs and exact computation of expec-
tations over transition probabilities.
In general case, these expectations can't be explicitly computed. Instead, agent is restricted to samples from transition probabilities gained during some interaction experience. Temporal Difference (TD)6 algorithm proposes to collect this data using t = argmax Qt (s, a)   and after
a
each gathered transition (st, at, rt+1, st+1) update only one cell of the table:



Qt+1(s,

a)

=

(1 - t)Qt (s, Qt (s, a)

a)

+

t

rt+1

+



max
a

Qt (st+1,

a

)

if s = st, a = at else

(8)

where t  (0, 1) plays the role of exponential smoothing parameter for estimating expectation Es p(s |st,at)(·) from samples.
Two key ideas are introduced in the update formula (8): exponential smoothing instead of exact
expectation computation and cell by cell updates instead of updating full table at once. Both are
required to settle Q-learning algorithm for online application. As the set S+ of terminal states in online setting is usually unknown beforehand, a slight modifi-
cation of update (8) is used. If observed next state s turns out to be terminal (recall the convention to denote this by flag done), its value function is known to be equal to zero:

V (s ) = max Q(s , a ) = 0
a

This

knowledge

is

embedded

in

the

update

rule

(8)

by

multiplying

max
a

Qt (st+1,

a

)

on

(1

-

donet+1). For the sake of shortness, this factor is often omitted but should be always present in

implementations.

Second important note about formula (8) is that it can be rewritten in the following equivalent

way:



Qt+1(s,

a)

=

Qt (s, Qt (s,

a) a)

+

t

rt+1

+



max
a

Qt (st+1,

a

)

-

Qt (s,

a)

if s = st, a = at (9) else

The expression in the brackets, referred to as temporal difference, represents a difference be-

tween

Q-value

Qt (s,

a)

and

its

one-step

approximation

rt+1

+



max
a

Qt (st+1,

a

),

which

must

be

zero in expectation for true optimal Q-function.

The idea of exponential smoothing allows us to formulate first practical algorithm which can work

in the tabular case with unknown world dynamics:

Algorithm 1: Temporal Difference algorithm
Hyperparameters: t  (0, 1) Initialize Q(s, a) arbitrary On each interaction step:
1. select a = argmax Q(s, a)
a
2. observe transition (s, a, r , s , done) 3. update table:
Q(s, a)  Q(s, a) + t r + (1 - done) max Q(s , a ) - Q(s, a)
a

It turns out that under several assumptions on state visitation during interaction process this procedure holds similar properties in terms of convergence guarantees, which are stated by the following theorem:
6also known as TD(0) due to theoretical generalizations
11

Proposition 7. [28] Let's define

et(s, a) =

t (s, a) is updated on step t 0 otherwise

Then if for every state-action pair (s, a)

+

+

et(s, a) = 

et(s, a)2 < 

t

t

the algorithm 1 converges to optimal Q with probability 1.

This theorem states that basic policy iteration method can be actually applied online in the way
proposed by TD algorithm, but demands «enough exploration» from the strategy of interacting with
MDP during training. Satisfying this demand remains a unique and common problem of reinforce-
ment learning. The widespread kludge is -greedy strategy which basically suggests to choose random action
instead of a = argmax Q(s, a) with probability t. The probability t is usually set close to 1
a
during first interaction iterations and scheduled to decrease to a constant close to 0. This heuristic
makes agent visit all states with non-zero probabilities independent of what current approximation Q(s, a) suggests.
The main practical issue with Temporal Difference algorithm is that it requires table Q(s, a) to be explicitly stored in memory, which is impossible for MDP with high state space complexity. This
limitation substantially restricted its applicability until its combination with deep neural network was
proposed.

3.2. Deep Q-learning (DQN)

Utilization of neural nets to model either a policy or a Q-function frees from constructing task-

specific features and opens possibilities of applying RL algorithms to complex tasks, e. g. tasks with

images as input. Video games are classical example of such tasks where raw pixels of screen are

provided as state representation and, correspondingly, as input to either policy or Q-function.

Main idea of Deep Q-learning [14] is to adapt Temporal Difference algorithm so that update for-

mula (9) would be equivalent to gradient descent step for training a neural network to solve a certain

regression task. Indeed, it can be noticed that the exponential smoothing parameter t resembles learning rate of first-order gradient optimization procedures, while the exploration conditions from

theorem 7 look identical to restrictions on learning rate of stochastic gradient descent.

The key hint is that (9) is actually a gradient descent step in the parameter space of the table

functions family:

Q(s, a, ) = s,a

where all s,a form a vector of parameters   R|S||A|. To unravel this fact, it is convenient to introduce some notation from regression tasks. First, let's
denote by y the target of our regression task, i. e. the quantity that our model is trying to predict:

y(s, a) := r(s ) +  max Q(s , a , )

(10)

a

where s is a sample from p(s | s, a) and s, a is input data. In this notation (9) is equivalent to:

t+1 = t + t [y(s, a) - Q(s, a, t)] es,a

where we multiplied scalar value t [y(s, a) - Q(s, a, t)] on the following vector es,a

esi,,ja :=

1 0

(i, j) = (s, a) (i, j) = (s, a)

to formulate an update of only one component of  in a vector form. By this we transitioned to update in parameter space using Q(s, a, ) = s,a. Remark that for table functions family the
12

derivative of Q(s, a, ) by  for given input s, a is its one-hot encoding, i. e. exactly es,a:

Q(s, a, ) = es,a

(11)



The statement now is that this formula is a gradient descent update for regression with input s, a, target y(s, a) and MSE loss function:

Loss(y(s, a), Q(s, a, t)) = (Q(s, a, t) - y(s, a))2

(12)

Indeed:

t+1 = t + t [y(s, a) - Q(s, a, t)] es,a =

{(12)}

=

t

-

t



Loss(y, Q(s,  Q

a,

t)) es,a

{(11)}

=

t

-

t



Loss(y, Q(s,  Q

a,

t))

 Q

(s, a, 

t)

=

{chain

rule}

=

t

-

t



Loss(y,

Q(s, 

a,

t))

The obtained result is evidently a gradient descent step formula to minimize MSE loss function with target (10):

t+1

=

t

-

t



Loss(y,

Q(s, 

a,

t))

(13)

It is important that dependence of y from  is ignored during gradient computation (otherwise

the chain rule application with y being dependent on  is incorrect). On each step of temporal dif-

ference algorithm new target y is constructed using current Q-function approximation, and a new

regression task with this target is set. For this fixed target one MSE optimization step is done ac-

cording to (13), and on the next step a new regression task is defined. Though during each step the

target is considered to represent some ground truth like it is in supervised learning, here it provides a direction of optimization and because of this reason is sometimes called a guess.

Notice that representation (13) is equivalent to standard TD update (9) with all theoretical results

remaining while the parametric family Q(s, a, ) is a table functions family. At the same time, (13)

can be formally applied to any parametric function family including neural networks. It must be

taken into account that this transition is not rigorous and all theoretical guarantees provided by

theorem 7 are lost at this moment.
Further on we assume that optimal Q-function is approximated with neural network Q(s, a) with parameters . Note that for discrete action space case this network may take only s as input and output |A| numbers representing Q(s, a1) . . . Q(s, a|A|), which allows to find an optimal action in a given state s with a single forward pass through the net. Therefore target y for given

transition (s, a, r , s , done) can be computed with one forward pass and optimization step can be performed in one more forward7 and one backward pass.

Small issue with this straightforward approach is that, of course, it is impractical to train neural networks with batches of size 1. In [14] it is proposed to use experience replay to store all collected

transitions (s, a, r , s , done) as data samples and on each iteration sample a batch of standard for

neural networks training size. As usual, the loss function is assumed to be an average of losses for

each transition from the batch. This utilization of previously experienced transitions is legit because TD algorithm is known to be an off-policy algorithm, which means it can work with arbitrary transi-

tions gathered by any agent's interaction experience. One more important benefit from experience replay is sample decorrelation as consecutive transitions from interaction are often similar to each

other since agent usually locates at the particular part of MDP.

Though empirical results of described algorithm turned out to be promising, the behaviour of

Q values indicated the instability of learning process. Reconstruction of target after each optimization step led to so-called compound error when approximation error propagated from the closeto-terminal states to the starting in avalanche manner and could lead to guess being 106 and more times bigger than the true Q value. To address this problem, [14] introduced a kludge known as target network, which basic idea is to solve fixed regression problem for K > 1 steps, i. .e. recompute

target every K-th step instead of each.

7in implementations it is possible to combine s and s in one batch and perform these two forward passes «at once».

13

To avoid target recomputation for the whole experience replay, the copy of neural network Q is stored, called the target network. Its architecture is the same while weights - are a copy of Q from the moment of last target recomputation8 and its main purpose is to generate targets y for given current batch.
Combining all things together and adding -greedy strategy to facilitate exploration, we obtain classic DQN algorithm:

Algorithm 2: Deep Q-learning (DQN)

Hyperparameters: B -- batch size, K -- target network update frequency, (t)  (0, 1] -- greedy exploration parameter, Q -- neural network, SGD optimizer. Initialize weights of  arbitrary Initialize -   On each interaction step:
1. select a randomly with probability (t), else a = argmax Q(s, a)
a
2. observe transition (s, a, r , s , done)
3. add observed transition to experience replay
4. sample batch of size B from experience replay
5. for each transition T from the batch compute target:
y(T ) = r(s ) +  max Q(s , a , -)
a

6. compute loss:

1 Loss =

(Q(s, a, ) - y(T ))2

B

T

7. make a step of gradient descent using  Loss

8. if t mod K = 0: -  

3.3. Double DQN

Although target network successfully prevented Q from unbounded growth and empirically stabilized learning process, the values of Q on many domains were evident to tend to overestimation. The problem is presumed to reside in max operation in target construction formula (10):

y = r(s ) +  max Q(s , a , -)
a
During this estimation max shifts Q-value estimation towards either to those actions that led to high reward due to luck or to the actions with overestimating approximation error.
The solution proposed in [25] is based on idea of separating action selection and action evaluation to carry out each of these operations using its own approximation of Q:

max Q(s , a , -) = Q(s , argmax Q(s , a , -), -) 

a

a

 Q(s , argmax Q(s , a , 1-), 2-)
a

The simplest, but expensive, implementation of this idea is to run two independent DQN («Twin DQN») algorithms and use the twin network to evaluate actions:

y1 = r(s ) + Q1(s , argmax Q2(s , a , 2-), 1-)
a
8alternative, but more computationally expensive option, is to update target network weights on each step using exponential smoothing

14

y2 = r(s ) + Q2(s , argmax Q1(s , a , 1-), 2-)
a
Intuitively, each Q-function here may prefer lucky or overestimated actions, but the other Q-function judges them according to its own luck and approximation error, which may be as underestimating as overestimating. Ideally these two DQNs should not share interaction experience to achieve that, which makes such algorithm twice as expensive both in terms of computational cost and sample efficiency.
Double DQN [25] is more compromised option which suggests to use current weights of network  for action selection and target network weights - for action evaluation, assuming that when the target network update frequency K is big enough these two networks are sufficiently different:
y = r(s ) + Q(s , argmax Q(s , a , ), -)
a
3.4. Dueling DQN
Another issue with DQN algorithm 2 emerges when a huge part of considered MDP consists of states of low optimal value V (s), which is an often case. The problem is that when the agent visits unpromising state instead of lowering its value V (s) it remembers only low pay-off for performing some action a in it by updating Q(s, a). This leads to regular returns to this state during future interactions until all actions prove to be unpromising and all Q(s, a) are updated. The problem gets worse when the cardinality of action space is high or there are many similar actions in action space.
One benefit of deep reinforcement learning is that we are able to facilitate generalization across actions by specifying the architecture of neural network. To do so, we need to encourage the learning of V (s) from updates of Q(s, a). The idea of dueling architecture [27] is to incorporate approximation of V (s) explicitly in computational graph. For that purpose we need the definition of advantage function:

Definition 8. For given MDP and policy  the advantage function under policy  is defined as

A(s, a) := Q(s, a) - V (s)

(14)

Advantage function is evidently interconnected with Q-function and value function and actually
shows the relative advantage of selecting action a comparing to average performance of the policy. If for some state A(s, a) > 0, then modifying  to select a more often in this particular state will lead to better policy as its average return will become bigger than initial V (s). This follows from the following property of arbitrary advantage function:

Ea(a|s)A(s, a) = Ea(a|s) [Q(s, a) - V (s)] =

= Ea(a|s)Q(s, a) - V (s) =

(15)

{using (4)} = V (s) - V (s) = 0

Definition of optimal advantage function A(s, a) is analogous and allows us to reformulate Q(s, a) in terms of V (s) and A(s, a):

Q(s, a) = V (s) + A(s, a)

(16)

Straightforward utilization of this decomposition is following: after several feature extracting lay-
ers the network is joined with two heads, one outputting single scalar V (s) and one outputting |A| numbers A(s, a) like it was done in DQN for Q-function. After that this scalar value estimation is added to all components of A(s, a) in order to obtain Q(s, a) according to (16). The problem with this naive approach is that due to (15) advantage function can not be arbitrary and must hold
the property (15) for Q(s, a) to be identifiable. This restriction (15) on advantage function can be simplified for the case when optimal policy is

15

induced by optimal Q-function:

0 = Ea(a|s)Q(s, a) - V (s) = = Q(s, argmax Q(s, a)) - V (s) =
a
= max Q(s, a) - V (s) =
a
= max [Q(s, a) - V (s)] =
a
= max A(s, a)
a
This condition can be easily satisfied in computational graph by subtracting max A(s, a) from
a
advantage head. This will be equivalent to the following formula of dueling DQN:

Q(s, a) = V (s) + A(s, a) - max A(s, a)

(17)

a

The interesting nuance of this improvement is that after evaluation on Atari-57 authors discovered that substituting max operation in (17) with averaging across actions led to better results (while usage of unidentifiable formula (16) led to poor performance). Although gradients can be backpropagated through both operation and formula (17) seems theoretically justified, in practical implementations averaging instead of maximum is widespread.

3.5. Noisy DQN
By default, DQN algorithm does not concern the exploration problem and is always augmented with -greedy strategy to force agent to discover new states. This baseline exploration strategy suffers from being extremely hyperparameter-sensitive as early decrease of (t) to close to zero values may lead to stucking in local optima, when agent is unable to explore new options due to imperfect Q, while high values of (t) force agent to behave randomly for excessive amount of episodes, which slows down learning. In other words, -greedy strategy transfers responsibility to solve exploration-exploitation trade-off on engineer.
The key reason why -greedy exploration strategy is relatively primitive is that exploration priority does not depend on current state. Intuitively, the choice whether to exploit knowledge by selecting approximately optimal action or to explore MDP by selecting some other depends on how explored the current state s is. Discovering a new part of state space after any amount of interaction probably indicates that random actions are good to try there, while close-to-initial states will probably be sufficiently explored after several first episodes.
In -greedy strategy agent selects action using deterministic Q(s, a, ) and only afterwards injects state-independent noise in a form of (t) probability of choosing random action. Noisy networks [4] were proposed as a simple extension of DQN to provide state-dependent and parameterfree exploration by injecting noise of trainable volume to all (or most9) nodes in computational graph.
Let a linear layer with m inputs and n outputs in q-network perform the following computation:
y(x) = W x + b
where x  Rm is input, W  Rn×m -- weights matrix, b  Rm -- bias. In noisy layers it is proposed to substitute deterministic parameters with samples from N (µ, ) where µ,  are trained with gradient descent10. On the forward pass through the noisy layer we sample W  N (0, Inm×nm), b  N (0, In×n) and then compute
W = (µW + W W ) b = (µb + b b)
y(x) = W x + b
where denotes element-wise multiplication, µW , W  Rn×m, µb, b  Rn -- trainable parameters of the layer. Note that the number of parameters for such layers is doubled comparing to ordinary layers.
9usually it is not injected in very first layers responsible for feature extraction like convolutional layers in networks for images as input.
10using standard reparametrization trick
16

As the output of q-network now becomes a random variable, loss value becomes a random variable too. Like in similar models for supervised learning, on each step an expectation of loss function over noise is minimized:
E Loss(, )  min

The gradient in this setting can be estimated using Monte-Carlo:
E Loss(, ) = E Loss(, )   Loss(, )   N (0, I)
It can be seen that amount of noise actually inflicting output of network may vary for different inputs, i. e. for different states. There are no guarantees that this amount will reduce as the interaction proceeds; the behaviour of average magnitude of noise injected in the network with time is reported to be extremely sensitive to initialization of W , b and vary from MDP to MDP.
One technical issue with noisy layers is that on each pass an excessive amount (by the number of network parameters) of noise samples is required. This may substantially reduce computational efficiency of forward pass through the network. For optimization purposes it is proposed to obtain noise for weights matrices in the following way: sample just n + m noise samples 1W  N (0, Im×m), 2W  N (0, In×n) and acquire matrix noise in a factorized form:
W = f (1W )f (2W )T
where f is a scaling function, e. g. f (x) = sign(x) |x|. The benefit of this procedure is that it requires m + n samples instead of mn, but sacrifices the interlayer independence of noise.

3.6. Prioritized experience replay

In DQN each batch of transitions is sampled from experience replay using uniform distribution,
treating collected data as equally prioritized. In such scheme states for each update come from the
same distribution as they come from interaction experience (except that they become decorellated),
which agrees with TD algorithm as the basement of DQN.
Intuitively observed transitions vary in their importance. At the beginning of training most guesses tend to be more or less random as they rely on arbitrarily initialized Q and the only source of trusted information are transitions with non-zero received reward, especially near terminal states where V(s ) is known to be equal to 0. In the midway of training, most of experience replay is filled with the memory of interaction within well-learned part of MDP while the most crucial information is
contained in transitions where agent explored new promising areas and gained novel reward yet to
be propagated through Bellman equation. All these significant transitions are drowned in collected
data and rarely appear in sampled batches.
The central idea of prioritized experience replay [18] is that priority of some transition T = (s, a, r , s , done) is proportional to temporal difference:

(T ) := y(T ) - Q(s, a, ) = Loss(y(T ), Q(s, a, ))

(18)

Using these priorities as proxy of transition importances, sampling from experience replay proceeds using following probabilities:
P(T )  (T )
where hyperparameter   R+ controls the degree to which the sampling weights are sparsified: the case  = 0 corresponds to uniform sampling distribution while  = + is equivalent to greedy sampling of transitions with highest priority.
The problem with (18) claim is that each transition's priority changes after each network update. As it is impractical to recalculate loss for the whole data after each step, some simplifications must be put up with. The straightforward option is to update priority only for sampled transitions in the current batch. New transitions can be added to experience replay with highest priority, i. e. max (T )11.
T
Second debatable issue of prioritized replay is that it actually substitutes loss function of DQN updates, which assumed uniform sampling of visited states to ensure they come from state visitation distribution:
ET Uniform Loss(T )  min

11which can be computed online with O(1) complexity
17

While it is not clear what distribution is better to sample from to ensure exploration restrictions of theorem 7, prioritized experienced replay changes this distribution in uncontrollable way. Despite its fruitfulness at the beginning and midway of training process, this distribution shift may destabilize learning close to the end and make algorithm stuck with locally optimal policy. Since formally this issue is about estimating an expectation over one probability with preference to sample from another one, the standard technique called importance sampling can be used as countermeasure:

M1

ET Uniform Loss(T ) =

M Loss(Ti) =

i=0

M

1

= i=0 P(Ti) M P(Ti) Loss(Ti) =

1 = ET P(T ) M P(T ) Loss(T )

where M is a number of transitions stored in experience replay memory. Importance sampling implies that we can avoid distribution shift that introduces undesired bias by making smaller gradient updates for significant transitions which now appear in the batches with higher frequency. The price for bias elimination is that importance sampling weights lower prioritization effect by slowing down learning of highlighted new information.
This duality resembles trade-off between bias and variance, but important moment here is that distribution shift does not cause any seeming issues at the beginning of training when agent behaves close to random and do not produce valid state visitation distribution anyway. The idea proposed in [18] based on this intuition is to anneal the importance sampling weights so they correct bias properly only towards the end of training procedure.

LossprioritizedER = ET P(T )

1

(t)

Loss(T )

BP(T )

where (t)  [0, 1] and approaches 112 as more interaction steps are executed. If (t) is set to 0, no bias correction is held, while (t) = 1 corresponds to unbiased loss function, i. e. equivalent to sampling from uniform distribution.
The most significant and obvious drawback of prioritized experience replay approach is that it
introduces additional hyperparameters. Although  represents one number, algorithm's behaviour may turn out to be sensitive to its choosing, and (t) must be designed by engineer as some scheduled motion from something near 0 to 1, and its well-turned selection may require inaccessible
knowledge about how many steps it will take for algorithm to «warm up».

3.7. Multi-step DQN
One more widespread modification of Q-learning in RL community is substituting one-step approximation present in Bellman optimality equation (6) with N -step:

Proposition 8. (N -step Bellman optimality equation)

N

Q(s0, a0) = ET |s0,a0

 t-1 r (st )

+

N

max
aN

Q(sN ,

aN )

(19)

t=1

Indeed, definition of Q(s, a) consists of average return and can be viewed as making T max steps from state s0 after selecting action a0, while vanilla Bellman optimality equation represents Q(s, a) as reward from one next step in the environment and estimation of the rest of trajectory reward recursively. N -step Bellman equation (19) generalizes these two opposites.
All the same reasoning as for DQN can be applied to N -step Bellman equation to obtain N -step DQN algorithm, which only modification appears in target computation:

N
y(s0, a0) = t-1r(st) + N max Q(sN , aN , )
aN t=1 12often it is initialized by a constant close to 0 and is linearly increased until it reaches 1
18

(20)

To perform this computation, we are required to obtain for given state s and a not only one next step, but N steps. To do so, instead of transitions N -step roll-outs are stored, which can be done by precomputing following tuples:

T=

N

s, a,

n-1r(n), s(N), done

n=1

where r(n) is the reward received in n steps after visitation of considered state s, s(N) is state visited in N steps, and done is a flag whether the episode ended during N -step roll-out13. All other aspects of algorithm remain the same in practical implementations, and the case N = 1 corresponds to standard DQN.
The goal of using N > 1 is to accelerate propagation of reward from terminal states backwards through visited states to s0 as less update steps will be required to take into account freshly observed reward and optimize behaviour at the beginning of episodes. The price is that formula (20)
includes an important trick: to calculate such target, for second (and following) step action a must be sampled from  for Bellman equation (19) to remain true. In other words, application of N -step Q-learning is theoretically improper when behaviour policy differs from . Note that we do not face this problem in the case N = 1 in which we are required to sample only from transition probability p(s | s, a) for given state-action pair s, a.
Even considering   argmax Q(s, a, ), where Q is our current approximation of ,
a
makes N -step DQN an on-policy algorithm when for every state-action pair s, a it is preferable to sample target using the closest approximation of  available. This questions usage of experience replay or at the very least encourages to limit its capacity to store only M max newest transitions with M max being relatively not very big.
To see the negative effect of N -step DQN, consider the following toy example. Suppose agent makes a mistake on the second step after s and ends episode with huge negative reward. Then in the case N > 2 each time the roll-out starting with this s is sampled in the batch, the value of Q(s, a, ) will be updated with this received negative reward even if Q(s , ·, ) already learned not to repeat this mistake again.
Yet empirical results in many domains demonstrate that raising N from 1 to 2-3 may result in substantial acceleration of training and positively affect the final performance. On the contrary, the
theoretical groundlessness of this approach explains its negative effects when N is set too big.

13all N -step roll-outs must be considered including those terminated at k-th step for k < N .
19

4. Distributional approach for value-based methods
4.1. Theoretical foundations
The setting of RL task inherently carries internal stochasticity of which agent has no substantial control. Sometimes intelligent behaviour implies taking risks with severe chance of low episode return. All this information resides in the distribution of return R (1) as random variable.
While value-based methods aim at learning expectation of this random variable as it is the quantity we actually care about, in distributional approach [1] it is proposed to learn the whole distribution of returns. It further extends the information gathered by algorithm about MDP towards model-based case in which the whole MDP is imitated by learning both reward function r(s) and transitions T, but still restricts itself only to reward and doesn't intend to learn world model.
In this section we discuss some theoretical extensions of temporal difference ideas in the case when expectations on both sides of Bellman equation (5) and Bellman optimality equation (6) are taken away.
The central object of study in Q-learning was Q-function, which for given state and action returns the expectation of reward. To rewrite Bellman equation not in terms of expectations, but in terms of the whole distributions, we require a corresponding notation.

Definition 9. For given MDP and policy  the value distribution of policy  is a random variable defined as
Z(s, a) := trt+1 s0 = s, a0 = a
t=0

Note that Z just represents a random variable which is taken expectation of in definition of

Q-function:

Q(s, a) = ET Z(s, a)

Using this definition of value distribution, Bellman equation can be rewritten to extend the recur-

sive connection between adjacent states from expectations of returns to the whole distributions of

returns:

Proposition 9. (Distributional Bellman Equation) [1]

Z(s, a) c.=d.f. r(s ) + Z(s , a ) s  p(s | s, a), a  (a | s )

(21)

Here we used some auxiliary notation: by c.=d.f. we mean that cumulative distribution functions of two random variables to the right and left are equal almost everywhere. Such equations are called recursive distributional equations and are well-known in theoretical probability theory14. By using | we describe a sampling procedure for the random variable to the right side of equation: for given s, a next state s is sampled from transition probability, then a is sampled from given policy, then random variable Z(s , a ) is sampled to calculate a resulting sample r(s ) + Z(s , a ).
While the space of Q-functions Q(s, a)  S × A  R is finite, the space of value distributions is a space of mappings from state-action pair to continuous distributions:
Z(s, a)  S × A  P(R)
and it is important to notice that even in the table-case when state and action spaces are finite, the space of value distributions is essentially infinite. Crucial moment for us will be that convergence properties now depend on chosen metric15.
The choice of metric in S × A  P(R) represents the same issue as in the space of continuous random variables P(R): if we choose a metric in the latter, we can construct one in the former:

14to get familiar with this notion, consider this basic example:

X1 c.=d.f . X2 + X3

2

2

where X1, X2, X3 are random variables coming from N (0, 2). 15in finite spaces it is true that convergence in one metric guarantees convergence to the same point for any other metric.

20

Proposition 10. If d(X, Y ) is a metric in the space P(R), then

d(Z1, Z2) := sup d(Z1(s, a), Z2(s, a))
sS,aA

is a metric in the space S × A  P(R).

The particularly interesting for us example of metric in P(R) will be Wasserstein metric, which concerns only random variables with bounded moments, so we will additionally assume that for all

state-action pairs s, a

EZ(s, a)p  +

are finite for p  1.

Proposition 11. For 1  p  + for two random variables X, Y on continuous domain with p-

th bounded moments and cumulative distribution functions FX and FY correspondingly a Wasser-

stein distance

1

1

p

Wp(X, Y ) :=  FX-1() - FY-1() p d

0

W(X, Y ) := sup FX-1() - FY-1()
[0,1]

is a metric in the space of random variables with p-th bounded moments.

Thus we can conclude from proposition 10 that maximal form of Wasserstein metric

W p(Z1, Z2) = sup Wp(Z1(s, a), Z2(s, a))

(22)

sS,aA

is a metric in the space of value distributions. We now concern convergence properties of point iteration method to solve (21) in order to obtain
Z for given policy , i. e. solve the task of policy evaluation. For that purpose we initialize Z0(s, a) arbitrarily16 and perform the following updates for all state-action pairs s, a:

Zt+1(s, a) c.:d=.f. r(s ) + Zt(s , a )

(23)

Here we assume that we are able to compute the distribution of random variable on the right side knowing , all transition probabilities T, the distribution of Zt and reward function. The question whether the sequence {Zt} converges to Z can be given a detailed answer:

Proposition 12. [1] Denote by B the following operator (S × A  P(R))  (S × A  P(R)),

updating Zt as in (23):

Zt+1 = BZt

for all state-action pairs s, a. Then B is a contraction mapping in W p (22) for 1  p  +, i.e. for any two value distribu-
tions Z1, Z2 W p(BZ1, BZ2)  W p(Z1, Z2)

Hence there is a unique fixed point of system of equations (21) and the point iteration method converges to it.

One more curious theoretical result is that B is in general not a contraction mapping for such distances as Kullback-Leibler divergence, Total Variation distance and Kolmogorov distance17. It shows

16here we consider value distributions from theoretical point of view, assuming that we are able to explicitly store a table of
|S||A| continuous distributions without any approximations. 17one more metric for which the contraction property was shown is Cramer metric:

1



2

l2(X, Y ) =  (FX () - FY ())2 d

R
where FX , FY are c.d.f. of random variables X, Y correspondingly.

21

that metric selection indeed influences convergence rate.
Similar to traditional value functions, we can define optimal value distribution Z(s, a). Substituting18 (s) = argmax ET Z(s, a) into (21), we obtain distributional Bellman optimality
a
equation:

Proposition 13. (Distributional Bellman optimality equation)
Z(s, a) c.=d.f. r(s ) + Z(s , argmax ET Z(s , a )) s  p(s | s, a) (24)
a
Now we concern the same question whether the point iteration method of solving (24) leads to solution Z and whether it is a contraction mapping for some metric. The answer turns out to be negative.

Proposition 14. [1] Point iteration for solving (24) may diverge.
Level of impact of this result is not completely clear. Point iteration for (24) preserves means of distributions, i. e. it will eventually converge to Q(s, a) with all theoretical guarantees from classical Q-learning. The reason behind divergence theorems hides in the rest of distributions like other moments and situations when equivalent (in terms of average return) actions may lead to different higher moments.

4.2. Categorical DQN

There are obvious obstacles for practical application of distributional Q-learning following from

complication of working with arbitrary continuous distributions. Usually we are restricted to approx-

imations inside some family of parametric distributions, so we have to perform a projection step on

each iteration.

Second matter in combining distributional Q-learning with deep neural networks is to take into

account that only samples from p(s | s, a) are available for each update. To provide a distributional analog of temporal difference algorithm 9, some analog of exponential smoothing for distributional

setting must be proposed.

Categorical DQN [1] (also referred as c51) provides straightforward design of practical distribu-

tional algorithm. While DQN was a resemblance of temporal difference algorithm, Categorical DQN

attempts to follow the logic of DQN.

The concept is as following. The neural network with parameters  in this setting takes as in-
put s  S and for each action a outputs parameters (s, a) of distributions of random variable Z(s, a). As in DQN, experience replay can be used to collect observed transitions and sample a batch for each update step. For each transition T = (s, a, r , s , done) in the batch a guess is
computed:

y(T ) c.:d=.f. r + (1 - done)Z s , argmax EZ(s , a )

(25)

a

Note that expectation of Z(s , a ) is computed explicitly using the form of chosen parametric family of distributions and outputted parameters (s , a ), as is the distribution of random variable r + (1 - done)Z(s , a ). In other words, in this setting guess y(T ) is also a continuous random variable, distribution of which can be constructed only approximately. As both target and model

output are distributions, it is reasonable to design loss function in a form of some divergence D between y(T ) and Z(s, a):

Loss() = ET D y(T ) Z(s, a)

(26)

t+1

=

t

-

 

Loss(t) 

18to perform this step validly, a clarification concerning argmax operator definition must be given. The choice of action a returned by this operator in the cases when several actions lead to the same maximal average returns must not depend on
Z, as this choice affects higher moments of resulted distribution. To overcome this issue, for example, in the case of finite action space all actions can be enumerated and the optimal action with the lowest index is returned by operator.

22

The particular choice of this divergence must be made with concern that y(T ) is a «sample» from a full one-step approximation of Z which includes transition probabilities:

yfull(s,

a)

c.d.f .
:=

p(s | s, a)y(s, a, r(s ), s , done(s ))

(27)

s S

This form is precisely the right side of distributional Bellman optimality equation as we just incor-
porated intermediate sampling of s into the value of random variable. In other words, if transition probabilities T were known, the update could be made using distribution of yfull as a target.

Lossfull() = Es,aD(yfull(s, a) Z(s, a))
This motivates to choose KL(y(T ) Z(s, a)) (specifically with this order of arguments) as D to exploit the following property (we denote by pX a p.d.f. pf random variable X):

ET KL(yfull(s, a) Z(s, a)) =  ET -pyfull(s,a)() log pZ(s,a))()d + const() =
R
{using (27)} = ET Es p(s |s,a) - py(T )() log pZ(s,a))()d =
R
{taking expectation out} = ET Es p(s |s,a) -py(T )() log pZ(s,a))()d =
R
= ET Es p(s |s,a) KL y(T ) Z(s, a)
This property basically states that gradient of loss function (26) with KL as D is an unbiased (Monte-Carlo) estimation of gradient of KL-divergence for «full» distribution (27), which resembles the employment of exponential smoothing in temporal difference learning. For many other diver-
gences, including Wasserstein metric, same statement is not true, so their utilization in described
online setting will lead to biased gradients and all theory-grounded intuition that algorithm moves
in the right direction becomes distinctively lost. Moreover, KL-divergence is known to be one of the easiest divergences to work with due to its nice smoothness properties and wide prevalence in many
deep learning pipelines.
Described above motivation to choose KL-divergence as an actual objective for minimization is contradictory. Theoretical analysis of distributional Q-learning, specifically theorem 12, though concerning policy evaluation other than optimal Z search, explicitly hints that the process converges exponentially fast for Wasserstein metric, while even for precisely made updates in terms of KLdivergence we are not guaranteed to get any closer to true solution.
More «practical» defect of KL-divergence is that it demands two comparable distributions to share the same domain. This means that by choosing KL-divergence we pledge to guarantee that y(T ) and Z(s, a) in (26) have coinciding support. This emerging restriction seems limiting even beforehand as for episodic MDP value distribution in terminal states is obviously degenerated (their
support consists of one point r(s) which is given all probability mass) which means that our value distribution approximation is basically ensured to never be precise.
In Categorical DQN, as follows from the name, the family of distributions is chosen to be categorical on the fixed support {z0, z1 . . . zA-1} where A is number of atoms. As no prior information about MDP is given, the basic choice of this support is uniform grid from some Vmin  R to V max  R:
i zi = Vmin + A - 1 (Vmax - Vmin), i  0, 1, . . . A - 1
These bounds, though, must be chosen carefully as they implicitly assume

Vmin  Z(s, a)  Vmax

and if these inequalities are not tight, the approximation will obviously become poor.

Therefore the neural network outputs A numbers, summing into 1, to represent arbitrary distri-

bution on this support:

i(s, a, ) := P(Z(s, a) = zi)

Within this family of distributions, computation of expectation, greedy action selection and KLdivergence is trivial. One problem hides in target formula (25): while we can compute distribution y(T ), its support may in general differ from {z0 . . . zA-1}. To avoid the issue of disjoint supports,

23

a projection step must be done to find the closest to target distribution within the chosen family19. Therefore the resulting target used in the loss function is
y(T ) c.:d=.f. C r + (1 - done)Z s , argmax EZ(s , a )
a
where C is projection operator. The resulting practical algorithm, named c51 after categorical distributions with A = 51 atoms,
inherits ideas of experience replay, -greedy exploration and target network from DQN. Empirically, though, usage of target network remains an open question as the chosen family of distributions restricts value approximation from unbounded growth by «clipping» predictions at zA-1 and z0, yet it is still considered slightly improving performance.

Algorithm 3: Categorical DQN (c51)

Hyperparameters: B -- batch size, Vmax, Vmin, A -- parameters of support, K -- target network update frequency, (t)  (0, 1] -- greedy exploration parameter,  -- neural net-
work, SGD optimizer.

Initialize weights  of neural net  arbitrary

Initialize -  

Precompute

support

grid

zi

=

Vmin

+

i A-1

(Vmax

-

Vmin)

On each interaction step:

1. select a randomly with probability (t), else a = argmax
a
2. observe transition (s, a, r , s , done)

i zii(s, a, )

3. add observed transition to experience replay

4. sample batch of size B from experience replay

5. for each transition T from the batch compute target:

P(y(T ) = r + zi) = i s , argmax zii(s , a , -), -

a

i

6. project y(T ) on support {z0, z1 . . . zA-1}

7. compute loss:

1 Loss =

KL(y(T ) Z(s, a, ))

B

T

8. make a step of gradient descent using  Loss

9. if t mod K = 0: -  

4.3. Quantile Regression DQN (QR-DQN)
Categorical DQN discovered a gap between theory and practice as KL-divergence, used in practical algorithm, is theoretically unjustified. Theorem 12 hints that the true divergence we should care about is actually Wasserstein metric, but it remained unclear how it could be optimized using only samples from transition probabilities T.
In [3] it was discovered that selecting another family of distributions to approximate Z(s, a) will reduce Wasserstein minimization task to the search for quantiles of specific distributions. The
19to project a categorical distribution with support {v0, v1 . . . vA-1} on categorical distributions with support {z0, z1 . . . zA-1} one can just find for each vi the closest two atoms zj  vi  zj+1 and split all probability mass for vi between zj and zj+1 proportional to closeness. If vi < z0, then all its probability mass is given to z0, same with upper bound.
24

latter can be done in online setting using quantile regression technique. This led to alternative distributional Q-learning algorithm named Quantile Regression DQN (QR-DQN).
The basic idea is to «swap» fixed support and learned probabilities of Categorical DQN. We will
now consider the family with fixed probabilities for A-atomed categorical distribution with arbitrary support {0(s, a, ), 1(s, a, ), . . . , A -1(s, a, )}. Again, we will assume all probabilities to be equal given the absence of any prior knowledge; namely, our distribution family is now

Z(s, a)  Uniform 0(s, a, ), . . . , A -1(s, a, )

In this setting neural network outputs A arbitrary real numbers that represent the support of uniform categorical distribution20, where A is the number of atoms and the only hyperparameter to select.
For table-case setting, on each step of point iteration we desire to update the cell for given state-
action pair s, a with full distribution of random variable to the right side of (24). If we are limited to store only A atoms of the support, the true distribution must be projected on the space of Aatomed categorical distributions. Consider now this task of projecting some given random variable
with c.d.f. F () in terms of Wasserstein distance. Specifically, we will be interested in minimizing W1-distance for p = 1 as the theorem 12 states the contraction property for all 1  p  + and we are free to choose any:

1

0

F

-1()

-

U -1
z0 ,z1 ...zA-1

()

d  min
z0 ,z1 ...zA-1

(28)

where Uz0,z1...zA-1 is c.d.f. for uniform categorical distribution on given support. Its inverse, also known as quantile function, has a following simple form:



z0



Uz-01,z1...zA-1 ()

=

z1 ...







zA-1

0





<

1 A

1 A





<

2 A

A-1 A





<

1

Substituting this into (28)

A-1 i=0

i+1

A i

F -1() - zi

d  min
z0 ,z1 ...zA-1

A

splits the optimization of Wasserstein into A independent tasks that can be solved separately:

i+1

A F -1() - zi d  min

i

zi

A

(29)

Proposition 15. [3] Let's denote

i :=

i A

+

i+1 A

2

Then every solution for (29) satisfies F (zi) = i, i. e. it is i-th quantile of c. d. f. F .

The result 15 states that we require only A specific quantiles of random variable to the right side of Bellman equation21. Hence the last thing to do to design a practical algorithm is to develop a pro-
cedure of unbiased estimation of quantiles for the random variable on the right side of distribution
Bellman optimality equation (24).
20Note that target distribution is now guaranteed to remain within this distribution family as multiplying on  just shrinks the support and adding r just shifts it. We assume that if some atoms of the support coincide, the distribution is still A-atomed categorical; for example, for degenerated distribution (like in the case of terminal states) 0(s, a, ) = 1(s, a, ) = · · · = A -1(s, a, ). This shows that projection step heuristic is not needed for this particular choice of distribution family.
21It can be proved that for table-case policy evaluation algorithm which stores in each cell not expectations of reward (as in Q-learning) but A quantiles updated according to distributional Bellman equation (21) using theorem 15 converges to quantiles of Z(s, a) in Wasserstein metric for 1  p  + and its update operator is a contraction mapping in W.
25

Quantile regression is the standard technique to estimate the quantiles of empirical distribution
(i. .e. distribution that is represented by finite amount of i. i. d. samples from it). Recall from machine
learning that the constant solution optimizing l1-loss is median, i. .e. 1 -th quantile. This fact can be
2
generalized to arbitrary quantiles:

Proposition 16. (Quantile Regression) [11] Let's define loss as

 (c - X)

cX

Loss(c, X) =

(1 -  )(X - c) c < X

Then solution for

EX Loss(c, X)  min

(30)

cR

is  -th quantile of distribution of X.

As usual in the case of neural networks, it is impractical to optimize (30) until convergence on
each iteration for each of A desired quantiles i. Instead just one step of gradient optimization is made and the outputs of neural network i(s, a, ), which play the role of c in formula (30), are moved towards the quantile estimation via backpropagation. In other words, (30) sets a loss function
for network outputs; the losses for different quantiles are summed up. The resulting loss is

A-1

LossQR(s, a, ) =

Es p(s |s,a)Eyy(T )  - I[i(s, a, ) < y] i(s, a, ) - y (31)

i=0

where I denotes an indicator function. The expectation over y  y(T ) for given transition can be computed in closed form: indeed, y(T ) is also an A-atomed categorical distribution with support {r + 0(s , a ), . . . , r + A -1(s , a )}, where

a

= argmax EZ(s , a , ) = argmax 1

a

a

A

i

i(s , a , )

and expectation over transition probabilities, as always, is estimated using Monte-Carlo by sampling transitions from experience replay.

Algorithm 4: Quantile Regression DQN (QR-DQN)

Hyperparameters: B -- batch size, A -- number of atoms, K -- target network update frequency, (t)  (0, 1] -- greedy exploration parameter,  -- neural network, SGD optimizer.

Initialize weights  of neural net  arbitrary

Initialize -  

Precompute mid-quantiles i =

i A

+

i+1 A

2

On each interaction step:

1.

select a randomly with probability (t), else a

=

argmax
a

1 A

i i(s, a, )

2. observe transition (s, a, r , s , done)

3. add observed transition to experience replay

4. sample batch of size B from experience replay

5. for each transition T from the batch compute the support of target distribution:

y(T )j = r + j

1

s , argmax

a

A

i(s , a , -), -
i

26

6. compute loss:

1 Loss =
BA

i - I[i(s, a, ) < y(T )j] i(s, a, ) - y(T )j

Tij

7. make a step of gradient descent using  Loss

8. if t mod K = 0: -  

4.4. Rainbow DQN

Success of Deep Q-learning encouraged a full-scale research of value-based deep reinforcement learning by studying various drawbacks of DQN and developing auxiliary extensions. In many articles some extensions from previous research were already considered and embedded in compared algorithms during empirical studies.
In Rainbow DQN [7], seven Q-learning-based ideas are united in one procedure with ablation studies held whether all these incorporated extensions are essentially necessary for resulted RL algorithm:
· DQN (sec. 3.2)
· Double DQN (sec. 3.3)
· Dueling DQN (sec. 3.4)
· Noisy DQN (sec. 3.5)
· Prioritized Experience Replay (sec. 3.6)
· Multi-step DQN (sec. 3.7)
· Categorical22 DQN (sec. 4.2)
There is little ambiguity on how these ideas can be combined; we will discuss several nonstraightforward circumstances and provide the full algorithm description after.
To apply prioritized experience replay in distributional setting, the measure of transition importance must be provided. The main idea is inherited from ordinary DQN where priority is just loss for this transition:
(T ) := Loss(y(T ), Z(s, a, )) = KL(y(T ) Z(s, a, ))
To combine noisy networks with double DQN heuristic, it is proposed to resample noise on each forward pass through the network and through its copy for target computation. This decision implies that action selection, action evaluation and network utilization are independent and stochastic (for exploration cultivation) steps.
The one snagging combination here is categorical DQN and dueling DQN. To merge these ideas, we need to model advantage A(s, a, ) in distributional setting. In Rainbow this is done straightforwardly: the network has two heads, value stream v(s, ) outputting A real values and advantage stream a(s, a, ) outputting A × |A| real values. Then these streams are integrated using the same formula (17) with the only exception being softmax applied across atoms dimension to guarantee that output is categorical distribution:

i(s, a, )  exp

1 v(s, )i + a(s, a, )i - |A| a a(s, a, )i

(32)

Combining lack of intuition behind this integration formula with usage of mean instead of theoretically justified max makes this element of Rainbow the most questionable. During the ablation studies it was discovered that dueling architecture is the only component that can be removed without noticeable loss of performance. All other ingredients are believed to be crucial for resulting algorithm as they address different problems.
22Quantile Regression can be considered instead

27

Algorithm 5: Rainbow DQN

Hyperparameters: B -- batch size, Vmax, Vmin, A -- parameters of support, K -- target network update frequency, N -- multi-step size,  -- degree of prioritized experience replay, (t) -- importance sampling bias correction for prioritized experience replay,  -- neural
network, SGD optimizer.

Initialize weights  of neural net  arbitrary

Initialize -  

Precompute

support

grid

zi

=

Vmin

+

i A-1

(Vmax

-

Vmin)

On each interaction step:

1. select a = argmax i zii(s, a, , ),   N (0, I)
a
2. observe transition (s, a, r , s , done)

3. construct N -step transition T =

s, a,

N n=0

 n r (n+1) ,

s(N ) ,

done

and add it to

experience replay with priority maxT (T )

4. sample batch of size B from experience replay using probabilities P(T )  (T )

5. compute weights for the batch (where M is the size of experience replay memory)

1

(t)

w(T ) =

M P(T )

6. for each transition T = (s, a, r¯, s¯, done) from the batch compute target (detached from computational graph to prevent backpropagation):
1, 2  N (0, I)

P(y(T ) = r¯ + N zi) = i s¯, argmax zii(s¯, a¯, , 1), -, 2

a¯

i

7. project y(T ) on support {z0, z1 . . . zA-1}

8. update transition priorities

(T )  KL(y(T ) Z(s, a, , )),   N (0, I)

9. compute loss:

1

Loss =

w(T )(T )

B

T

10. make a step of gradient descent using  Loss

11. if t mod K = 0: -  

28

5. Policy Gradient algorithms

5.1. Policy Gradient theorem

Alternative approach to solving RL task is direct optimization of objective

J () = ET 

t-1rt  max


(33)

t=1

as a function of . Policy gradient methods provide a framework how to construct an efficient optimization procedure based on stochastic first-order optimization within RL setting.
We will assume that (a | s) is a stochastic policy parameterized with   . It turns out, that if  is differentiable by , then so is our goal (33). We now proceed to discuss the technique of derivative calculation which is based on employment of log-derivative trick:

Proposition 17. For arbitrary distribution (a) parameterized by :

(a) = (a) log (a)

(34)

In most general form, this trick allows us to derive the gradient of expectation of an arbitrary
function f (a, ) : A ×   R, differentiable by , with respect to some distribution (a), also parameterized by :

Ea(a)f (a, ) =  (a)f (a, )da =
A
=  [(a)f (a, )] da =
A
{product rule} = [(a)f (a, ) + (a)f (a, )] da =
A
= (a)f (a, )da + E(a)f (a, ) =
A
{log-derivative trick (34)} = (a) log (a)f (a, )da + E(a)f (a, ) =
A
= E(a) log (a)f (a, ) + E(a)f (a, )
This technique can be applied sequentially (to expectations over (a0 | s0), (a1 | s1) and so on) to obtain the gradient J ().

Proposition 18. (Policy Gradient Theorem) [24] For any MDP and differentiable policy  the gradient of objective (33) is

J () = ET  t log (at | st)Q(st, at)

(35)

t=0

For future references, we require another form of formula (35), which provides another point of view. For this purpose, let us define a discounted state visitation frequency:

Definition 10. For given MDP and given policy  its discounted state visitation frequency is defined by
d(s) := (1 - ) tP(st = s)
t=0
where st are taken from trajectories T sampled using given policy .
Discounted state visitation frequencies, if normalized, represent a marginalized probability for agent to land in a given state s23. It is rarely attempted to be learned, but it assists theoretical
23the t weighting in this definition is often introduced to incorporate the same reduction of contribution of later states in the whole gradient according to (35). Similar notation is sometimes used for state visitation frequency without discount.
29

study by allowing us to rewrite expectations over trajectories with separated intrinsic and extrinsic randomness of the decision making process:

J () = Esd(s)Ea(a|s) log (a | s)Q(s, a)

(36)

This form is equivalent to (35) as sampling a trajectory and going through all visited states with weights t induces the same distribution as defined in d(s).
Now, although we acquired an explicit form of objective's gradient, we are able to compute it only

approximately, using Monte-Carlo estimation for expectations via sampling one or several trajecto-

ries. Second form of gradient (36) reveals that it is possible to use roll-outs of trajectories without

waiting for episode ending, as the states for the roll-outs come from the same distribution as they would for complete episode trajectories24. The essential thing is that exactly the policy () must be used for sampling to obtain unbiased Monte-Carlo estimation (otherwise state visitation frequency

d(s) is different). These features are commonly underlined by notation E, which is a shorter form of Esd(s)Ea(a|s). When convenient, we will use it to reduce the gradient to a shorter form:

J () = E() log (a | s)Q(s, a)

(37)

Second important thing worth mentioning is that Q(s, a) is essentially present in the gradient. Remark that it is never available to the algorithm and must also be somehow estimated.

5.2. REINFORCE

REINFORCE [29] provides a straightforward approach to approximately calculate the gradient (35) in episodic case using Monte-Carlo estimation: N games are played and Q-function under policy  is approximated with corresponding return:

Q(s, a) = ET |s,aR(T )  R(T ), T   | s, a The resulting formula is therefore the following:

1 J ()  N

N T t=0

t log (at | st)

t -trt +1
t =t

(38)

This estimation is unbiased as both approximation of Q and approximation of expectation over trajectories are done using Monte-Carlo. Given that estimation of gradient is unbiased, stochastic

gradient ascent or more advanced stochastic optimization techniques are known to converge to local

optimum.

From theoretical point of view REINFORCE can be applied straightforwardly for any parametric

family (a | s) including neural networks. Yet the enormous time required for convergence and the problem of stucking in local optimums make this naive approach completely impractical.
The main source of problems is believed to be the high variance of gradient estimation (38), as the convergence rate of stochastic gradient descent directly depends on the variance of gradient

estimation. The standard technique of variance reduction is an introduction of baseline. The idea is to add

some term that will not affect the expectation, but may affect the variance. One such baseline can

be derived using following reasoning: for any distribution it is true that (a | s)da = 1. Taking
A
the gradient  from both sides, we obtain:

0 = (a | s)da =
A

{log-derivative trick (34)} = (a | s) log (a | s)da =
A
= E(a|s) log (a | s)

24in practice and in most policy gradients algorithms, sampling roll-outs never include t weights, which formally corresponds to estimating gradient using incorrect equation («approximation»):

 J ()  ET 

 log (at | st)Q(st, at)

t=0

which differs from the correct version (35) in ignoring t multiplier. On the one hand, it equalizes the contribution of dif-

ferent terms and agrees with intuition, but on the other hand such gradient estimation does not imply optimization of any

reasonable objective and breaks the idea of straightforward gradient ascent [15].

30

Multiplying this expression on some constant, we can scale this baseline:
E(a|s) const(a) log (a | s) = 0 Notice that the constant here must be independent of a, but may depend on s. Application of this technique to our case provides the following result25:

Proposition 19. For any arbitrary function b(s) : S  R, called baseline:
J () = ET  t log (at | st) (Q(st, at) - b(st))
t=0
Selection of the baseline is up to us as long as it does not depend on actions at. The intent is to choose it in a way that minimizes the variance.
It is believed that high variance of (38) originates from multiplication of Q(s, a), which may have arbitrary scale (e. .g. in a range [100, 200]) while  log (at | st) naturally has varying signs26. To reduce the variance, the baseline must be chosen so that absolute values of expression inside the expectation are shifted towards zero. Wherein the optimal baseline is provided by the following theorem:

Proposition 20. The solution for

VT 

t log (at | st) (Q(st, at) - b(st))  min
b(s)

t=0

is given by

b(s)

=

Ea(a|s)t  log (a | s) Ea(a|s)  log (a |

2 2

Q

(s,

a)

s)

2 2

(39)

As can be seen, optimal baseline calculation involves expectations which again can only be com-

puted (in most cases) using Monte-Carlo (both for numerator and denominator). For that purpose,

for every visited state s estimations of Q(s, a) are needed for all (or some) actions a, as otherwise estimation of baseline will coincide with estimation of Q(s, a) and collapse gradient to zero. Prac-

tical utilization of result (39) is to consider a constant baseline independent of s with similar optimal

form:

b

=

ET  t=0 t  log (at | st) ET  t=0  log (at |

2 2

Q

(st

,

at

)

st)

2 2

Utilization of some kind of baseline, not necessarily optimal, is known to significantly reduce the

variance of gradient estimation and is an essential part of any policy gradient method. The final step

to make this family of algorithms applicable when using deep neural networks is to reduce variance

of Q estimation by employing RL task structure like it was done in value-based methods.

5.3. Advantage Actor-Critic (A2C)

Suppose that in optimal baseline formula (39) it happens that

 log (a | s)

2 2

= const(a).

Though in reality this is actually not true, under this circumstance the optimal baseline formula

significantly reduces and unravels a close-to-optimal but simple form of baseline:

b(s) = tEa(a|s)Q(s, a) = tV (s)
Substituting this baseline into gradient formula (37) and recalling the definition of advantage function (14), the gradient can now be rewritten as follows:

J () = E() log (a | s)A(s, a)

(40)

This representation of gradient is used as the basement for most policy gradient algorithms as it offers lower variance while selecting the baseline expressed in terms of value functions which can be

25this result can be generalized by introducing different baselines for estimation of different components of J (). 26this follows, for example, from baseline derivation.

31

efficiently learned similar to how it was done in value-based methods. Such algorithms are usually named Actor-Critic as they consist of two neural networks: (a | s), representing a policy, called an actor, and V(s) with parameters , approximately estimating actor's performance, called a critic. Note that the choice of value function to learn can be arbitrary; it is possible to learn Q or A instead, as all of them are deeply interconnected. Value function V  is chosen as the simplest one since it depends only on state and thus is hoped to be easier to learn.
Having a critic V(s), Q-function can be approximated in a following way:
Q(s, a)  r + V (s )  r + V(s )
First approximation is done using Monte-Carlo, while second approximation inevitably introduces bias. Important thing to notice is that at this moment our gradient estimation stops being unbiased and all theoretical guarantees of converging are once again lost.
Advantage function therefore can be obtained according to the definition:

A(s, a) = Q(s, a) - V (s)  r + V(s ) - V(s)

(41)

Note that biased estimation of baseline doesn't make gradient estimation biased by itself, as baseline can be an arbitrary function of state. All bias introduction happens inside the approximation of Q. It is possible to use critic only for baseline, which allows complete avoidance of bias, but then the only way to estimate Q is via playing several games and using corresponding returns, which suffers from higher variance and low sample efficiency.
The logic behind training procedure for the critic is taken from value-based methods: for given
policy  its value function can be obtained using point iteration for solving

V (s) = Ea(a|s)Es p(s |s,a) [r + V (s )]

Similar to DQN, on each update a target is computed using current approximation

y = r + V(s )
and then MSE is minimized to move values of V(s) towards the guess. Notice that to compute the target for critic we require samples from the policy  which is being
evaluated. Although actor evolves throughout optimization process, we assume that one update of policy  does not lead to significant change of true V  and thus our critic, which approximates value function for older version of policy, is close enough to construct the target. But if samples from, for example, old policy are used to compute the guess, the step of critic update will correspond to learning the value function for old policy other than current. Essentially, this means that both actor and critic training procedures require samples from current policy , making Actor-Critic algorithm onpolicy by design. Consequently, samples that were collected on previous update iterations become useless and can be forgotten. This is the key reason why policy gradient algorithms are usually less sample-efficient than value-based.
Now as we have an approximation of value function, advantage estimation can be done using one-step transitions (41). As the procedure of training an actor, i. .e. gradient estimation (40), also does not demand sampling the whole trajectory, each update now requires only a small roll-out to be sampled. The amount of transitions in the roll-out corresponds to the size of mini-batch.
The problem with roll-outs is that the data is obviously not i. i. d., which is crucial for training networks. In value-based methods, this problem was solved with experience replay, but in policy gradient algorithms it is essential to collect samples from scratch after each update of the networks parameters. The practical solution for simulated environments is to launch several instances of environment (for example, on different cores of multiprocessor) in parallel threads and have several parallel interactions. After several steps in each environment, the batch for update is collected by uniting transitions from all instances and one synchronous27 update of networks parameters  and  is performed.
One more optimization that can be done is to partially share weights of networks  and . It is justified as first layers of both networks correspond to basic features extraction and these features are likely to be the same for optimal policy and value function. While it reduces the number of training parameters almost twice, it might destabilize learning process as the scales of gradient (40) and
27there is also an asynchronous modification of advantage actor critic algorithm (A3C) which accelerates the training process by storing a copy of network for each thread and performing weights synchronization from time to time.
32

gradient of critic's MSE loss may be significantly different, so they should be balanced with additional hyperparameter.

Algorithm 6: Advantage Actor-Critic (A2C)

Hyperparameters: B -- batch size, V -- critic neural network,  -- actor neural network,  -- critic loss scaling, SGD optimizer.

Initialize weights ,  arbitrary On each step:

1. obtain a roll-out of size B using policy () 2. for each transition T from the roll-out compute advantage estimation:
A(T ) = r + V(s ) - V

3. compute target (detached from computational graph to prevent backpropagation):

y(T ) = r + V(s )

4. compute critic loss:

1 Loss =
B

2
y(T ) - V

T

5. compute critic gradients:

critic =  Loss 

6. compute actor gradient:

actor = 1 B

 log (a | s)A(T )

T

7. make a step of gradient descent using actor + critic

5.4. Generalized Advantage Estimation (GAE)

There is a design dilemma in Advantage Actor Critic algorithm concerning the choice whether to use the critic to estimate Q(s, a) and introduce bias into gradient estimation or to restrict critic employment only for baseline and cause higher variance with necessity of playing the whole episodes for each update step.
Actually, the range of possibilities is wider. Since Actor-Critic is an on-policy algorithm by design, we are free to use N -step approximations instead of one-step: using

N -1

Q(s, a) 

nr(n+1) + N V  s(N)

n=0

we can define N -step advantage estimator as

N -1

A(N)(s, a) :=

nr(n+1) + N V s(N) - V(s)

n=0

For N = 1 this estimation corresponds to Actor-Critic one-step estimation with high bias and low variance. For N =  it yields the estimator with critic used only for baseline with no bias and high variance. Intermediate values correspond to something in between. Note that to use N -step advantage estimation we have to perform N steps of interaction after given state-action pair.

33

Usually finding a good value for N as hyperparameter is difficult as its «optimal» value may float throughout the learning process. In Generalized Advantage Estimation (GAE) [20] it is proposed to
construct an ensemble out of different N -step advantage estimators using exponential smoothing with some hyperparameter :

AGAE(s, a) := (1 - ) A(1)(s, a) + A(2)(s, a) + 2A(3)(s, a) + . . .

(42)

Here the parameter   [0, 1] allows smooth control over bias-variance trade-off:  = 0 corresponds to Actor-Critic with higher bias and lower variance while   1 corresponds to REINFORCE with no bias and high variance. But unlike N as hyperparameter, it uses mix of different estimators in intermediate case.
GAE proved to be a convenient way how more information can be obtained from collected rollout in practice. Instead of waiting for episode termination to compute (42) we may use «truncated» GAE which ensembles only those N -step advantage estimators that are available:

Atrunc.GAE(s, a)

:=

A(1)(s, a)

+

A(2)(s, a) + 2A(3)(s, a) + · · · 1 +  + 2 + · · · + N-1

+

N-1A(N)(s, a)

Note that the amount N of available estimators may be different for different transitions from rollout: if we performed K steps of interaction in some instance of environment starting from some state-action pair s, a, we can use N = K step estimators; for next state-action pair s , a we have only N = K -1 transitions and so on, while the last state-action pair sN-1, aN-1 can be estimated only using A(1) as only N = 1 following transition is available. Although different transitions are estimated with different precision (leading to different bias and variance), this approach allows to use
all available information for each transition and utilize multi-step approximations without dropping
last transitions of roll-outs used only for target computation.

5.5. Natural Policy Gradient (NPG)

In this section we discuss the motivation and basic principles behind the idea of natural gradient descent, which we will require for future references.
The standard gradient descent optimization method is known to be extremely sensitive to the choice of parametrization. Suppose we attempt to solve the following optimization task:

f (q)  min
q
where q is a distribution and F is arbitrary differentiable function. We often restrict q to some parametric family and optimize similar objective, but with respect to some vector of parameters  as unknown variable:
f (q)  min

Classic example of such problem is maximum likelihood task when we try to fit the parameters of our model to some observed data. The problem is that when using standard gradient descent both the convergence rate and overall performance of optimization method substantially depend on the choice of parametrization q. The problem holds even if we fix specific distribution family as many distribution families allow different parametrizations.
To see why gradient descent is parametrization-sensitive, consider the model which is used at some current point k to determine the direction of next optimization step:

f (qk ) +

f (qk ), 

 min




2 2

<

k

where k is learning rate at step k. Being first-order method, gradient descent constructs a «model» which approximates F locally around k using first-order Taylor expansion and employs standard Euclidean metric to determine a region of trust for this model. Then this surrogate task is solved
analytically to obtain well-known update formula:

  -f (qk )

34

The issue arises from reliance on Eucliden metric in the space of parameters. In most parametrizations, small changes in parameters space do not guarantee small change in distribution space and vice versa: some small changes in distribution may demand big steps in parameters space28.
Natural gradient proposes to use another metric, which achieves invariance to parametrization of distribution q using the properties of Fisher matrix:

Definition 11. For distribution q Fisher matrix Fq() is defined as Fq() := Exq log q(x)( log q(x))T

Note that Fisher matrix depends on parametrization. Yet for any parametrization it is guaranteed to be positive semi-definite by definition. Moreover, it induces a so-called Riemannian metric29 in the space of parameters:
d(1, 2)2 := (2 - 1)T Fq(1)(2 - 1)
In natural gradient descent it is proposed to use this metric instead of Euclidean:

f (qk ) +

f (qk ), 

 min


T Fq(k) < k

This surrogate task can be solved analytically to obtain the following optimization direction:

  -Fq(k)-1f (qk )

(43)

The direction of gradient descent is corrected by Fisher matrix which concerns the scale across dif-
ferent axes. This direction, specified by Fq(k)-1f (qk ), is called natural gradient. Let's discuss why this new metric really provides us invariance to distribution parametrization.

We already obtained natural gradient for q being parameterized by  (43). Assume that we have

another parametrization q . These new parameters  are somehow related to ; we suppose there is some functional dependency (), which we assume to be differentiable with jacobian J . In this

notation:

 = J,

Jij

:=

 i  j

(44)

The central property of Fisher matrix, which provides the desired invariance, is the following:

Proposition 21. If  = () with jacobian J , then reparametrization formula for Fisher matrix is

Fq() = J T Fq()J

(45)

Now it can be derived that natural gradient for parametrization with  is the same as for . If we want to calculate natural gradient in terms of , then our step is, according to (44):

 = J =

{natural gradient in terms of }  J Fq(k)-1 f (qk ) =

{Fisher matrix reparametrization (45)} = J

J T Fq(k)J

-1
 f (qk )

{chain rule} = J J T Fq(k)J -1  (k)T f (qk ) =

= J J -1Fq(k)-1J -T J T f (qk ) =

= Fq(k)-1f (qk )

28classic example is that N (0, 100) is similar to N (1, 100) while N (0, 0.1) is completely different from N (1, 0.1), although Euclidean distance in parameter space is the same for both pairs.
29in Euclidean space the general form of scalar product is x, y := xT Gy, where G is fixed positive semi-definite matrix. The metric induced by this scalar product is correspondingly d(x, y)2 := (y - x)T G(y - x). The difference in Riemannian space is that G, called metric tensor, depends on x, so the relative distance may vary for different points. It is used to describe the distances between points on manifolds and holds important properties which Fisher matrix inherits as metric
tensor for distribution space.

35

which can be seen to be the same as in (43). Application of natural gradient descent in DRL setting is complicated in practice. Theoretically,
the only change that must be done is scaling of gradient using inverse Fisher matrix (43). Yet, Fisher matrix requires n2 memory and O(n3) computational costs for inversion where n is the number of parameters. For neural networks this causes the same complications as the application of secondorder optimization methods.
K-FAC optimization method [13] provides a specific approximation form of Fisher matrix for neural networks with linear layers which can be efficiently computed, stored and inverted. Usage of K-FAC approximation allows to compute natural gradient directly using (43).

5.6. Trust-Region Policy Optimization (TRPO)

The main drawback of Actor-Critic algorithm is believed to be the abandonment of experience that was used for previous updates. As the number of updates required is usually huge, this is considered to be a substantial loss of information. Yet, it is not clear how this information can be effectively used for newer updates.
Suppose we want to make an update of (), but using samples collected by some old. The straightforward approach is importance sampling technique, which naive application to gradient formula (40) yields the following result:

P(T | ()) J () = ET old P (T | old)

 log (at | st)A(st, at)

t=0

The emerged importance sampling weight is actually computable as transition probabilities cross

out:

P(T | ()) =
P(T | old)

t=1 (at | st) t=1 old(at | st)

The problem with this coefficient is that it tends either to be exponentially small or to explode. Even

with some heuristic normalization of coefficients the batch gradient would become dominated by

one or several transitions and destabilize the training procedure by introducing even more variance.

Notice that application of importance sampling to another representation of gradient (37) yields

seemingly different result:

J ()

=

Eold

d()(s) dold (s)

(a | old(a

s) | s)



log

 (a

|

s)A (s,

a)

(46)

Here we avoided common for the whole trajectories importance sampling weights by using the def-
inition of state visitation frequencies. But this result is even less practical as these frequencies are
unknown to us.
The first key idea behind the theory concerning this problem is that may be these importance sampling coefficients behave more stable if the policies old and () are in some terms «close». Intuitively, in this case d()(s) of formula (46) is close to 1 as state visitation frequencies are similar,
dold (s)
and the remained importance sampling coefficient becomes acceptable in practice. And if some two
policies are similar, their values of our objective (2) are probably close too. For any two policies,  and old:

J () - J (old) = ET  tr(st) - J (old) =

t=0

= ET 

tr(st) - V old (s0) =

t=0

= ET 

tr(st) - V old (s0) =

t=0

{trick

 t=0

(at+1

-

at)

=

-a030}

=

ET



tr(st) +

t+1V old (st+1) - tV old (st) =

t=0

t=0

{regroup} = ET 

t r(st) + V old (st+1) - V old (st) =

t=0

36

{by definition (3)} = ET 

t Qold (st, at) - V old (st)

t=0

{by definition (14)} = ET  tAold (st, at)

t=0

The result obtained above is often referred to as relative policy performance identity and is actually very interesting: it states that we can substitute reward with advantage function of arbitrary policy and that will shift the objective by the constant.
Using the discounted state visitation frequencies definition 10, relative policy performance identity can be rewritten as

J () - J (old)

=

1

1 -



Esd (s) Ea(a|s) Aold

(s,

a)

Now assume we want to optimize parameters  of policy  while using data collected by old: applying importance sampling in the same manner:

J () - J (old)

=

1

1 -



Esdold

(s)

d (s) dold (s)

Eaold

(a|s)

(a | old(a

s) | s)

Aold

(s,

a)

As we have in mind the idea of old being close to , the question is how well this identity can be approximated if we assume d (s) = dold (s). Under this assumption:

J () - J (old)



Lold ()

:=

1

1 -



Esdold

(s) Ea old (a|s)

(a | s) old(a | s)

Aold

(s,

a)

The point is that interaction using old corresponds to sampling from the expectations presented

in Lold ():

Lold ()

=

Eold

(a | s) Aold (s, old(a | s)

a)

The approximation quality of Lold () can be described by the following theorem:

Proposition 22. [19]

J () - J (old) - Lold ()

 C max KL(old
s

 )[s]

where C is some constant and KL(old )[s] is a shorten notation for KL(old(a | s) (a | s)).

There is an important corollary of proposition 22:

J ()

-

J (old)



Lold ()

-

C

max
s

KL(old

 )[s]

which not only states that expression on the right side represents a lower bound, but also that the optimization procedure

k+1 = argmax


Lk

()

-

C

max
s

KL(k

 )[s]

(47)

will yield a policy with guaranteed monotonic improvement31. In practice there are several obstacles which preserve us from obtaining such procedure. First of
all, our advantage function estimation is never precise. Secondly, it is hard to estimate precise value of constant C. One last obstacle is that it is not clear how to calculate KL-divergence in its maximal form (with max taken across all states).

30and if MDP is episodic, for terminal states V old (sT ) = 0 by definition. 31the maximum of lower bound is non-negative as its value for  = k equals zero, which causes J (k+1) - J (k)  0.

37

In Trust-Region policy optimization [19] the idea of practical algorithm, approximating procedure
(47), is analyzed. To address the last issue, the naive approximation is proposed to substitute max with averaging across states32:

max KL(old
s

)[s]  Esdold (s) KL(old

 )[s]

The second step of TRPO is to rewrite the task of unconstrained minimization (47) in equivalent constrained («trust-region») form33 to incorporate the unknown constant C into learning rate:

Lold ()  max


(48)

Esd(s|old) KL(old )[s] < C

Note that this rewrites an update iteration in terms of optimization methods: while Lold () is an approximation of true objective J () - J (old), the constraint sets the region of trust to the surrogate. Remark that constraint is actually a divergence in policy space, i. e. it is very similar to a
metric in the space of distributions while the surrogate is a function of the policy and depends on
parameters  only through . To solve the constrained problem (48), the technique from convex optimization is used. Assume
that old is a current policy and we want to update its parameters k. Then the objective of (48) is modeled using first-order Taylor expansion around k while constraint is modeled using secondorder 34 Taylor approximation:

Lold (k + ) 

 Lold ()|k , 

 max


Esd(s|old) KL(old

k+) 

1 2

Esd(s|old

)

T

2 KL(old

) k  < C

It turns out, that this model is equivalent to natural policy gradient, discussed in sec. 5.5:

Proposition 23.

2 KL( old)[s] k = F(a|s)()

so KL-divergence constraint can be approximated with metric induced by Fisher matrix. Moreover, the gradient of surrogate function is

Lold ()|k

=

Eold

(a | s)|k Aold (s, a) old(a | s)

=

{old = k } = Eold  log k (a | s)Aold (s, a)
which is exactly an Actor-Critic gradient. Therefore the formula of update step is given by
  -F()-1Lold ()
where Lold () coincides with standard policy gradient, and F() is hessian of KL-divergence:
F() := Esdold (s) 2 KL(old ) k
In practical implementations KL-divergence can be Monte-Carlo estimated using collected rollout. The size of roll-out must be significantly bigger than in Actor-Critic to achieve sufficient precision of hessian estimation. Then to obtain a direction of optimization step the following system of linear equations
F() = -Lold () is solved using a conjugate gradients method which is able to work with Hessian-vector multiplication procedure instead of requiring to calculate F() explicitly.
32the distribution from which the states come is set to be dold (s) for convenience as this is the distribution from which they come in Lold ().
33the unconstrained objective is Lagrange function for constrained form. 34as first-order term is zero.
38

TRPO also accompanies the update step with a line-search procedure which dynamically adjusts step length using standard backtracking heuristic. As TRPO intuitively seeks for policy improvement on each step, the idea is to check whether the lower bound (47) is positive after the biggest step allowed according to KL-constraint and reduce the step size until it becomes positive.
Unlike Actor-Critic, TRPO performs extremely expensive complicated update steps but requires relatively small number of iterations in return. Of course, due to many approximations done, the overall procedure is only a resemblance of theoretically-justified iterations (47) providing improvement guarantees.

5.7. Proximal Policy Optimization (PPO)

Proximal Policy Optimization [21] proposes alternative heuristic way of performing lower bound
(47) optimization which demonstrated encouraging empirical results.
PPO still substitutes max KL on average, but leaves the surrogate in unconstrained form, sug-
s
gesting to treat unknown constant C as a hyperparameter:

Eold

(a | s) Aold (s, a) - C KL(old old(a | s)

)[s]  max


(49)

The naive idea would be to straightforwardly optimize (49) as it is equivalent to solving the constraint trust-region task (48). To avoid Hessian-involved computations, one possible option is just to perform one step of first-order gradient optimization of (49). Such algorithm was empirically discovered to perform poorly as importance sampling coefficients (a|s) tend to unbounded growth.
 old (a|s)
In PPO it is proposed to cope with this problem in a simple old-fashioned way: by clipping. Let's denote by
r() := (a | s) old(a | s)
an importance sampling weight and by

rclip() := clip(r(), 1 - , 1 + )

its clipped version where  (0, 1) is a hyperparameter. Then the clipped version of lower bound is:

Eold min r()Aold (s, a), rclip()Aold (s, a) - C KL(old )[s]  max

(50)



Here the minimum operation is introduced to guarantee that the surrogate objective remains a
lower bound. Thus the clipping at 1 + may occur only in the case if advantage is positive while clipping at 1 - may occur if advantage is negative. In both cases, clipping represents a penalty for importance sampling weight r() being too far from 1.
The overall procedure suggested by PPO to optimize the «stabilized» version of lower bound (50) is the following. A roll-out is collected using current policy old with some parameters . Then the batches of typical size (as for Actor-Critic methods) are sampled from collected roll-out and several
steps of SGD optimization of (50) proceed with respect to policy parameters . During this process the policy old is considered to be fixed and new interaction steps are not performed, while in implementations there is no need to store old weights k since everything required from old is to collect transitions and remember the probabilities old(a | s). The idea is that during these several steps we may use transitions from the collected roll-out several times. Similar alternative is to per-
form several epochs of training by passing through roll-out several times, as it is often done in deep
learning.
Interesting fact discovered by the authors of PPO during ablation studies is that removing KLpenalty term doesn't affect the overall empirical performance. That is why in many implementations
PPO does not include KL-term at all, making the final surrogate objective have a following form:

Eold min r()Aold (s, a), rclip()Aold (s, a)  max

(51)



Note that in this form the surrogate is not generally a lower bound and «improvement guarantees» intuition is lost.

39

Algorithm 7: Proximal Policy Optimization (PPO)

Hyperparameters: B -- batch size, R -- rollout size, n_epochs -- number of epochs,  -- clipping parameter, V -- critic neural network,  -- actor neural network,  -- critic loss scaling, SGD optimizer.
Initialize weights ,  arbitrary On each step:
1. obtain a roll-out of size R using policy (), storing action probabilities as old(a | s).
2. for each transition T from the roll-out compute advantage estimation (detached from computational graph to prevent backpropagation):
A(T ) = r + V(s ) - V

3. perform n_epochs passes through roll-out using batches of size B; for each batch:

· compute critic target (detached from computational graph to prevent backpropagation): y(T ) = r + V(s )

· compute critic loss:

1 Loss =
B

2
y(T ) - V

T

· compute critic gradients:

critic =  Loss 

· compute importance sampling weights:

r(T )

=

(a | s) old(a | s)

· compute clipped importance sampling weights:

rclip(T ) = clip(r(T ), 1 - , 1 + )

· compute actor gradient:

actor = 1 B

 min r(T )A(T ), rclip(T )A(T )

T

· make a step of gradient descent using actor + critic

40

6. Experiments

6.1. Setup
We performed our experiments using custom implementation of discussed algorithms attempting to incorporate best features from different official and unofficial sources and unifying all algorithms in a single library interface. The full code is available at our github.
While custom implementation might not be the most efficient, it hinted us several ambiguities in algorithms which are resolved differently in different sources. We describe these nuances and the choices made for our experiments in appendix A.
For each environment we launch several algorithms to train the network with the same architecture with the only exception being the head which is specified by the algorithm (see table 1).

DQN Dueling Categorical Dueling Categorical Quantile Dueling Quantile
A2C / PPO

Linear transformation to |A| arbitrary real values First head: linear transformation to |A| arbitrary real values Second head: linear transformations to an arbitrary scalar
Aggregated using dueling architecture formula (17) |A| linear transformations with softmax to A values First head: linear transformation to |A| arbitrary real values Second head: |A| linear transformations to A arbitrary real values Aggregated using dueling architecture formula (32) |A| linear transformations to A arbitrary real values First head: linear transformation to |A| arbitrary real values Second head: |A| linear transformations to A arbitrary real values Aggregated using dueling architecture formula (32) without softmax Actor head: linear transformation with softmax to |A| values
Critic head: linear transformation to scalar value

Table 1: Heads used for different algorithms. Here |A| is the number of actions and A is the chosen number of atoms.

For noisy networks all fully-connected layers in the feature extractor and in the head are substituted with noisy layers, doubling the number of their trained parameters. Both usage of noisy layers and the choice of the head influences the total number of parameters trained by the algorithm.
As practical tuning of hyperparameters is computationally consuming activity, we set all hyperparameters to their recommended values while trying to share the values of common hyperparameters among algorithms without affecting overall performance.
We choose to give each algorithm same amount of interaction steps to provide the fair comparison of their sample efficiency. Thus the wall-clock time, number of episodes played and the number of network parameters updates varies for different algorithms.

6.2. Cartpole
Cartpole from OpenAI Gym [2] is considered to be one of the simplest environments for DRL algorithms testing. The state is described with 4 real numbers while action space is two-dimensional discrete.
The environment rewards agent with +1 each tick until the episode ends. Poor action choices lead to early termination. The game is considered solved if agent holds for 200 ticks, therefore 200 is maximum reward in this environment.
In our first experiment we launch algorithms for 10 000 interaction steps to train a neural network on the Cartpole environment. The network consists of two fully-connected hidden layers with 128 neurons and an algorithm-specific head. We used ReLU for activations. The results of a single launch are provided35 in table 2.
35we didn't tune hyperparameters for each of the algorithms, so the configurations used might not be optimal.

41

Reached 200 Average reward Average FPS

Double DQN Dueling Double DQN DQN Categorical DQN Prioritized Double DQN Categorical Prioritized Double DQN Quantile Prioritized Double DQN Categorical DQN with target network Quantile Double DQN Quantile DQN Categorical Double DQN Noisy Quantile Prioritized Dueling DQN Twin DQN Noisy Double DQN Noisy Prioritized Double DQN Quantile Regression Rainbow Rainbow Noisy Quantile Prioritized Double DQN Noisy Categorical Prioritized Double DQN PPO with GAE Noisy Prioritized Dueling Double DQN PPO Noisy Categorical Prioritized Dueling Double DQN A2C A2C with GAE

23.0 27.0 33.0 28.0 37.0 46.0 42.0 44.0 54.0 70.0 42.0 86.0 57.0 67.0 94.0 106.0 91.0 127.0 63.0 144.0 180.0 184.0 428.0
-

126.17 121.78 116.27 110.87 110.52 104.86 100.76
96.08 93.14 88.12 81.25 74.13 71.14 71.06 67.34 67.11 64.01 63.01 62.04 53.06 47.52 45.19 22.09 12.30 11.50

95.78 62.65 101.53 74.95 85.58 66.00 68.62 73.92 75.40 77.93 70.90 21.41 52.51 31.81 30.72 21.54 20.35 28.27 27.81 390.53 22.56 412.88 20.63 1048.64 978.00

Table 2: Results on Cartpole for different algorithms: number of episode when the highest score of 200 was reached, average reward across all played episodes and average number of frames processed in a second (FPS).

6.3. Pong
We used Atari Pong environment from OpenAI Gym [2] as our main testbed to study the behaviour of the following algorithms:
· DQN -- Deep Q-learning (sec. 3.2)
· c51 -- Categorical DQN (sec. 4.2)
· QR-DQN -- Quantile Regression DQN (sec. 4.3)
· Rainbow (sec. 4.4)
· A2C -- Advantage Actor Critic (sec. 5.3) extended with GAE (sec. 5.4)
· PPO -- Proximal Policy Optimization (sec. 5.7) extended with GAE (sec. 5.4) In Pong, each episode is split into rounds. Each round ends with player either winning or loosing. The episode ends when the player wins or looses 21 rounds. The reward is given after each round and is +1 for winning and -1 for loosing. Therefore the maximum total reward is 21 and the minimum is -21. Note that the flag done indicating episode ending is not provided to the agent after each round but only at the end of full game (consisting of 21-41 rounds). The standard preprocessing for Atari games proposed in DQN [14] was applied to the environment (see table 3). Thus, state space is represented by (84, 84) grayscale pixels input (1 channel with domain [0, 255]). Action space is discrete with |A| = 6 actions. All algorithms were given 1 000 000 interaction steps to train the network with the same feature extractor presented on fig. 1. The number of trained parameters is presented in table 4. All used hyperparameters are listed in table 7 in appendix B.
42

NoopResetEnv MaxAndSkipEnv
FireResetEnv WarpFrame

Do nothing first 30 frames of games to imitate the pause between game start and real player reaction. Each interaction steps takes 4 frames of the game to allow less frequent switch of action. Max is taken
over 4 passed frames to obtain an observation. Presses «Fire» button at first frame to launch the game, otherwise screen remains frozen.
Turns observation to grayscale image of size 84x84.
Table 3: Atari Pong preprocessing

Algorithm DQN c51
QR-DQN Rainbow
A2C PPO

Number of trained parameters 1 681 062 1 834 962 1 834 962 3 650 410 1 681 575 1 681 575

Table 4: Number of trained parameters in Pong experiment.

6.4. Interaction-training trade-off in value-based algorithms
There is a common belief that policy gradient algorithms are much faster in terms of computational costs while value-based algorithms are preferable when simulation is expensive because of their sample efficiency. This follows from the nature of algorithms, as the fraction «observations per network updates» is extremely different for these two families: indeed, in DQN it is often assumed to perform one network update after each new transitions, while A2C collects about 32-40 observations for only one update. That makes the number of network updates performed during 1M steps interaction process substantially different and is the main reason of policy gradients speed rate.
Also policy gradient algorithms use several threads for parallel simulations (8 in our experiments) while value-based algorithms are formally single-threaded. Yet they can also enjoy multi-threaded interaction, in the simplest form by playing 1 step in all instances of environment and then performing L steps of network optimization [8]. For consistency with single-threaded case it is reasonable to set the value of L to be equal to the number of threads to maintain the same fraction «observations per network updates».
However it has been reported that lowering value of L in two or four times can positively affect wall-clock time with some loss of sample efficiency, while raising batch size may mitigate this downgrade. The overall impact of such acceleration of value-based algorithms on performance properties is not well studied and may alter their behaviour.
In our experiments on Pong it became evident that value-based algorithms perform extensive amount of redundant network optimization steps, absorbing knowledge faster than novel information from new transitions comes in. This reasoning in particular follows from the success of PPO on Pong task which performs more than 10 times less network updates.

Threads Batch size
L

Vanilla algorithm 1 32 1

Accelerated version 8
128 2

Interactions per update

1

4

Table 5: Setup for value-based acceleration experiment

We compared two versions of value-based algorithms: vanilla version, which is single-threaded with standard batch size (32) and L = 1 meaning that each observed transition is followed with one network optimization step, and accelerated version, where 1 interaction step is performed in 8 parallel instances of environment and L is set to be 2 instead of 8 which raises the fraction «ob-
43

(1, 84, 84)
(64, 9, 9)

Convolution 8x8 with stride = 4
Convolution 4x4 with stride = 2
Convolution 3x3 with stride = 1
Fullyconnected layer

(32, 20, 20)

512 FEATURES

(64, 7, 7)

Algorithmspecific head
Figure 1: Network used for Atari Pong. All activation functions are ReLU. For Rainbow the fully-connected layer and all dense layers in the algorithm-specific head are substituted with noisy layers.

servations per training step» in four times. To compensate this change we raised batch size in four times.
As expected, average speed of algorithms increases in approximately 3.5 times (see table 6). We provide training curves with respect to 1M performed interaction steps on fig. 2 and with respect to wall-clock time on fig. 3. The only vanilla algorithm that achieved better final score comparing to its accelerated rival is QR-DQN, while other three algorithms demonstrated both acceleration and performance improvement. The latter is probably caused by randomness as relaunch of algorithms within the same setting and hyperparameters can be strongly influenced by random seed.
It can be assumed that fraction «observations per updates» is an important hyperparameter of value-based algorithms which can control the trade-off between wall-clock time and sample efficiency. From our results it follows that low fraction leads to excessive network updates and may slow down learning in several times. Yet this hyperparameter can barely be tuned universally for all kinds of tasks opposed to many other hyperparameters that usually have their recommended default values.
We stick further to the accelerated version and use its results in final comparisons.
6.5. Results
We compare the results of launch of six algorithms on Pong from two perspectives: sample efficiency (fig. 4) and wall-clock time (fig. 5). We do not compare final performance of these algorithms as all six algorithms are capable to reach near-maximum final score on Pong given more iterations, while results after 1M iterations on a single launch significantly depend on chance.
All algorithms start with a warm-up session during which they try to explore the environment and
44

average score for the last 20 episodes

Algorithm DQN c51
QR-DQN Rainbow
A2C PPO

Interactions per update

vanilla accelerated

1

4

1

4

1

4

1

4

40

10.33

Average transitions per second

vanilla

accelerated

55.74

168.43

44.08

148.76

47.46

155.97

19.30

70.22

656.25

327.13

Table 6: Computational efficiency of vanilla and accelerated versions.

20

DQN accelerated

15

DQN vanilla c51 accelerated

10

c51 vanilla QR-DQN accelerated

5

QR-DQN vanilla Rainbow accelerated

Rainbow vanilla

0

5

10

15

20

0

200000

Acceleration's influence on sample efficiency

400000

600000

interaction step

800000

1000000

Figure 2: Training curves of vanilla and accelerated version of value-based algorithms on 1M steps of Pong. Although accelerated versions perform network updates four times less frequent, the performance degradation is not observed.

learn first dependencies how the result of random behaviour can be surpassed. Epsilon-greedy with tuned parameters provides sufficient amount of exploration for DQN, c51 and QR-DQN whithout slowing down further learning while hyperparameter-free noisy networks are the main reason why Rainbow has substantially longer warm-up.
Policy gradient algorithms incorporate exploration strategy in stochasticity of learned policy but underutilization of observed samples leads to almost 1M-frames warm-up for A2C. It can be observed that PPO successfully mitigates this problem by reusing samples thrice. Nevertheless, both PPO and A2C solve Pong relatively quickly after the warm-up stage is over.
Value-based algorithm proved to be more computationally costly. QR-DQN and categorical DQN introduce more complicated loss computation, yet their slowdown compared to standard DQN is moderate. On the contrary, Rainbow is substantially slower mainly because of noise generation involvement. Furthermore, combination of noisy networks and prioritized replay results in even less stable training process.
We provide loss curves for all six algorithms and statistics for noise magnitude and prioritized replay for Rainbow in appendix C; some additional visualizations of trained algorithms playing episodes of Pong are presented in appendix D.

45

average score for the last 20 episodes

20 15 10 5 0 5 10 15 20
0

Acceleration effect on value-based algorithms

DQN accelerated DQN vanilla c51 accelerated c51 vanilla QR-DQN accelerated QR-DQN vanilla Rainbow accelerated Rainbow vanilla

200

400minutes

600

800

Figure 3: Training curves of vanilla and accelerated version of value-based algorithms on 1M steps of Pong from wall-clock time.

average score for the last 20 episodes

20 15

DQN c51

10

QR-DQN Rainbow

5

A2C PPO

0

5

10

15

20

0

Comparing different algorithms on Pong

200000

400000

600000

interaction step

800000

Figure 4: Training curves of all algorithms on 1M steps of Pong.

1000000

average score for the last 20 episodes

20 15 10

Comparing wall-clock time of different algorithms on Pong

P(0PhO50m)

D(1QhN38m)

c(15h1 52m) Q(1Rh-D4Q6mN)

5

0

5 10

A(02hC25m)

15

20

0

50

100

150

minutes

R(3ahin5b7omw)
DQN c51 QR-DQN Rainbow A2C PPO 200

Figure 5: Training curves of all algorithms on 1M steps of Pong from wall-clock time.

46

7. Discussion
We have concerned two main directions of universal model-free RL algorithm design and attempted to recreate several state-of-art pipelines.
While the extensions of DQN are reasonable solutions of evident DQN problems, their effect is not clearly seen on simple tasks like Pong36. Current state-of-art in single-threaded value-based approach, Rainbow DQN, is full of «glue and tape» decisions that might be not the most effective way of training process stabilization.
Distributional value-based approach is one of the cheapest in terms of resources extensions of vanilla DQN algorithm. Although it is reported to provide substantial performance improvement in empirical experiments, the reason behind this result remains unclear as expectation of return is the key quantity for agent's decision making while the rest of learned distribution does not affect his choices. One hypothesis to explain this phenomenon is that attempting to capture wider range of dependencies inside given MDP may provide auxiliary helping tasks to the algorithm, leading to better learning of expectation. Intuitively it seems that more reasonable switch of DQN to distributional setting would be learning the Bayesian uncertainty of expectation of return given observed data, but scalable practical algorithms within this orthogonal paradigm are yet to be created.
Policy gradient algorithms are aimed at direct optimization of objective and currently beat valuebased approach in terms of computational costs. They tend to have less hyperparameters but are extremely sensitive to the choice of optimizer parameters and especially learning rate. We have affirmed the effectiveness of state-of-art algorithm PPO, which succeeded to solve Pong within an hour without hyperparameter tuning. Though on the one hand this algorithm was derived from TRPO theory, it essentially deviates from it and substitutes trust region updates with heuristic clipping.
It can be observed in our results that PPO provides better gradients to the same network than DQN-based algorithms despite the absence of experience replay. While it is fair to assume that forgetting experienced transitions leads to information loss, it is also true that most observations stored in replay memory are already learned or contain no useful information. The latter makes most transitions in the sampled mini-batches insignificant, and, while prioritized replay attacks this issue, it might still be the case that current experience replay management techniques are imperfect.
There are still a lot of deviations of empirical results from theoretical perspectives. It is yet unclear which techniques are of the highest potential and what explanation lies behind many heuristic elements composing current state-of-art results. Possibly essential elements of modeling human-like reinforcement learning are yet to be unraveled as active research in this area promises substantial acceleration, generalization and stabilization of DRL algorithms.
36although it takes several hours to train, Pong is considered to be the easiest of 57 Atari games and one of the most basic testbeds for RL algorithms.
47

References
[1] M. G. Bellemare, W. Dabney, and R. Munos. A distributional perspective on reinforcement learning. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages 449­458. JMLR. org, 2017.
[2] G. Brockman, V. Cheung, L. Pettersson, J. Schneider, J. Schulman, J. Tang, and W. Zaremba. Openai gym. arXiv preprint arXiv:1606.01540, 2016.
[3] W. Dabney, M. Rowland, M. G. Bellemare, and R. Munos. Distributional reinforcement learning with quantile regression. In Thirty-Second AAAI Conference on Artificial Intelligence, 2018.
[4] M. Fortunato, M. G. Azar, B. Piot, J. Menick, I. Osband, A. Graves, V. Mnih, R. Munos, D. Hassabis, O. Pietquin, et al. Noisy networks for exploration. arXiv preprint arXiv:1706.10295, 2017.
[5] I. Goodfellow, Y. Bengio, A. Courville, and Y. Bengio. Deep learning, volume 1. MIT press Cambridge, 2016.
[6] P. Henderson, R. Islam, P. Bachman, J. Pineau, D. Precup, and D. Meger. Deep reinforcement learning that matters. In Thirty-Second AAAI Conference on Artificial Intelligence, 2018.
[7] M. Hessel, J. Modayil, H. Van Hasselt, T. Schaul, G. Ostrovski, W. Dabney, D. Horgan, B. Piot, M. Azar, and D. Silver. Rainbow: Combining improvements in deep reinforcement learning. In Thirty-Second AAAI Conference on Artificial Intelligence, 2018.
[8] D. Horgan, J. Quan, D. Budden, G. Barth-Maron, M. Hessel, H. Van Hasselt, and D. Silver. Distributed prioritized experience replay. arXiv preprint arXiv:1803.00933, 2018.
[9] A. Irpan. Deep reinforcement learning doesnt work yet. Online (Feb. 14): https://www. alexirpan. com/2018/02/14/rl-hard. html, 2018.
[10] L. Kaiser, M. Babaeizadeh, P. Milos, B. Osinski, R. H. Campbell, K. Czechowski, D. Erhan, C. Finn, P. Kozakowski, S. Levine, et al. Model-based reinforcement learning for atari. arXiv preprint arXiv:1903.00374, 2019.
[11] R. Koenker and G. Bassett Jr. Regression quantiles. Econometrica: journal of the Econometric Society, pages 33­50, 1978.
[12] T. P. Lillicrap, J. J. Hunt, A. Pritzel, N. Heess, T. Erez, Y. Tassa, D. Silver, and D. Wierstra. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971, 2015.
[13] J. Martens and R. Grosse. Optimizing neural networks with kronecker-factored approximate curvature. In International conference on machine learning, pages 2408­2417, 2015.
[14] V. Mnih, K. Kavukcuoglu, D. Silver, A. Graves, I. Antonoglou, D. Wierstra, and M. Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013.
[15] C. Nota and P. S. Thomas. Is the policy gradient a gradient? arXiv preprint arXiv:1906.07073, 2019.
[16] OpenAI. Openai five. https://blog.openai.com/openai-five/, 2018.
[17] T. Salimans, J. Ho, X. Chen, S. Sidor, and I. Sutskever. Evolution strategies as a scalable alternative to reinforcement learning. arXiv preprint arXiv:1703.03864, 2017.
[18] T. Schaul, J. Quan, I. Antonoglou, and D. Silver. Prioritized experience replay. arXiv preprint arXiv:1511.05952, 2015.
[19] J. Schulman, S. Levine, P. Abbeel, M. I. Jordan, and P. Moritz. Trust region policy optimization. In Icml, volume 37, pages 1889­1897, 2015.
[20] J. Schulman, P. Moritz, S. Levine, M. Jordan, and P. Abbeel. High-dimensional continuous control using generalized advantage estimation. arXiv preprint arXiv:1506.02438, 2015.
[21] J. Schulman, F. Wolski, P. Dhariwal, A. Radford, and O. Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.
48

[22] D. Silver, T. Hubert, J. Schrittwieser, I. Antonoglou, M. Lai, A. Guez, M. Lanctot, L. Sifre, D. Kumaran, T. Graepel, et al. Mastering chess and shogi by self-play with a general reinforcement learning algorithm. arXiv preprint arXiv:1712.01815, 2017.
[23] R. S. Sutton and A. G. Barto. Reinforcement learning: An introduction. MIT press, 2018. [24] R. S. Sutton, D. A. McAllester, S. P. Singh, and Y. Mansour. Policy gradient methods for rein-
forcement learning with function approximation. In Advances in neural information processing systems, pages 1057­1063, 2000. [25] H. Van Hasselt, A. Guez, and D. Silver. Deep reinforcement learning with double q-learning. In Thirtieth AAAI Conference on Artificial Intelligence, 2016. [26] O. Vinyals, I. Babuschkin, J. Chung, M. Mathieu, M. Jaderberg, W. M. Czarnecki, A. Dudzik, A. Huang, P. Georgiev, R. Powell, T. Ewalds, D. Horgan, M. Kroiss, I. Danihelka, J. Agapiou, J. Oh, V. Dalibard, D. Choi, L. Sifre, Y. Sulsky, S. Vezhnevets, J. Molloy, T. Cai, D. Budden, T. Paine, C. Gulcehre, Z. Wang, T. Pfaff, T. Pohlen, Y. Wu, D. Yogatama, J. Cohen, K. McKinney, O. Smith, T. Schaul, T. Lillicrap, C. Apps, K. Kavukcuoglu, D. Hassabis, and D. Silver. AlphaStar: Mastering the Real-Time Strategy Game StarCraft II. https://deepmind.com/blog/ alphastar-mastering-real-time-strategy-game-starcraft-ii/, 2019. [27] Z. Wang, T. Schaul, M. Hessel, H. Van Hasselt, M. Lanctot, and N. De Freitas. Dueling network architectures for deep reinforcement learning. arXiv preprint arXiv:1511.06581, 2015. [28] C. J. Watkins and P. Dayan. Q-learning. Machine learning, 8(3-4):279­292, 1992. [29] R. J. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 8(3-4):229­256, 1992.
49

Appendix A. Implementation details

Here we describe several technical details of our implementation which may potentially influence

the obtained results.

In most papers on value-based algorithms hyperparameters recommended for Atari games as-

sume raw input in the range [0, 255], while in various implementations of policy gradient algorithms

normalized input in the range [0, 1] is considered. Stepping aside from these agreements may dam-

age the convergence speed both for value-based and policy gradient algorithms as the change of

input domain requires hyperparameters retuning.

We use MSE loss emerged in theoretical intuition for DQN while in many sources it is recom-

mended to use Huber loss37 instead to stabilize learning.

In all value-based algorithms except c51 we update target network each K-th frame instead of

exponential smoothing of its parameters as it is computationally cheaper. For c51 we remove target

network heuristic as apriori limited domain prevents unbounded growth of predictions.

We do not architecturally force quantiles outputted by the network in Quantile Regression DQN

to satisfy 0  1  · · ·  A-1. As in the original paper, we assume that all A outputs of network are arbitrary real values and use a standard linear transformation as our last layer.

In dueling architectures we subtract mean of A(s, a) across actions instead of theoretically as-

sumed maximum as proposed by original paper authors.

We implement sampling from prioritized replay using SumTree data structure and in informal

experiments affirmed the acceleration it provides. The importance sampling weight annealing (t)

is represented by initial value (0) =  which is then linearly annealed to 1 during first T frames; both  and T are hyperparameters.
We do not allow priorities P(T ) to be greater than 1 by clipping as suggested in the original

paper. This may mitigate the effect of prioritization replay but stabilizes the process.

As importance sampling weights w(T )

=

1 BP(T )

are potentially very close to zero, in original

article it was proposed to normalize them on max w(T ). In some implementations the maximum is

taken over the whole experience replay while in others maximum is taken over current batch, which

is not theoretically justified but computationally much faster. We stick to the latter option.

ple

For noisy layers we 1  Rn, 2  Rm

use factorized noise sampling: for layer with m inputs and n outputs we samfrom standard normal distributions and scale both using f () = sign() .

Thus we use f (1)f (2)T as our noise sample for weights matrix and f (2) as noise sample for

bias. All noise is shared across mini-batch. Noise is resampled on each forward pass through the

network and thus is independent between evaluation, selection and interaction. Despite all these

simplifications, we found noisy layers to be the most computationally expensive modification of

DQN leading to substantial degradation of wall-clock time.

For policy gradient algorithms we add additional policy entropy term to the loss to force ex-

ploration. We also define actor loss as a scalar function that yields the same gradients as in the

corresponding gradient estimation (40) for A2C to compute it using PyTorch mechanics. For PPO

objective (51) provides analogous «actor loss»; thus, in both policy gradient algorithms the full loss

is defined as summation of actor, critic and entropy losses, with the two latter being scaled using

scalar hyperparameters.

We use shared network architecture for policy gradient algorithms with one feature extractor and

two heads, one for policy and one for critic.

KL-penalty is not used in our PPO implementation. Also we do not normalize advantage esti-

mations across the roll-out to zero mean and unit standard deviation as additionally done in some

implementations.

We use PyTorch default initialization for linear and convolutional layers although orthogonal ini-

tialization of all layers is reported to be beneficial for policy gradient algorithms. Initial values of

sigmas

for

noisy

layers

is

set

to

be

constant

and

equal

to

init m

where

init

is

a

hyperparameter

and

m is the number of inputs in accordance with original paper.

We use Adam as our optimizer with default 1 = 0.9, 2 = 0.999,  = 1e-8. No gradient clipping is performed.

37Huber loss is defined as

(y - y^)2 if |y - y^| < 1 Loss(y, y^) =
|y - y^| else
50

Appendix B. Hyperparameters

DQN QR-DQN c51 Rainbow A2C PPO

Reward discount factor  (t)-greedy strategy
Interactions per training step Batch size B
Rollout capacity PPO number of epochs Replay buffer initialization size38 Replay buffer capacity M Target network updates K
Number of atoms A Vmin, Vmax
Noisy layers std initialization Multistep N
Prioritization degree  Prioritization bias correction  Unbiased prioritization after
GAE coeff.  Critic loss weight Entropy loss weight
PPO clip Optimizer Learning rate

0.01

+

0.99e-

30

t 000

0.99 -

4

128

-

-

10 000 transitions

1 000 000 transitions

each 1000-th step

-

51

-

-

[-10, 10]

-

-

-

0.5

-

-

-

3

-

-

-

0.5

-

-

-

0.4

-

-

- 100 000 steps

-

-

-

-

Adam

0.0001

- 32 40 1024
3 0.95 0.5 0.01
0.1

Table 7: Selected hyperparameters for Atari Pong

38number of transitions to collect in replay memory before starting network optimization using mini-batch sampling.
51

loss

Appendix C. Training statistics on Pong

1.0 0.8 0.6 0.4 0.2 0.0 0

DQN loss behaviour

0.10

DQN loss (averaged across 1000 steps)
average loss

std

0.08

0.06

loss

0.04

0.02

50000 100000 150000 200000 250000 0.00 0 network update step

50000 100000 150000 200000 250000 network update step

Figure 6: DQN loss behaviour during training on Pong.

c51 loss behaviour
4 3 2 1 0
0 50000 100000 150000 200000 network update step

QR-DQN loss behaviour
22.5 20.0 17.5 15.0 12.5 10.0 7.5
0 50000 100000150000200000 network update step

8 Rainbow loss behaviour
7 6 5 4 3 2 1
0 50000 100000150000200000 network update step

Figure 7: Loss behaviours of c51, QR-DQN and Rainbow during training on Pong.

loss

52

(smmeodioatnhewdeiwgithth iwninmdioni-wb=a1t0c0h0)

Importance sampling correction weights
1.000
0.995

0.01025

0.990

0.01020

0.985

0.980

0.01015

0.975

0.01010

0.970 0.965
0

0.01005 50000 100000 150000 200000 250000 0.01000 0
network update step

Average noise magnitude
50000 100000 150000 200000 250000 network update step

Figure 8: Rainbow statistics during training. Left: smoothed with window 1000 median of importance sampling weights from sampled mini-batches. Right: average noise magnitude logged at each 20-th step of training.

loss

Advantage Actor-Critic loss behaviour

1.0

Actor loss

0.5

Critic loss Entropy loss

0.0

0.5

1.0

1.5

0

5000

10000network update step15000

20000

25000

Figure 9: A2C loss behaviour during training.

loss

1.0 0.5 0.0 0.5 1.0 1.5 2.0 0

Proximal Policy Optimization loss behaviour

Actor loss Critic loss Entropy loss

20000

40000

60000

network update step

Figure 10: PPO loss behaviour during training.

53

80000

state value

state value

Appendix D. Playing Pong behaviour

DQN playing Pong

2.5

2.0

1.5

1.0

0.5

Predicted V(s)

0.0

Reward-to-go losses

0.5 0

wins

200

400

600

800episode step 1000

1200

1400

1600

Figure 11: DQN playing one episode of Pong.

c51 playing Pong
2.5

2.0

1.5

1.0

0.5

Predicted V(s) Reward-to-go

losses

0.0

wins

0

200

400

600

800

1000

1200

1400

1600

episode step

Figure 12: c51 playing one episode of Pong.

-10.0

c51 value distribution during one played episode

0.5

-8.0

-6.0

0.4

-4.0

-2.0

0.3

0.0

2.0

0.2

4.0

6.0

0.1

8.0

10.0 0

200

400

600

800

1000

1200

1400

1600

0.0

episode step

Figure 13: c51 value distribution prediction during one episode of Pong.

state value

54

3

Quantile Regression DQN playing Pong

2

state value

1

state value

0

Predicted V(s)

Reward-to-go

1

losses wins

0

500

1000

1500

2000

2500

episode step

Figure 14: Quantile Regression DQN playing one episode of Pong.

Quantile Regression DQN value distribution approximation during one played episode
4

3

2

1

0

1

0

500

1000

1500

2000

2500

episode step

Figure 15: Quantile Regression DQN value distribution prediction during one episode of Pong.

Rainbow playing Pong
2.0 1.5

1.0

0.5

0.0

Predicted V(s) Reward-to-go

losses

0.5

wins

0

250

500

750

1000

1250

1500

1750

2000

episode step

Figure 16: Rainbow playing one episode of Pong (exploration turned off, i.e. all noise samples are zero).

-10.0

Rainbow value distribution during one played episode

-8.0

0.40

-6.0

0.35

-4.0

0.30

-2.0

0.25

0.0 2.0 4.0

0.20 0.15

6.0

0.10

8.0

0.05

10.0 0

250

500

750

e1p0i0s0ode step 1250

1500

1750

2000

0.00

Figure 17: Rainbow value distribution prediction during one episode of Pong (exploration turned off, i.e. all noise samples are zero).

state value

state value

55

state value

A2C playing Pong

0.5

0.0

0.5

1.0

Predicted V(s)

1.5

Reward-to-go losses

2.0 0

wins

250

500

750

1000

1250

1500

1750

2000

episode step

Figure 18: A2C playing one episode of Pong.

actions

A2C policy during one played episode

NOOP

0.8

FIRE

0.7 0.6

RIGHT

0.5

LEFT

0.4

0.3

RIGHTFIRE

0.2

LEFTFIRE

0.1

0

250

500

750

10e0p0isode step1250

1500

1750

2000

Figure 19: A2C policy distribution during one episode of Pong.

state value

PPO playing Pong

1.5

1.0

0.5

0.0

0.5

Predicted V(s)

1.0

Reward-to-go losses

wins

1.5 0

250

500

750

1000

1250

1500

1750

2000

episode step

Figure 20: PPO playing one episode of Pong.

actions

PPO policy during one played episode

NOOP

FIRE

0.8

RIGHT

0.6

LEFT

0.4

RIGHTFIRE

0.2

LEFTFIRE

0

250

500

750

1000

1250

1500

1750

2000

episode step

Figure 21: PPO policy distribution during one episode of Pong.

56

