Towards Robust Interpretability with Self-Explaining Neural Networks

arXiv:1806.07538v2 [cs.LG] 3 Dec 2018

David Alvarez-Melis CSAIL, MIT
dalvmel@mit.edu

Tommi S. Jaakkola CSAIL, MIT
tommi@csail.mit.edu

Abstract
Most recent work on interpretability of complex machine learning models has focused on estimating a posteriori explanations for previously trained models around specific predictions. Self-explaining models where interpretability plays a key role already during learning have received much less attention. We propose three desiderata for explanations in general ­ explicitness, faithfulness, and stability ­ and show that existing methods do not satisfy them. In response, we design self-explaining models in stages, progressively generalizing linear classifiers to complex yet architecturally explicit models. Faithfulness and stability are enforced via regularization specifically tailored to such models. Experimental results across various benchmark datasets show that our framework offers a promising direction for reconciling model complexity and interpretability.
1 Introduction
Interpretability or lack thereof can limit the adoption of machine learning methods in decision-critical --e.g., medical or legal-- domains. Ensuring interpretability would also contribute to other pertinent criteria such as fairness, privacy, or causality [5]. Our focus in this paper is on complex self-explaining models where interpretability is built-in architecturally and enforced through regularization. Such models should satisfy three desiderata for interpretability: explicitness, faithfulness, and stability where, for example, stability ensures that similar inputs yield similar explanations. Most post-hoc interpretability frameworks are not stable in this sense as shown in detail in Section 5.4.
High modeling capacity is often necessary for competitive performance. For this reason, recent work on interpretability has focused on producing a posteriori explanations for performance-driven deep learning approaches. The interpretations are derived locally, around each example, on the basis of limited access to the inner workings of the model such as gradients or reverse propagation [4, 18], or through oracle queries to estimate simpler models that capture the local input-output behavior [16, 2, 14]. Known challenges include the definition of locality (e.g., for structured data), identifiability [12] and computational cost (with some of these methods requiring a full-fledged optimization subroutine [24]). However, point-wise interpretations generally do not compare explanations obtained for nearby inputs, leading to unstable and often contradicting explanations [1].
A posteriori explanations may be the only option for already-trained models. Otherwise, we would ideally design the models from the start to provide human-interpretable explanations of their predictions. In this work, we build highly complex interpretable models bottom up, maintaining the desirable characteristics of simple linear models in terms of features and coefficients, without limiting performance. For example, to ensure stability (and, therefore, interpretability), coefficients in our model vary slowly around each input, keeping it effectively a linear model, albeit locally. In other words, our model operates as a simple interpretable model locally (allowing for point-wise interpretation) but not globally (which would entail sacrificing capacity). We achieve this with a regularization scheme that ensures our model not only looks like a linear model, but (locally) behaves like one.
32nd Conference on Neural Information Processing Systems (NeurIPS 2018), Montréal, Canada.

Our main contributions in this work are: · A rich class of interpretable models where the explanations are intrinsic to the model · Three desiderata for explanations together with an optimization procedure that enforces them · Quantitative metrics to empirically evaluate whether models adhere to these three principles, and
showing the advantage of the proposed self-explaining models under these metrics

2 Interpretability: linear and beyond

To motivate our approach, we start with a simple linear regression model and successively generalize

it towards the class of self-explaining models. For input features x1, . . . , xn  R, and associated

parameters 0, . . . , n  R the linear regression model is given by f (x) =

n i

ixi

+

0.

This

model

is arguably interpretable for three specific reasons: i) input features (xi's) are clearly anchored with

the available observations, e.g., arising from empirical measurements; ii) each parameter i provides

a quantitative positive/negative contribution of the corresponding feature xi to the predicted value;

and iii) the aggregation of feature specific terms ixi is additive without conflating feature-by-feature

interpretation of impact. We progressively generalize the model in the following subsections and

discuss how this mechanism of interpretation is preserved.

2.1 Generalized coefficients
We can substantially enrich the linear model while keeping its overall structure if we permit the coefficients themselves to depend on the input x. Specifically, we define (offset function omitted) f (x) = (x)T x, and choose  from a complex model class , realized for example via deep neural networks. Without further constraints, the model is nearly as powerful as--and surely no more interpretable than--any deep neural network. However, in order to maintain interpretability, at least locally, we must ensure that for close inputs x and x in Rn, (x) and (x ) should not differ significantly. More precisely, we can, for example, regularize the model in such a manner that xf (x)  (x0) for all x in a neighborhood of x0. In other words, the model acts locally, around each x0, as a linear model with a vector of stable coefficients (x0). The individual values (x0)i act as and are interpretable as coefficients of a linear model with respect to the final prediction, but adapt dynamically to the input, albeit varying slower than x. We will discuss specific regularizers so as to keep this interpretation in Section 3.

2.2 Beyond raw features ­ feature basis

Typical interpretable models tend to consider each variable (one feature or one pixel) as the funda-
mental unit which explanations consist of. However, pixels are rarely the basic units used in human
image understanding; instead, we would rely on strokes and other higher order features. We refer
to these more general features as interpretable basis concepts and use them in place of raw inputs in our models. Formally, we consider functions h(x) : X  Z  Rk, where Z is some space of interpretable atoms. Naturally, k should be small so as to keep the explanations easily digestible. Alternatives for h(·) include: (i) subset aggregates of the input (e.g., with h(x) = Ax for a boolean mask matrix A), (ii) predefined, pre-grounded feature extractors designed with expert knowledge (e.g., filters for image processing), (iii) prototype based concepts, e.g. hi(x) = x - zi for some zi  X [12], or learnt representations with specific constraints to ensure grounding [19]. Naturally, we can let h(x) = x to recover raw-input explanations if desired. The generalized model is now:

K

f (x) = (x)T h(x) = (x)ih(x)i

(1)

i=1
Since each h(x)i remains a scalar, it can still be interpreted as the degree to which a particular feature is present. In turn, with constraints similar to those discussed above (x)i remains interpretable as a local coefficient. Note that the notion of locality must now take into account how the concepts rather than inputs vary since the model is interpreted as being linear in the concepts rather than x.

2.3 Further generalization
The final generalization we propose considers how the elements (x)ih(x)i are aggregated. We can achieve a more flexible class of functions by replacing the sum in (1) by a more general aggregation

2

function g(z1, . . . , zk). Naturally, in order for this function to preserve the desired interpretation of (x) in relation to h(x), it should: i) be permutation invariant, so as to eliminate higher order uninterpretable effects caused by the relative position of the arguments, (ii) isolate the effect of individual h(x)i's in the output (e.g., avoiding multiplicative interactions between them), and (iii) preserve the sign and relative magnitude of the impact of the relevance values (x)i. We formalize these intuitive desiderata in the next section.
Note that we can naturally extend the framework presented in this section to multivariate functions with range in Y  Rm, by considering i : X  Rm, so that i(x)  Rm is a vector corresponding to the relevance of concept i with respect to each of the m output dimensions. For classification, however, we are mainly interested in the explanation for the predicted class, i.e., y^(x) for y^ = argmaxy p(y|x).

3 Self-explaining models

We now formalize the class of models obtained through subsequent generalization of the simple
linear predictor in the previous section. We begin by discussing the properties we wish to impose on  in order for it to act as coefficients of a linear model on the basis concepts h(x). The intuitive notion of robustness discussed in Section 2.2 suggests using a condition bounding (x) - (y) with L h(x) - h(y) for some constant L. Note that this resembles, but is not exactly equivalent to, Lipschitz continuity, since it bounds 's variation with respect to a different--and indirect--measure of change, provided by the geometry induced implicitly by h on X . Specifically,
Definition 3.1. We say that a function f : X  Rn  Rm is difference-bounded by h : X  Rn  Rk if there exists L  R such that f (x) - f (y)  L h(x) - h(y) for every x, y  X .

Imposing such a global condition might be undesirable in practice. The data arising in applications often lies on low dimensional manifolds of irregular shape, so a uniform bound might be too restrictive. Furthermore, we specifically want  to be consistent for neighboring inputs. Thus, we seek instead a local notion of stability. Analogous to the local Lipschitz condition, we propose a pointwise, neighborhood-based version of Definition 3.1:
Definition 3.2. f : X  Rn  Rm is locally difference bounded by h : X  Rn  Rk if for every x0 there exist  > 0 and L  R such that x - x0 <  implies f (x) - f (x0)  L h(x) - h(x0) .

Note that, in contrast to Definition 3.1, this second notion of stability allows L (and ) to depend on x0, that is, the "Lipschitz" constant can vary throughout the space. With this, we are ready to define the class of functions which form the basis of our approach.
Definition 3.3. Let x  X  Rn and Y  Rm be the input and output spaces. We say that f : X  Y is a self-explaining prediction model if it has the form

f (x) = g 1(x)h1(x), . . . , k(x)hk(x)

(2)

where:

P1) g is monotone and completely additively separable

P2)

For every zi

:= i(x)hi(x), g satisfies

g zi

0

P3)  is locally difference bounded by h

P4) hi(x) is an interpretable representation of x

P5) k is small.

In that case, for a given input x, we define the explanation of f (x) to be the set Ef (x)  {(hi(x), i(x))}ki=1 of basis concepts and their influence scores.

Besides the linear predictors that provided a starting point in Section 2, well-known families such as
generalized linear models and Nearest-neighbor classifiers are contained in this class of functions. However, the true power of models described in Definition 3.3 comes when (·) (and potentially h(·)) are realized by architectures with large modeling capacity, such as deep neural networks. When (x) is realized with a neural network, we refer to f as a self-explaining neural network (SENN). If g depends on its arguments in a continuous way, f can be trained end-to-end with back-propagation. Since our aim is maintaining model richness even in the case where the hi are chosen to be trivial input feature indicators, we rely predominantly on  for modeling capacity, realizing it with larger,
higher-capacity architectures.

3

It remains to discuss how the properties (P1)-(P5) in Definition 3.3 are to be enforced. The first two depend entirely on the choice of aggregating function g. Besides trivial addition, other options include affine functions g(z1, . . . , zk) = i Aizi where Ai's values are constrained to be positive. On the other hand, the last two conditions in Definition 3.3 are application-dependent: what and how
many basis concepts are adequate should be informed by the problem and goal at hand.

The only condition in Definition 3.3 that warrants further discussion is (P3): the stability of  with
respect to h. For this, let us consider what f would look like if the i's were indeed (constant) parameters. Looking at f as a function of h(x), i.e. f (x) = g(h(x)), let z = h(x). Using the chain
rule we get xf = zf · Jxh, where Jxh denotes the Jacobian of h (with respect to x). At a given point x0, we want (x0) to behave as the derivative of f with respect to the concept vector h(x) around x0, i.e., we seek (x0)  zf . Since this is hard to enforce directly, we can instead plug this ansatz in xf = zf · Jxh to obtain a proxy condition:

L(f (x)) := xf (x) - (x) Jxh(x)  0

(3)

All three terms in L(f ) can be computed, and when using differentiable architectures h(·) and (·), we obtain gradients with respect to (3) through automatic differentiation and thus use it as a

regularization term in the optimization objective. With this, we obtain a gradient-regularized objective
of the form Ly(f (x), y) + L(f ), where the first term is a classification loss and  a parameter that trades off performance against stability--and therefore, interpretability-- of (x).

4 Learning interpretable basis concepts

Raw input features are the natural basis for interpretability when the input is low-dimensional and individual features are meaningful. For high-dimensional inputs, raw features (such as individual pixels in images) often lead to noisy explanations that are sensitive to imperceptible artifacts in the data, tend to be hard to analyze coherently and not robust to simple transformations such as constant shifts [9]. Furthermore, the lack of robustness of methods that relies on raw inputs is amplified for high-dimensional inputs, as shown in the next section. To avoid some of these shortcomings, we can instead operate on higher level features. In the context of images, we might be interested in the effect of textures or shapes--rather than single pixels--on predictions. For example, in medical image processing higher-level visual aspects such as tissue ruggedness, irregularity or elongation are strong predictors of cancerous tumors, and are among the first aspects that doctors look for when diagnosing, so they are natural "units" of explanation.

Ideally, these basis concepts would be informed by expert knowledge, such as the doctor-provided features mentioned above. However, in cases where such prior knowledge is not available, the basis concepts could be learnt instead. Interpretable concept learning is a challenging task in its own right [8], and as other aspects of interpretability, remains ill-defined. We posit that a reasonable minimal set of desiderata for interpretable concepts is: (i) Fidelity: the representation of x in terms of concepts should preserve relevant information, (ii) Diversity: inputs should be representable with few non-overlapping concepts, and (iii) Grounding: concepts should have an immediate humanunderstandable interpretation.

Here, we enforce these conditions upon the concepts learnt by SENN by: (i) training h as an autoencoder, (ii) enforcing diversity through sparsity and (iii) providing interpretation on the concepts

by prototyping (e.g., by providing a small set of training examples that maximally activate each
concept). Learning of h is done end-to-end in conjunction with the rest of the model. If we denote by hdec( · ) : Rk  Rn the decoder associated with h, and x^ := hdec(h(x)) the reconstruction of x, we use an additional penalty Lh(x, x^) on the objective, yielding the loss:

Ly(f (x), y) + L(f ) + Lh(x, x^)

(4)

Achieving (iii), i.e., the grounding of h(x), is more subjective. A simple approach consists of
representing each concept by the elements in a sample of data that maximize their value, that is, we can represent concept i through the set Xi = argmaxX^X,|X^|=l xX^ h(x)i where l is small. Similarly, one could construct (by optimizing h) synthetic inputs that maximally activate each concept (and do not activate others), i.e., argmaxxX hi(x) - j=i hj(x). Alternatively, when available, one might want to represent concepts via their learnt weights--e.g., by looking at the filters associated with each concept in a CNN-based h( · ). In our experiments, we use the first of these approaches
(i.e., using maximally activated prototypes), leaving exploration of the other two for future work.

4

reconstruction loss
concept encoder relevance parametrizer

concepts

classification loss
class label aggregator
explanation

relevances

input x

robustness loss
Figure 1: A SENN consists of three components: a concept encoder (green) that transforms the input into a small set of interpretable basis features; an input-dependent parametrizer (orange) that generates relevance scores; and an aggregation function that combines to produce a prediction. The robustness loss on the parametrizer encourages the full model to behave locally as a linear function on h(x) with parameters (x), yielding immediate interpretation of both concepts and relevances.

5 Experiments
The notion of interpretability is notorious for eluding easy quantification [5]. Here, however, the motivation in Section 2 produced a set of desiderata according to which we can validate our models. Throughout this section, we base the evaluation on four main criteria. First and foremost, for all datasets we investigate whether our models perform on par with their non-modular, non interpretable counterparts. After establishing that this is indeed the case, we focus our evaluation on the interpretability of our approach, in terms of three criteria:
(i) Explicitness/Intelligibility: Are the explanations immediate and understandable? (ii) Faithfulness: Are relevance scores indicative of "true" importance? (iii) Stability: How consistent are the explanations for similar/neighboring examples?
Below, we address these criteria one at a time, proposing qualitative assessment of (i) and quantitative metrics for evaluating (ii) and (iii).
5.1 Dataset and Methods
Datasets We carry out quantitative evaluation on three classification settings: (i) MNIST digit recognition, (ii) benchmark UCI datasets [13] and (iii) Propublica's COMPAS Recidivism Risk Score datasets.1 In addition, we provide some qualitative results on CIFAR10 [10] in the supplement (§A.5). The COMPAS data consists of demographic features labeled with criminal recidivism ("relapse") risk scores produced by a private company's proprietary algorithm, currently used in the Criminal Justice System to aid in bail granting decisions. Propublica's study showing racial-biased scores sparked a flurry of interest in the COMPAS algorithm both in the media and in the fairness in machine learning community [25, 7]. Details on data pre-processing for all datasets are provided in the supplement.
Comparison methods. We compare our approach against various interpretability frameworks: three popular "black-box" methods; LIME [16], kernel Shapley values (SHAP, [14]) and perturbationbased occlusion sensitivity (OCCLUSION) [26]; and various gradient and saliency based methods: gradient×input (GRAD*INPUT) as proposed by Shrikumar et al. [20], saliency maps (SALIENCY) [21], Integrated Gradients (INT.GRAD) [23] and ( )-Layerwise Relevance Propagation (E-LRP) [4].
1github.com/propublica/compas-analysis/
5

Input

Saliency Grad*Input Int.Grad.

e-LRP

Occlusion

LIME

SENN

Cpt 1 Cpt 2 Cpt 3 Cpt 4 Cpt 5
C1 C2 C3 C4 C5

-100 0

C1 C2 C3 C4 C5
100

Figure 2: A comparison of traditional input-based explanations (positive values depicted in red) and SENN's concept-based ones for the predictions of an image classification model on MNIST. The explanation for SENN includes a characterization of concepts in terms of defining prototypes.

5.2 Explicitness/Intelligibility: How understandable are SENN's explanations?
When taking h(x) to be the identity, the explanations provided by our method take the same surface level (i.e, heat maps on inputs) as those of common saliency and gradient-based methods, but differ substantially when using concepts as a unit of explanations (i.e., h is learnt). In Figure 2 we contrast these approaches in the context of digit classification interpretability. To highlight the difference, we use only a handful of concepts, forcing the model encode digits into meta-types sharing higher level information. Naturally, it is necessary to describe each concept to understand what it encodes, as we do here through a grid of the most representative prototypes (as discussed in §4), shown here in Fig. 2, right. While pixel-based methods provide more granular information, SENN's explanation is (by construction) more parsimonious. For both of these digits, Concept 3 had a strong positive influence towards the prediction. Indeed, that concept seems to be associated with diagonal strokes (predominantly occurring in 7's), which both of these inputs share. However, for the second prediction there is another relevant concept, C4, which is characterized largely by stylized 2's, a concept that in contrast has negative influence towards the top row's prediction.

1.0 0.5 0.0 -0.5

SHAP LIME SENN
ionosphere

heart

diabetes

Dataset

abalone

1.00

1e 4

0.75

2.0

0.50

1.5

0.25

0.00

1.0

0.25

0.5

0.50

0.75

0.0

1.00 1 2 3 4 5 6 7 8 9 C1o0nc1e1pt12Ind13ex14 15 16 17 18 19 20 21

Figure 3: Left: Aggregated correlation between feature relevance scores and true importance, as described in Section 5.3. Right: Faithfulness evaluation SENN on MNIST with learnt concepts.

Faithfulness Estimate
Feature Relevance (x)i Probability Drop

5.3 Faithfulness: Are "relevant" features truly relevant?
Assessing the correctness of estimated feature relevances requires a reference "true" influence to compare against. Since this is rarely available, a common approach to measuring the faithfulness of relevance scores with respect to the model they are explaining relies on a proxy notion of importance: observing the effect of removing features on the model's prediction. For example, for a probabilistic classification model, we can obscure or remove features, measure the drop in probability of the predicted class, and compare against the interpreter's own prediction of relevance [17, 3]. Here, we further compute the correlations of these probability drops and the relevance scores on various points, and show the aggregate statistics in Figure 3 (left) for LIME, SHAP and SENN (without learnt concepts) on various UCI datasets. We note that this evaluation naturally extends to the case where the concepts are learnt (Fig. 3, right). The additive structure of our model allows for removal of features h(x)i--regardless of their form, i.e., inputs or concepts--simply by setting their coefficients i to zero. Indeed, while feature removal is not always meaningful for other predictions models (i.e., one must replace pixels with black or averaged values to simulate removal in a CNN), the definition of our model allows for targeted removal of features, rendering an evaluation based on it more reliable.
6

Original

Saliency

Grad*Input

Int.Grad.

e-LRP

Occlusion

LIME

SENN

P(7)=1.0000e+00

L^ = 1.45

L^ = 1.36

L^ = 0.91

L^ = 1.35

L^ = 1.66

L^ = 6.23

L^ = 0.01

Figure 4: Explaining a CNN's prediction on an true MNIST digit (top row) and a perturbed version
with added Gaussian noise. Although the model's prediction is mostly unaffected by this perturbation (change in prediction probability  10-4), the explanations for post-hoc methods vary considerably.

Relative Discrete Lipschitz Estimate Prediction Accuacy
Relative Cont. Lipschitz Estimate

85

0.5

84

0.4

83

82

0.3 81

0.2

80

0.1

79

78

0.0 77

1e-04

1e-03

1e-02

1e-01

1e+00

Regularization Strength 

(A) SENN on COMPAS

1.0

100.0

97.5 0.8
95.0

0.6

92.5

90.0

0.4

87.5

85.0 0.2
82.5

0.0

80.0

0e+001e-08 1e-07 1e-06 1e-05 1e-04 1e-03 1e-02 1e-011e+00

Regularization Strength 

(B) SENN on BREAST-CANCER

Prediction Accuacy

Lipshitz Estimate

Lipshitz Estimate

100 10-4
diabetes 101

UCI Datasets

heart

SHAP LIME SENN
yeast ionosphere abalone
MNIST

10-1 LIME SaliencyGrad*Input e-LRP Int.Grad.Occlusion SENN

(C) All methods on UCI/MNIST

Figure 5: (A/B): Effect of regularization on SENN's performance. (C): Robustness comparison.

5.4 Stability: How coherent are explanations for similar inputs?

As argued throughout this work, a crucial property that interpretability methods should satisfy to
generate meaningful explanations is that of robustness with respect to local perturbations of the input.
Figure 4 shows that this is not the case for popular interpretability methods; even adding minimal
white noise to the input introduces visible changes in the explanations. But to formally quantify this phenomenon, we appeal again to Definition 3.2 as we seek a worst-case (adversarial) notion of robustness. Thus, we can quantify the stability of an explanation generation model fexpl(x), by estimating, for a given input x and neighborhood size :

L^(xi) = argmax
xj B (xi)

fexpl(xi) - fexpl(xj ) 2 h(xi) - h(xj) 2

(5)

where for SENN we have fexpl(x) := (x), and for raw-input methods we replace h(x) with x, turning (5) into an estimation of the Lipschitz constant (in the usual sense) of fexpl. We can directly estimate this quantity for SENN since the explanation generation is end-to-end differentiable with
respect to concepts, and thus we can rely on direct automatic differentiation and back-propagation to optimize for the maximizing argument xj, as often done for computing adversarial examples for neural networks [6]. Computing (5) for post-hoc explanation frameworks is, however, much
more challenging, since they are not end-to-end differentiable. Thus, we need to rely on black-box optimization instead of gradient ascent. Furthermore, evaluation of fexpl for methods like LIME and SHAP is expensive (as it involves model estimation for each query), so we need to do so with a
restricted evaluation budget. In our experiments, we rely on Bayesian Optimization [22].

The continuous notion of local stability (5) might not be suitable for discrete inputs or settings
where adversarial perturbations are overly restrictive (e.g., when the true data manifold has regions
of flatness in some dimensions). In such cases, we can instead define a (weaker) sample-based notion of stability. For any x in a finite sample X = {xi}ni=1, let its -neighborhood within X be N (x) = {x  X | x - x  }. Then, we consider an alternative version of (5) with N (x) in lieu of B (xi). Unlike the former, its computation is trivial since it involves a finite sample.

7

We first use this evaluation metric to validate the usefulness of the proposed gradient regularization approach for enforcing explanation robustness. The results on the COMPAS and BREAST-CANCER datasets (Fig. 5 A/B), show that there is a natural tradeoff between stability and prediction accuracy through the choice of regularization parameter . Somewhat surprisingly, we often observe an boost in performance brought by the gradient penalty, likely caused by the additional regularization it imposes on the prediction model. We observe a similar pattern on MNIST (Figure 8, in the Appendix). Next, we compare all methods in terms of robustness on various datasets (Fig. 5C), where we observe SENN to consistently and substantially outperform all other methods in this metric.
It is interesting to visualize the inputs and corresponding explanations that maximize criterion (5) ­or its discrete counterpart, when appropriate­ for different methods and datasets, since these succinctly exhibit the issue of lack of robustness that our work seeks to address. We provide many such "adversarial" examples in Appendix A.7. These examples show the drastic effect that minimal perturbations can have on most methods, particularly LIME and SHAP. The pattern is clear: most current interpretability approaches are not robust, even when the underlying model they are trying to explain is. The class of models proposed here offers a promising avenue to remedy this shortcoming.
6 Related Work
Interpretability methods for neural networks. Beyond the gradient and perturbation-based methods mentioned here [21, 26, 4, 20, 23], various other methods of similar spirit exist [15]. These methods have in common that they do not modify existing architectures, instead relying on a-posteriori computations to reverse-engineer importance values or sensitivities of inputs. Our approach differs both in what it considers the units of explanation--general concepts, not necessarily raw inputs--and how it uses them, intrinsically relying on the relevance scores it produces to make predictions, obviating the need for additional computation. More related to our approach is the work of Lei et al. [11] and Al-Shedivat et al. [19]. The former proposes a neural network architecture for text classification which "justifies" its predictions by selecting relevant tokens in the input text. But this interpretable representation is then operated on by a complex neural network, so the method is transparent as to what aspect of the input it uses for prediction, but not how it uses it. Contextual Explanation Networks [19] are also inspired by the goal of designing a class of models that learns to predict and explain jointly, but differ from our approach in their formulation (through deep graphical models) and realization of the model (through variational autoencoders). Furthermore, our approach departs from that work in that we explicitly enforce robustness with respect to the units of explanation and we formulate concepts as part of the explanation, thus requiring them to be grounded and interpretable.
Explanations through concepts and prototypes. Li et al. [12] propose an interpretable neural network architecture whose predictions are based on the similarity of the input to a small set of prototypes, which are learnt during training. Our approach can be understood as generalizing this approach beyond similarities to prototypes into more general interpretable concepts, while differing in how these higher-level representation of the inputs are used. More similar in spirit to our approach of explaining by means of learnable interpretable concepts is the work of Kim et al. [8]. They propose a technique for learning concept activation vectors representing human-friendly concepts of interest, by relying on a set of human-annotated examples characterizing these. By computing directional derivatives along these vectors, they gauge the sensitivity of predictors with respect to semantic changes in the direction of the concept. Their approach differs from ours in that it explains a (fixed) external classifier and uses a predefined set of concepts, while we learn both of these intrinsically.
7 Discussion and future work
Interpretability and performance currently stand in apparent conflict in machine learning. Here, we make progress towards showing this to be a false dichotomy by drawing inspiration from classic notions of interpretability to inform the design of modern complex architectures, and by explicitly enforcing basic desiderata for interpretability--explicitness, faithfulness and stability--during training of our models. We demonstrate how the fusion of these ideas leads to a class of rich, complex models that are able to produce robust explanations, a key property that we show is missing from various popular interpretability frameworks. There are various possible extensions beyond the model choices discussed here, particularly in terms of interpretable basis concepts. As for applications, the natural next step would be to evaluate interpretable models in more complex domains, such as larger image datasets, speech recognition or natural language processing tasks.
8

Acknowledgments
The authors would like to thank the anonymous reviewers and Been Kim for helpful comments. The work was partially supported by an MIT-IBM grant on deep rationalization and by Graduate Fellowships from Hewlett Packard and CONACYT.
References
[1] D. Alvarez-Melis and T. S. Jaakkola. "On the Robustness of Interpretability Methods". In: Proceedings of the 2018 ICML Workshop in Human Interpretability in Machine Learning. 2018. arXiv: 1806.08049.
[2] D. Alvarez-Melis and T. S. Jaakkola. "A causal framework for explaining the predictions of black-box sequence-to-sequence models". In: Conference on Empirical Methods in Natural Language Processing (EMNLP). 2017, pp. 412­421.
[3] L. Arras, F. Horn, G. Montavon, K.-R. Müller, and W. Samek. ""What is relevant in a text document?": An interpretable machine learning approach". In: PLos ONE 12.8 (2017), pp. 1­ 23.
[4] S. Bach, A. Binder, G. Montavon, F. Klauschen, K. R. Müller, and W. Samek. "On pixel-wise explanations for non-linear classifier decisions by layer-wise relevance propagation". In: PLos ONE 10.7 (2015).
[5] F. Doshi-Velez and B. Kim. "Towards a Rigorous Science of Interpretable Machine Learning". In: ArXiv e-prints Ml (2017), pp. 1­12. arXiv: 1702.08608.
[6] I. J. Goodfellow, J. Shlens, and C. Szegedy. "Explaining and Harnessing Adversarial Examples". In: International Conference on Learning Representations. 2015.
[7] N. Grgic-Hlaca, M. B. Zafar, K. P. Gummadi, and A. Weller. "Beyond Distributive Fairness in Algorithmic Decision Making: Feature Selection for Procedurally Fair Learning". In: AAAI Conference on Artificial Intelligence. 2018.
[8] B. Kim, M. Wattenberg, J. Gilmer, C. Cai, J. Wexler, F. Viegas, and R. Sayres. " Interpretability Beyond Feature Attribution: Quantitative Testing with Concept Activation Vectors (TCAV) ". In: International Conference on Machine Learning (ICML). 2018.
[9] P.-J. Kindermans, S. Hooker, J. Adebayo, M. Alber, K. Schütt, S. Dähne, D. Erhan, and B. Kim. "The (Un)reliability of saliency methods". In: NIPS workshop on Explaining and Visualizing Deep Learning (2017).
[10] A. Krizhevsky. Learning multiple layers of features from tiny images. Tech. rep. Citeseer, 2009.
[11] T. Lei, R. Barzilay, and T. Jaakkola. "Rationalizing Neural Predictions". In: Conference on Empirical Methods in Natural Language Processing (EMNLP). 2016, pp. 107­117. arXiv: 1606.04155.
[12] O. Li, H. Liu, C. Chen, and C. Rudin. "Deep Learning for Case-Based Reasoning through Prototypes: A Neural Network that Explains Its Predictions". In: AAAI Conference on Artificial Intelligence. 2018. arXiv: 1710.04806.
[13] M. Lichman and K. Bache. UCI Machine Learning Repository. 2013.
[14] S. Lundberg and S.-I. Lee. "A unified approach to interpreting model predictions". In: Advances in Neural Information Processing Systems 30. 2017, pp. 4768­4777. arXiv: 1705.07874.
[15] G. Montavon, W. Samek, and K.-R. Müller. "Methods for interpreting and understanding deep neural networks". In: Digital Signal Processing (2017).
9

[16] M. T. Ribeiro, S. Singh, and C. Guestrin. ""Why Should I Trust You?": Explaining the Predictions of Any Classifier". In: ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD). New York, NY, USA: ACM, 2016, pp. 1135­1144. arXiv: 1602.04938.
[17] W. Samek, A. Binder, G. Montavon, S. Lapuschkin, and K. R. Müller. "Evaluating the visualization of what a deep neural network has learned". In: IEEE Transactions on Neural Networks and Learning Systems 28.11 (2017), pp. 2660­2673. arXiv: 1509.06321.
[18] R. R. Selvaraju, A. Das, R. Vedantam, M. Cogswell, D. Parikh, and D. Batra. "Grad-cam: Why did you say that? visual explanations from deep networks via gradient-based localization". In: ICCV. 2017. arXiv: 1610.02391.
[19] M. Al-Shedivat, A. Dubey, and E. P. Xing. "Contextual Explanation Networks". In: arXiv preprint arXiv:1705.10301 (2017).
[20] A. Shrikumar, P. Greenside, and A. Kundaje. "Learning Important Features Through Propagating Activation Differences". In: International Conference on Machine Learning (ICML). Ed. by D. Precup and Y. W. Teh. Vol. 70. Proceedings of Machine Learning Research. PMLR, June 2017, pp. 3145­3153. arXiv: 1704.02685.
[21] K. Simonyan, A. Vedaldi, and A. Zisserman. "Deep inside convolutional networks: Visualising image classification models and saliency maps". In: International Conference on Learning Representations (Workshop Track). 2014.
[22] J. Snoek, H. Larochelle, and R. P. Adams. "Practical Bayesian Optimization of Machine Learning Algorithms". In: Advances in Neural Information Processing Systems (NIPS). 2012.
[23] M. Sundararajan, A. Taly, and Q. Yan. "Axiomatic attribution for deep networks". In: arXiv preprint arXiv:1703.01365 (2017).
[24] J. Yosinski, J. Clune, A. Nguyen, T. Fuchs, and H. Lipson. "Understanding neural networks through deep visualization". In: arXiv preprint arXiv:1506.06579 (2015).
[25] M. B. Zafar, I. Valera, M. Rodriguez, K. Gummadi, and A. Weller. "From parity to preferencebased notions of fairness in classification". In: Advances in Neural Information Processing Systems (NIPS). 2017, pp. 228­238.
[26] M. D. Zeiler and R. Fergus. "Visualizing and understanding convolutional networks". In: European conference on computer vision. Springer. 2014, pp. 818­833.
10

A Appendix
A.1 Data Processing
MNIST/CIFAR10. We use the original MNIST and CIFAR10 datasets with standard mean and variance normalization, using 10% of the training split for validation. UCI. We use standard mean and variance scaling on all datasets and use (80%, 10%, 10%) train, validation and test splits. COMPAS We preprocess the data by rescaling the ordinal variable Number_of_priors to the range [0, 1]. The data contains several inconsistent examples, so we filter out examples whose label differs from a strong (80%) majority of other identical examples.

A.2 Architectures
The architectures used for SENN in each task are summarized below, where CL/FC stand for convolutional and fully-connected layers, respectively, and c denotes the number of concepts. Note that in every case we use more complex architectures for the parametrizer than the concept encoder.

h( · )
( · ) g( · )

COMPAS/UCI
h(x) = x FC(10, 5, 5, 1)
sum

MNIST
CL(10, 20)  FC(c) CL(10, 20)  FC(c · 10)
sum

CIFAR10
CL(10, 20)  FC(c) CL(26, 27, 28, 29, 29)  FC(28, 27, c · 10)
sum

In all cases, we train using the Adam optimizer with initial learning rate l = 2 × 10-4 and, whenever learning h( · ), sparsity strength parameter  = 2 × 10-5.

A.3 Predictive Performance of SENN
MNIST. We observed that any reasonable choice of parameters in our model leads to very low test prediction error (< 1.3%). In particular, taking  = 0 (the unregularized model) yields an unconstrained model with an architecture slightly modified from LeNet, for which we obtain a 99.11% test set accuracy (slightly above typical results for a vanilla LeNet). On the other hand, for the most extreme regularization value used ( = 1) we obtain an accuracy of 98.7%. All other values interpolate between these two extremes. In particular, the actual model used in Figure 2 obtained 99.03% accuracy, just slightly below the unregularized one.
UCI. As with previous experiments, our models are able to achieve competitive performance on all UCI datasets for most parameter configurations.
COMPAS. With default parameters, our SENN model achieves an accuracy of 82.02% on the test set, compared to 78.54% for a baseline logistic classification model. The relatively low performance of both methods is due to the problem of inconsistent examples mentioned above.
CIFAR10. With default parameters, our SENN model achieves an accuracy of 78.56% on the test set, which is on par for models of that size trained with some regularization method (our method requires no further regularization).

A.4 Implementation and dependency details
We used the implementations of LIME and SHAP provided by the authors. Unless otherwise stated, we use default parameter configurations and n = 100 estimation samples for these two methods. For the rest of the interpretability frameworks, we use the publicly available DeepExplain2 toolbox.
In our experiments, we compute L^i for SENN models by minimizing a Lagrangian relaxation of (5) through backpropagation. For all other methods, we rely instead on Bayesian optimization, via the skopt3 toolbox, using a budget of 40 function calls for LIME (due to higher compute time) and 200 for all other methods.
2github.com/marcoancona/DeepExplain 3scikit-optimize.github.io

11

A.5 Qualitative results on CIFAR10

Input Saliency Grad*Input Int.Grad. e-LRP Occlusion SENN C1 C2 C3 C4 C5

C1 C2 C3 C4 C5

C1 C2 C3 C4 C5

C1 C2 C3 C4 C5

C1 C2 C3 C4 C5

C1

C2

Cpt 1 Cpt 2 Cpt 3 Cpt 4 Cpt 5

C3 C4 C5

C1 C2 C3 C4 C5

C1

C2

Cpt 1 Cpt 2 Cpt 3 Cpt 4 Cpt 5

C3 C4 C5

Cpt 1 Cpt 2 Cpt 3 Cpt 4 Cpt 5

Figure 6: Explaining a CNN classifier on CIFAR10. Top: The attribution scores for various interpretability methods. Bottom: The concepts learnt by this SENN instance on CIFAR10 are characterized by conspicuous dominating colors and patterns (e.g., stripes and vertical lines in Concept 5, shown in the right-most column). All examples are correctly predicted by SENN, except the last one, in which it predicts ship instead of deer. The explanation provided by the model suggests it was fooled by a blue background which speaks against the deer class.
12

A.6 Additional Results on Stability

Original

Saliency

Grad*Input

Int.Grad.

e-LRP

Occlusion

LIME

SENN

P(7)=1.0000e+00

L^ = 1.61

L^ = 1.50

L^ = 1.13

L^ = 1.48

L^ = 1.75

L^ = 7.15

L^ = 0.01

P(7)=9.9999e-01

L^ = 1.42

L^ = 1.44

L^ = 1.04

L^ = 1.43

L^ = 1.73

L^ = 7.27

L^ = 0.01

P(7)=1.0000e+00

L^ = 1.51

L^ = 1.48

L^ = 0.97

L^ = 1.46

L^ = 1.60

L^ = 7.64

L^ = 0.01

P(7)=9.9999e-01

L^ = 1.61

L^ = 1.49

L^ = 1.06

L^ = 1.48

L^ = 1.83

L^ = 8.09

L^ = 0.02

P(7)=9.9999e-01

L^ = 1.52

L^ = 1.50

L^ = 1.05

L^ = 1.49

L^ = 1.90

L^ = 6.37

L^ = 0.01

P(7)=9.9999e-01

L^ = 1.86

L^ = 1.71

L^ = 1.28

L^ = 1.69

L^ = 1.90

L^ = 5.96

L^ = 0.01

Figure 7: The effect of gaussian perturbations on the explanations of various interpretability frame-
works. For every explainer fexpl, we show the relative effect of the perturbation in the explanation: L^ = fexpl(x) - fexpl(x~) / x - x~ .

Original

Perturbation 1

Perturbation 2

Perturbation 3

Perturbation 4

PertOuribgaintiaoln 5 Max Perturbation

C0
C1 Original
C2 C3 C4 C5

C0
C1 Perturbation 1

C0
C1 Perturbation 2

C0
C1 Perturbation 3

C0
C1 Perturbation 4

CC00 CC11

Perturbation 5

C0 C1

C2

C2

C2

C2

CC22

C2

C3

C3

C3

C3

CC33

C3

C4

C4

C4

C4

CC44

C4

C5

C5

C5

C5

CC55

C5

100 0 100 100 0 100 100 0 100 100 0 100 100 0 100 110000 00 100 100 0 100

C0

C0

C0

C0

C0

C0

C1

C1

C1

C1

C1

C1

C2

C2

C2

C2

C2

C2

C3

C3

C3

C3

C3

C3

C4

C4

C4

C4

C4

C4

C5

C5

C5

C5

C5

C5

100 0 100 100 0 100 100 0 100 100 0 100 100 0 100 100 0 100

Figure 8: Left: The effect of gradient-regularization on explanation stability. The unregularized
version (second row) produces highly variable, sometimes contradictory, explanations for slight perturbations of the same input. Regularization ( = 2 × 10-4) leads to more robust explanations.

13

A.7 Adversarial Examples For Interpretability

We now show various examples inputs and their adversarial perturbation (accoring to (5)) on various datasets.

Relevance Score (x) (Scaled)

Two yr Recidivism Number of Priors
Age Above FourtyFive Age Below TwentyFive
African American Asian
Hispanic Native American
Other Female Misdemeanor (Constant)

-100

-50

0

50

100

Relevance Score (x) (Scaled)

Two yr Recidivism Number of Priors
Age Above FourtyFive Age Below TwentyFive
African American Asian
Hispanic Native American
Other Female Misdemeanor (Constant)

-100

-50

0

50

100

(A) Unregularized SENN ( = 0)

Relevance Score (x) (Scaled)

Two yr Recidivism Number of Priors
Age Above FourtyFive Age Below TwentyFive
African American Asian
Hispanic Native American
Other Female Misdemeanor (Constant)

-100

-50

0

50

100

Relevance Score (x) (Scaled)

Two yr Recidivism Number of Priors
Age Above FourtyFive Age Below TwentyFive
African American Asian
Hispanic Native American
Other Female Misdemeanor (Constant)

-100

-50

0

50

100

(B) Gradient-regularized SENN ( = 5 × 10-2)

Figure 9: Prediction explanation for two individuals differing in only on the protected variable (African_American) in the COMPAS dataset. The method trained with gradient regularization (column B) yields more stable explanations, consistent with each other for these two individuals.

Input Value

Two_yr_Recidivism

0.00

Number_of_Priors

0.32

Age_Above_FourtyFive

0.00

Age_Below_TwentyFive

0.00

African_American

1.00

Asian

0.00

Hispanic

0.00

Native_American

0.00

Other

0.00

Female

0.00

Misdemeanor

0.00

Two_yr_Recidivism Number_of_Priors Age_Above_FourtyFive Age_Below_TwentyFive African_American
Asian Hispanic Native_American
Other Female Misdemeanor

Input Value

Two_yr_Recidivism

0.00

Number_of_Priors

0.36

Age_Above_FourtyFive

0.00

Age_Below_TwentyFive

0.00

African_American

1.00

Asian

0.00

Hispanic

0.00

Native_American

0.00

Other

0.00

Female

0.00

Misdemeanor

0.00

Two_yr_Recidivism Number_of_Priors Age_Above_FourtyFive Age_Below_TwentyFive African_American
Asian Hispanic Native_American
Other Female Misdemeanor

Explanation
0.1 0.0 0.1 Explanation
0.1 0.0 0.1

(A) SHAP (L = 6.78)

Input Value

Two_yr_Recidivism

0.00

Number_of_Priors

0.32

Age_Above_FourtyFive

0.00

Age_Below_TwentyFive

0.00

African_American

1.00

Asian

0.00

Hispanic

0.00

Native_American

0.00

Other

0.00

Female

0.00

Misdemeanor

0.00

Two_yr_Recidivism Number_of_Priors Age_Above_FourtyFive Age_Below_TwentyFive African_American
Asian Hispanic Native_American
Other Female Misdemeanor

Input Value

Two_yr_Recidivism

0.00

Number_of_Priors

0.36

Age_Above_FourtyFive

0.00

Age_Below_TwentyFive

0.00

African_American

1.00

Asian

0.00

Hispanic

0.00

Native_American

0.00

Other

0.00

Female

0.00

Misdemeanor

0.00

Two_yr_Recidivism Number_of_Priors Age_Above_FourtyFive Age_Below_TwentyFive African_American
Asian Hispanic Native_American
Other Female Misdemeanor

Explanation
0.1 0.0 0.1 Explanation
0.1 0.0 0.1

(B) LIME (L = 8.36)

Input Value

Two_yr_Recidivism

0.00

Number_of_Priors

0.23

Age_Above_FourtyFive

0.00

Age_Below_TwentyFive

1.00

African_American

1.00

Asian

0.00

Hispanic

0.00

Native_American

0.00

Other

0.00

Female

0.00

Misdemeanor

0.00

Two_yr_Recidivism Number_of_Priors Age_Above_FourtyFive Age_Below_TwentyFive African_American
Asian Hispanic Native_American
Other Female Misdemeanor

Input Value

Two_yr_Recidivism

0.00

Number_of_Priors

0.28

Age_Above_FourtyFive

0.00

Age_Below_TwentyFive

1.00

African_American

1.00

Asian

0.00

Hispanic

0.00

Native_American

0.00

Other

0.00

Female

0.00

Misdemeanor

0.00

Two_yr_Recidivism Number_of_Priors Age_Above_FourtyFive Age_Below_TwentyFive African_American
Asian Hispanic Native_American
Other Female Misdemeanor

Explanation
0.00 0.25 Explanation
0.00 0.25

(C) SENN (L = 0.57)

Figure 10: Adversarial examples (i.e., the maximizer argument in the discrete version of (5)) for SHAP, LIME and SENN on COMPAS. Both are true examples are from the test fold.

14

Original

Perturbed

Original

Perturbed

Original

Perturbed

L = 0.48

L = 0.45

L = 4.79

(A) SALIENCY

Original

Perturbed

(B) OCCLUSION

Original

Perturbed

(C) LIME

Original

Perturbed

L = 0.51

L = 0.49

L = 0.37

(D) E-LRP

(E) GRAD*INPUT

Original

Perturbed

L = 0.48

(F) INT.GRAD

(G) SALIENCY
Figure 11: Adversarial examples (i.e., the maximizer argument in (5)) for various interpretability methods on MNIST.

15

Input Value
X0 -0.5 X0 X1 -0.2 X1 X2 0.6 X2 X3 -0.3 X3 X4 0.1 X4 X5 -0.8 X5 X6 -0.5 X6 X7 -1.0 X7 X8 -1.0 X8
P(y = 1) = 0.86 0.1
Input Value
X0 -0.5 X0 X1 -0.2 X1 X2 0.6 X2 X3 -0.3 X3 X4 0.1 X4 X5 -0.8 X5 X6 -0.5 X6 X7 -1.0 X7 X8 -1.0 X8
P(y = 1) = 0.87 0.1

Explanation
0.0 0.1 0.2
Explanation
0.0 0.1 0.2

Input Value
X0 -0.5 X0 X1 -0.2 X1 X2 0.6 X2 X3 -0.3 X3 X4 0.1 X4 X5 -0.8 X5 X6 -0.5 X6 X7 -1.0 X7 X8 -1.0 X8 P(y = 1) = 0.86
Input Value
X0 -0.5 X0 X1 -0.2 X1 X2 0.6 X2 X3 -0.3 X3 X4 0.1 X4 X5 -0.8 X5 X6 -0.5 X6 X7 -1.0 X7 X8 -1.0 X8 P(y = 1) = 0.86

Explanation
0.1 0.0 0.1
Explanation
0.1 0.0 0.1

Input Value
X0 -0.4 X0 X1 -0.3 X1 X2 0.7 X2 X3 -0.4 X3 X4 -0.1 X4 X5 -0.8 X5 X6 -0.4 X6 X7 -1.0 X7 X8 0.1 X8
0.2
Input Value
X0 -0.4 X0 X1 -0.3 X1 X2 0.7 X2 X3 -0.4 X3 X4 -0.1 X4 X5 -0.8 X5 X6 -0.4 X6 X7 -1.0 X7 X8 0.1 X8
0.2

Explanation
0.1 0.0 0.1
Explanation
0.1 0.0 0.1

(A) SHAP on GLASS

Input Value

Explanation

XXXXXXXXXXXXX0123456789111012

-----------0000000001000.............9339043370774

XXXXXXXXXXXXX1119876543210210

P(y = 1) = 0.76

0.1 0.0 0.1 0.2

Input Value

Explanation

XXXXXXXXXXXXX0123456789111012

-----------0000000001000.............9339043370774

XXXXXXXXXXXXX1119876543210210

P(y = 1) = 0.76

0.1 0.0 0.1 0.2

(B) LIME on GLASS

Input Value

Explanation

XXXXXXXXXXXXX0123456789111012

-----------0000000001000.............9339043370774

XXXXXXXXXXXXX1119876543210210

P(y = 1) = 0.76

0.2 0.1 0.0 0.1

Input Value

Explanation

XXXXXXXXXXXXX0123456789111012

-----------0000000001000.............9339043370774

XXXXXXXXXXXXX1119876543210210

P(y = 1) = 0.76

0.2 0.1 0.0 0.1

(C) SENN on GLASS

Input Value

Explanation

XXXXXXXXXXXXX0123456789111012

------------0000000000000.............9231256970684

XXXXXXXXXXXXX1119876543210210

0.2

0.0

0.2

Input Value

Explanation

XXXXXXXXXXXXX0123456789111012

------------0000000000000.............9231256970684

XXXXXXXXXXXXX1119876543210210

0.2

0.0

0.2

(D) SHAP on WINE

Input Value

Explanation

X0 1.0 X0 X1 81.0 X1 X2 72.0 X2 X3 18.0 X3 X4 40.0 X4 X5 26.6 X5
X6 0.3 X6
X7 24.0 X7

P(y = 1) = 0.98 0.1 0.0 0.1 0.2

Input Value

Explanation

X0 1.0 X0 X1 81.1 X1 X2 72.0 X2 X3 18.1 X3 X4 40.0 X4 X5 26.6 X5
X6 0.3 X6
X7 23.9 X7

P(y = 1) = 0.98 0.1 0.0 0.1 0.2

(E) LIME on WINE

Input Value

Explanation

X0 1.0 X0 X1 81.0 X1 X2 72.0 X2 X3 18.0 X3 X4 40.0 X4 X5 26.6 X5
X6 0.3 X6
X7 24.0 X7

P(y = 1) = 0.98

0.2 0.1 0.0 0.1

Input Value

Explanation

X0 1.0 X0 X1 80.7 X1 X2 72.1 X2 X3 17.8 X3 X4 40.2 X4 X5 26.7 X5
X6 0.3 X6
X7 24.0 X7

P(y = 1) = 0.98

0.2 0.1 0.0 0.1

(F) SENN on WINE

Input Value

Explanation

X0 2.0 X0 X1 87.0 X1 X2 0.0 X2 X3 23.0 X3 X4 0.0 X4 X5 28.9 X5
X6 0.8 X6
X7 25.0 X7

0.10 0.05 0.00 0.05 0.10

Input Value

Explanation

X0 2.0 X0 X1 87.0 X1 X2 0.2 X2 X3 23.1 X3 X4 0.6 X4 X5 28.8 X5
X6 0.8 X6
X7 25.0 X7

0.10 0.05 0.00 0.05 0.10

(G) SHAP on DIABETES

(H) LIME on DIABETES

(I) SENN on DIABETES

Figure 12: Adversarial examples (i.e., the maximizer argument in (5)) for SHAP, LIME and SENN on various UCI datasets.
16

