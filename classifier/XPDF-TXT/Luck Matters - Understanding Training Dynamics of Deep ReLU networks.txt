arXiv:1905.13405v4 [cs.LG] 28 Jun 2019

Luck Matters: Understanding Training Dynamics of Deep ReLU Networks
Yuandong Tian Tina Jiang Qucheng Gong Ari Morcos Facebook AI Research
{yuandong, tinayujiang, qucheng, arimorcos}@fb.com
Abstract
We analyze the dynamics of training deep ReLU networks and their implications on generalization capability. Using a teacher-student setting, we discovered a novel relationship between the gradient received by hidden student nodes and the activations of teacher nodes for deep ReLU networks. With this relationship and the assumption of small overlapping teacher node activations, we prove that (1) student nodes whose weights are initialized to be close to teacher nodes converge to them at a faster rate, and (2) in over-parameterized regimes and 2-layer case, while a small set of lucky nodes do converge to the teacher nodes, the fanout weights of other nodes converge to zero. This framework provides insight into multiple puzzling phenomena in deep learning like over-parameterization, implicit regularization, lottery tickets, etc. We verify our assumption by showing that the majority of BatchNorm biases of pre-trained VGG11/13/16/19 models are negative. Experiments on (1) random deep teacher networks with Gaussian inputs, (2) teacher network pre-trained on CIFAR-10 and (3) extensive ablation studies validate our multiple theoretical predictions. Code is available at https://github.com/facebookresearch/luckmatters.
1 Introduction
Although neural networks have made strong empirical progress in a diverse set of domains (e.g., computer vision [17, 33, 11], speech recognition [12, 1], natural language processing [23, 4], and games [31, 32, 36, 24]), a number of fundamental questions still remain unsolved. How can Stochastic Gradient Descent (SGD) find good solutions to a complicated non-convex optimization problem? Why do neural networks generalize? How can networks trained with SGD fit both random noise and structured data [39, 18, 25], but prioritize structured models, even in the presence of massive noise [28]? Why are flat minima related to good generalization? Why does over-parameterization lead to better generalization [26, 40, 34, 27, 20]? Why do lottery tickets exist [7, 8]?
In this paper, we propose a theoretical framework for multilayered ReLU networks. Based on this framework, we try to explain these puzzling empirical phenomena with a unified view. We adopt a teacher-student setting where the label provided to an over-parameterized deep student ReLU network is the output of a fixed teacher ReLU network of the same depth and unknown weights (Fig. 1(a)). Here over-parameterization means that at each layer, the number of nodes in student network is more than the number of nodes in the teacher network. In this perspective, hidden student nodes are randomly initialized with different activation regions (Fig. 2(a)). During optimization, student nodes compete with each other to explain teacher nodes. From this setting, Theorem 4 shows that lucky student nodes which have greater overlap with teacher nodes converge to those teacher nodes at a fast rate, resulting in winner-take-all behavior. Furthermore, Theorem 5 shows that in the 2-layer case, if a subset of student nodes are close to the teachers', they converge to them and the fan-out weights of other irrelevant nodes of the same layer vanishes.
Preprint. Work in progress.

(a)

(b)

Input space (c)

j2

Teacher Network (Fixed parameters)

(Over-parameterized) Student Network (Learnable Parameters)

Figure 1: (a) Teacher-Student Setting. For each node j, the activation region is Ej = {x : fj(x) > 0}. (b) node j initialized to overlap substantially with a teacher node j1 converges faster towards j1 (Thm. 4). (c)

Student nodes initialized to be close to teacher converges to them, while the fan-out weights of other irrelevant

student nodes goes to zero. (Thm. 5).

With this framework, we try to intuitively explain various neural network behaviors as follows:
Fitting both structured and random data. Under gradient descent dynamics, some student nodes, which happen to overlap substantially with teacher nodes, will move into the teacher node and cover them. This is true for both structured data that corresponds to small teacher networks with few intermediate nodes, or noisy/random data that correspond to large teachers with many intermediate nodes. This explains why the same network can fit both structured and random data (Fig. 2(a-b)).
Over-parameterization. In over-parameterization, lots of student nodes are initialized randomly at each layer. Any teacher node is more likely to have a substantial overlap with some student nodes, which leads to fast convergence (Fig. 2(a) and (c), Thm. 4), consistent with [7, 8]. This also explains that training models whose capacity just fit the data (or teacher) yields worse performance [20].
Flat minima. Deep networks often converge to "flat minima" whose Hessian has a lot of small eigenvalues [29, 30, 22, 3]. Furthermore, while controversial [5], flat minima seem to be associated with good generalization, while sharp minima often lead to poor generalization [13, 15, 37, 21]. In our theory, when fitting with structured data, only a few lucky student nodes converge to the teacher, while for other nodes, their fan-out weights shrink towards zero, making them (and their fan-in weights) irrelevant to the final outcome (Thm. 5), yielding flat minima in which movement along most dimensions ("unlucky nodes") results in minimal change in output. On the other hand, sharp minima is related to noisy data (Fig. 2(d)), in which more student nodes match with the teacher.
Implicit regularization. On the other hand, the snapping behavior enforces winner-take-all: after optimization, a teacher node is fully covered (explained) by a few student nodes, rather than splitting amongst student nodes due to over-parameterization. This explains why the same network, once trained with structured data, can generalize to the test set.
Lottery Tickets. Lottery Tickets [7, 8, 41] is an interesting phenomenon: if we reset "salient weights" (trained weights with large magnitude) back to the values before optimization but after initialization, prune other weights (often > 90% of total weights) and retrain the model, the test performance is the same or better; if we reinitialize salient weights, the test performance is much worse. In our theory, the salient weights are those lucky regions (Ej3 and Ej4 in Fig. 3) that happen to overlap with some teacher nodes after initialization and converge to them in optimization. Therefore, if we reset their weights and prune others away, they can still converge to the same set of teacher nodes, and potentially achieve better performance due to less interference with other irrelevant nodes. However, if we reinitialize them, they are likely to fall into unfavorable regions which cannot cover teacher nodes, and therefore lead to poor performance (Fig. 3(c)), just like in the case of under-parameterization. Recently, Supermask [41] shows that a supermask can be found from winning tickets. If it is applied to initialized weights, the network without training gives much better test performance than chance. This is also consistent with the intuitive picture in Fig. 3(b).
2 Mathematical Framework
Notation. Consider a student network and its associated teacher network (Fig. 1(a)). Denote the input as x. For each node j, denote fj(x) as the activation, fj(x) as the ReLU gating (for the toplayer, fc(x) and fc (x) are always 1), and gj(x) as the backpropagated gradient, all as functions of x. We use the superscript  to represent a teacher node (e.g., j). Therefore, gj never appears as teacher nodes are not updated. We use wjk to represent weight between node j and k in the student network. Similarly, wjk represents the weight between node j and k in the teacher network.
2

Structured Data

The Effect of over-parameterization

(a) (Small teacher network)

(b)

Random (large teacher

Data network)

Weight Initialization

Convergence

Weight Initialization

Convergence

Figure 2: Explanation of implicit regularization. Blue are activation regions of teacher nodes, while orange are students'. (a) When the data labels are structured, the underlying teacher network is small and each layer has few nodes. Over-parameterization (lots of red regions) covers them all. Moreover, those student nodes that heavily overlap with the teacher nodes converge faster (Thm. 4), yield good generalization performance. (b) If a dataset contains random labels, the underlying teacher network that can fit to it has a lot of nodes. Over-parameterization can still handle them and achieves zero training error.

(a)

(b)

(c)

Figure 3: Explanation of lottery ticket phenomenon. (a) A successful training with over-parameterization (2 filters in the teacher network and 4 filters in the student network). Node j3 and j4 are lucky draws with strong overlap with two teacher node j1 and j2, and thus converges with high weight magnitude. (b) Lottery ticket phenomenon: initialize node j3 and j4 with the same initial weight, clamp the weight of j1 and j2 to zero, and retrain the model, the test performance becomes better since j3 and j4 still converge to their teacher node, respectively. (c) If we reinitialize node j3 and j4, it is highly likely that they are not overlapping with teacher node j1 and j2 so the performance is not good.

We focus on multi-layered ReLU networks. We use the following equality extensively: (x) =  (x)x. For ReLU node j, we use Ej  {x : fj(x) > 0} as the activation region of node j.
Teacher network versus Dataset. The reason why we formulate the problem using teacher network rather than a dataset is the following: (1) It leads to a nice and symmetric formulation for multilayered ReLU networks (Thm. 1). (2) A teacher network corresponds to an infinite size dataset, which separates the finite sample issues from induction bias in the dataset, which corresponds to the structure of teacher network. (3) If student weights can be shown to converge to teacher ones, generalization bound can naturally follow for the student. (4) The label complexity of data generated from a teacher is automatically reduced, which could lead to better generalization bound. On the other hand, a bound for arbitrary function class can be hard.
Objective. We assume that both the teacher and the student output probabilities over C classes. We use the output of teacher as the input of the student. At the top layer, each node c in the student corresponds to each node c in the teacher. Therefore, the objective is:

1

min J(w)
w

=

2 Ex

fc(x) - fc (x) 2

(1)

By the backpropagation rule, we know that for each sample x, the (negative) gradient gc(x)  J/fc = fc (x) - fc(x). The gradient gets backpropagated until the first layer is reached.
Note that here, the gradient gc(x) sent to node c is correlated with the activation of the corresponding teacher node fc (x) and other student nodes at the same layer. Intuitively, this means that the gradient "pushes" the student node c to align with class c of the teacher. If so, then the student learns the corresponding class well. A natural question arises:

Are student nodes at intermediate layers correlated with teacher nodes at the same layers?

One might wonder this is hard since the student's intermediate layer receives no direct supervision from the corresponding teacher layer, but relies only on backpropagated gradient. Surprisingly, the following theorem shows that it is possible for every intermediate layer:

3

(a) Small overlap

(b) L-condition

(c) Notations Layer l + 1

Layer l
Input Data
Figure 4: (a) Small overlaps between node activations. Figure drawn in the space spanned by the activations of last layer so all decision boundaries are linear. (b) Lipschitz condition (Assumption 2). (c) Notation in Thm. 2.

Theorem 1 (Recursive Gradient Rule). If all nodes j at layer l satisfies Eqn. 2





gj(x) = fj(x)  jj (x)fj (x) - jj (x)fj (x) ,

(2)

j

j

then all nodes k at layer l - 1 also satisfies Eqn. 2 with kk (x) and kk (x) defined recursively from top to bottom-layer as follows:

kk (x)  wjkfj (x)jj (x)fj (x)wjk , kk (x)  wjkfj (x)jj (x)fj (x)wj k (3)

jj

jj

And for the base case where node c and c are at the top-most layer, cc (x) = cc (x) = (c - c) (i.e., 1 when c corresponds to c, and 0 otherwise).

Note that Theorem 1 applies to arbitrarily deep ReLU networks and allows different number of nodes for the teacher and student. The role played by ReLU activation is to make the expression of  concise, otherwise kk and kk can take a very complicated (and asymmetric) form.
In particular, we consider the over-parameterization setting: the number of nodes on the student side is much larger (e.g., 5-10x) than the number of nodes on the teacher side. Using Theorem 1, we discover a novel and concise form of gradient update rule:

Assumption 1 (Separation of Expectations).

Ex jj (x)fj (x)fj (x)fk(x)fk (x) Ex jj (x)fj(x)fj (x)fk(x)fk (x)

= Ex jj (x) Ex fj (x)fj (x) Ex [fk(x)fk (x)](4) = Ex [jj (x)] Ex fj(x)fj (x) Ex [fk(x)fk (x)] (5)

Theorem 2. If Assumption 1 holds, the gradient dynamics of deep ReLU networks with objective

(Eqn. 1) is:

W l = Ll WlHl+1 - LlWlHl+1

(6)

Here we explain the notations. Wl = w1, . . . , wm l is ml teacher weights, l+1 = Ex [jj (x)],

djj = Ex fj (x)fj (x) and Dl = [djj ], Hl+1 = [hjj ] = l+1  Dl, ljj = Ex [fj (x)fj (x)]

and Ll = [ljj ]. We can define similar notations for W (which has nl columns/filters), , D, H

and L (Fig. 4(c)). there is no ReLU,
network structure,

wAlet+th1haeavnelodwlemls+atx1lao=ynelrylldm=eapx e0=n,dLsH0olnm=awxLe=i0g,hHatstlmtWhaexl+h=1ig, .hI.e.ds,tuWelayltm oearEx-lq1n=,.

lmax - 1 where 1. According to while Ll and Ll

only depend on W0, . . . , Wl-1.

3 Analysis on the Dynamics

In the following, we will use Eqn. 6 to analyze the dynamics of the multi-layer ReLU networks. For convenience, we first define the two functions l and d ( is the ReLU function):

l(w, w ) = Ex (wT x)(w T x) , d(w, w ) = Ex I(wT x)I(w T x) .

(7)

We assume these two functions have the following property .

Assumption 2 (Lipschitz condition). There exists Kd and Kl so that:

i(w, w1) - i(w, w2)  Kii(w, w1) w1 - w2 , i  {d, l}

(8)

4

Using this, we know that djj = d(wj, wj ), djj = d(wj, wj ), and so on. For brevity, denote djj = d(wj, wj ) (when notation j1 is heavy) and so on. We impose the following assumption:
Assumption 3 (Small Overlap between teacher nodes). There exists l 1 and d 1 so that:

dj1j2  ddj1j1 (or ddj2j2 ), lj1j2  llj1j1 (or llj2j2 ), for j1 = j2

(9)

Intuitively, this means that the probability of the simultaneous activation of two teacher nodes j1 and j2 is small. If we have sufficient training data to cover the input space, then a sufficient condition for Assumption 3 to happen is that the teacher has negative bias, which means that they cut corners in the space spanned by the node activations of the lower layer (Fig. 4a). We have empirically verified that the majority of biases in BatchNorm layers (after the data are whitened) are negative in VGG11/16 trained on ImageNet (Sec. 4.1).

3.1 Effects of BatchNorm
Batch Normalization [14] has been extensively used to speed up the training, reduce the tuning efforts and improve the test performance of neural networks. Here we use an interesting property of BatchNorm: the total "energy" of the incoming weights of each node j is conserved over training iterations:
Theorem 3 (Conserved Quantity in Batch Normalization). For Linear  ReLU  BN or Linear  BN  ReLU configuration, wj of a filter j before BN remains constant in training. (Fig. 15).
See Appendix for the proof. The similar lemma is also in [2]. This may partially explain why BN has stabilization effect: energy will not leak from one layer to nearby ones. Due to this property, in the following, for convenience we assume wj 2 = wj 2 = 1, and the gradient w j is always orthogonal to the current weight wj. Note that on the teacher side we can always push the magnitude component to the upper layer; on the student side, random initialization naturally leads to constant magnitude of weights.

3.2 Same number of student nodes as teacher

We start with a simple case first. Consider that we only analyze layer l without overparameterization, i.e., nl = ml. We also assume that Ll = Ll = I, i.e., the input of that layer l is whitened, and the top-layer signal is uniform, i.e., l+1 = l+1 = 11T (all  entries are 1). Then the following theorem shows that weight recovery could follow (we use j as j).

Theorem 4. For dynamics w j = Pwj (W hj - W hj), where Pwj  I - wjwjT is a projection

matrix into the orthogonal complement of wj. hj , hj are corresponding j-th column in H and

H. Denote j = (wj, wj) and assume j  0. If  = cos 0 - (m - 1) dMd > 0, then

wj  wj with the rate 1 - d¯ ( is learning rate). Here d¯ = [1 + 2Kd sin(0/2)] minj djj0 and

Md

=

(1

+

Kd)

[1

+

2Kd

sin(0/2)]2

/

cos

0 2

.

See Appendix for the proof. Here we list a few remarks:
Faster convergence near wj. we can see that due to the fact that hjj in general becomes larger when wj  wj (since cos 0 can be close to 1), we expect a super-linear convergence near wj. This brings about an interesting winner-take-all mechanism: if the initial overlap between a student node j and a particular teacher node is large, then the student node will snap to it (Fig. 1(c)).
Importance of projection operator Pwj . Intuitively, the projection is needed to remove any ambiguity related to weight scaling, in which the output remains constant if the top-layer weights are multiplied by a constant , while the low-layer weights are divided by . Previous works [6] also uses similar techniques while we justify it with BN. Without Pwj , convergence can be harder.
Top-down modulation. Note that here we assume the top-layer signal is uniform, which means that according to kk , there is no preference on which student node k corresponds to which teacher node k. If there is a preference (e.g., kk = (k - k)), then from the proof, the cross-term hkk will be suppressed due to kk , making convergence easier. As we will see next, such a top-down modulation plays an important role for 2-layer and over-parameterization case. We believe that it also plays a similar role for deep networks.

5

Teacher

Student

Convergence

Figure 5: Over-parameterization and top-down modulation. Thm. 5 shows that under certain conditions, the relevant weights Wu  W  and weights connecting to irrelevant student nodes Vr  0.

3.3 Over-Parameterization and Top-down Modulation in 2-layer Network

In the over-parameterization case (nl > ml, e.g., 5-10x), we arrange the variables into two parts: W = [Wu, Wr], where Wu contains ml columns (same size as W ), while Wr contains nl - ml columns. We use [u] (or u-set) to specify nodes 1  j  m, and [r] (or r-set) for the remaining part.

In this case, if we want to show "the main component" Wu converges to W , we will meet with one core question: to where will Wr converge, or whether Wr will even converge at all? We need to consider not only the dynamics of the current layer, but also the dynamics of the upper layer.

Using a 1-hidden layer over-parameterized ReLU network as an example, Theorem 5 shows that the upper-layer dynamics V = LV  - LV automatically apply top-down modulation to suppress

the influence of Wr, regardless of their convergence. Here V =

Vu Vr

, where Vu are the weight

components of u-set. See Fig. 5.

Theorem 5 (Over-Parameterization and Top-down Modulation). Consider W = W H - W H

with over-parameterization (n > m) and its upper-layer dynamics V = LV  - LV . Assume that

initial value Wu0 is close to W : j = (wj, wj)  0 for j  [u]. If (1) Assumption 3 holds for

all pairwise so that Eqn.

combination 41 and Eqn.

of 42

columns of holds, then

W Wu

and Wr0, and (2) there  W , Vu  V  and

exists Vr 

 0

= (0, m) > 0 and with rate 1 - ¯.

¯

See Appendix for the proof (and definition of ¯ in Eqn. 45). The intuition is: if Wu is close to W  and Wr are far away from them due to Assumption 3, the off-diagonal elements of L and L are smaller than diagonal ones. This causes Vu to move towards V  and Vr to move towards zero. When Vr becomes small, so does jj for j  [r] or j  [r]. This in turn suppresses the effect of Wr and accelerates the convergence of Wu. Vr  0 exponentially so that Wr stays close to its initial locations, and Assumption 3 holds for all iterations. A few remarks:

Flat minima. Since Vr  0, Wr can be changed arbitrarily without affecting the outputs of the neural network. This could explain why there are many flat directions in trained networks, and why many eigenvalues of the Hessian are close to zero [29].

Understanding of pruning methods. Theorem 5 naturally relates two different unstructured network pruning approaches: pruning small weights in magnitude [9, 7] and pruning weights suggested by Hessian [19, 10]. It also suggests a principled structured pruning method: instead of pruning a filter by checking its weight norm, pruning accordingly to its top-down modulation.

Accelerated convergence and learning rate schedule. For simplicity, the theorem uses a uniform (and conservative)  throughout the iterations. In practice,  is initially small (due to noise introduced by r-set) but will be large after a few iterations when Vr vanishes. Given the same learning rate, this leads to accelerated convergence. At some point, the learning rate  becomes too large, leading to fluctuation. In this case,  needs to be reduced.

Many-to-one mapping. Theorem 5 shows that under strict conditions, there is one-to-one corre-
spondence between teacher and student nodes. In general this is not the case. Two students nodes can be both in the vicinity of a teacher node wj and converge towards it, until that node is fully explained. We leave it to the future work for rigid mathematical analysis of many-to-one mappings.

Random initialization. One nice thing about Theorem 5 is that it only requires the initial Wu - W  to be small. In contrast, there is no requirement for small Vr . Therefore, we could expect
that with more over-parameterization and random initialization, in each layer l, it is more likely to find the u-set (of fixed size ml), or the lucky weights, so that Wu is quite close to W . At the same

6

Conv0

Conv1

Conv2

Conv3

Conv4

Conv5

Conv6

Count

Count

Conv7

Conv8

Conv9

Conv10

Conv11

Conv12

Positive Bias Negative Bias

Figure 6: Distribution of BatchNorm bias in pre-trained VGG16 on ImageNet. Orange/blue are positive/negative biases. Conv0 corresponds to the lowest layer (closest to the input). VGG11/13/19 in Fig. 18.

time, we don't need to worry about Wr which grows with more over-parameterization. Moreover, random initialization often gives orthogonal weight vectors, which naturally leads to Assumption 3.
3.4 Extension to Multi-layer ReLU networks
Using a similar approach, we could extend this analysis to multi-layer cases. We conjecture that similar behaviors happen: for each layer, due to over-parameterization, the weights of some lucky student nodes are close to the teacher ones. While these converge to the teacher, the final values of others irrelevant weights are initialization-dependent. If the irrelevant nodes connect to lucky nodes at the upper-layer, then similar to Thm. 5, the corresponding fan-out weights converge to zero. On the other hand, if they connect to nodes that are also irrelevant, then these fan-out weights are notdetermined and their final values depends on initialization. However, it doesn't matter since these upper-layer irrelevant nodes eventually meet with zero weights if going up recursively, since the top-most output layer has no over-parameterization. We leave a formal analysis to future work.
4 Simulations
4.1 Checking Assumption 3
To make Theorem 4 and Theorem 5 work, we make Assumption 3 that the activation field of different teacher nodes should be well-separated. To justify this, we analyze the bias of BatchNorm layers after the convolutional layers in pre-trained VGG11/13/16/19. We check the BatchNorm bias c1 as these models use Linear-BatchNorm-ReLU architecture. After BatchNorm first normalizes the input data into zero mean distribution, the BatchNorm bias determines how much data pass the ReLU threshold. If the bias is negative, then a small portion of data pass ReLU gating and Assumption 3 is likely to hold. From Fig. 6, it is quite clear that the majority of BatchNorm bias parameters are negative, in particular for the top layers.
4.2 Numerical Experiments of Thm. 5
We verify Thm. 5 by checking whether Vr moves close to 0 under different initialization. We use a network with one hidden layer. The teacher network is 10-20-30, while the student network has more nodes in the hidden layers. Input data are Gaussian noise. We initialize the student networks so that the first 20 nodes are close to the teacher. Specifically, we first create matrices W and V by first filling with i.i.d Gaussian noise, and then normalizing their columns to 1. Then the initial value of student W is Wu0 = column normalize(pW W  + W ), where pW is a factor controlling how close Wu0 is to W . For Wr we initialize with noise. Similarly we initialize Vu with a factor pV . The larger pW and pV , the close the initialization Wu0 and Vu0 to the ground truth values. Fig. 7 shows the behavior over different iterations. All experiments are repeated 32 times with different random seeds, and (mean± std) are reported. We can see that a close initialization leads to faster (and low variance) convergence of Vr to small values. In particular, it is important to have Wu0 close to W  (large pW ), which leads to a clear separation between row norms of Vu and Vr, even if they are close to each other at the beginning of training. Having Vu0 close to V  makes the initial gap larger and also helps convergence. On the other hand, if pW is small, then even if pV is large, the gap between row norms of Vu and Vr only shifts but doesn't expand over iterations.
7

Figure 7: Numerical verification of Thm. 5. Rows are 2×, 5× and 10× over-parameterization. Columns are different initializations of student networks. All figures show vj , i.e., norm of each row of V .
5 Experiments
5.1 Experiment Setup
We evaluate both the fully connected (FC) and ConvNet setting. For FC, we use a ReLU teacher network of size 50-75-100-125. For ConvNet, we use a teacher with channel size 64-64-64-64. The student networks have the same depth but with 10× nodes/channels at each layer, such that they are substnatially over-parameterized. When BatchNorm is added, it is added after ReLU.
We use random i.i.d Gaussian inputs with mean 0 and std 10 (abbreviated as GAUS) and CIFAR-10 as our dataset in the experiments. GAUS generates infinite number of samples while CIFAR-10 is a finite dataset. For GAUS, we use a random teacher network as the label provider (with 100 classes). To make sure the weights of the teacher are weakly overlapped, we sample each entry of wj from [-0.5, -0.25, 0, 0.25, 0.5], making sure they are non-zero and mutually different within the same layer, and sample biases from U [-0.5, 0.5]. In the FC case, the data dimension is 20 while in the ConvNet case it is 16 × 16. For CIFAR-10 we use a pre-trained teacher network with BatchNorm. In the FC case, it has an accuracy of 54.95%; for ConvNet, the accuracy is 86.4%. We repeat 5 times for all experiments, with different random seed and report min/max values.
Two metrics are used to check our prediction that some lucky student nodes converge to the teacher:
Normalized correlation ¯. We compute normalized correlation (or cosine similarity)  between teacher and student activations1 evaluated on a validation set. At each layer, we average the best correlation over teacher nodes: ¯ = meanj maxj jj , where jj is computed for each teacher and student pairs (j, j). ¯  1 means that most teacher nodes are covered by at least one student. Mean Rank r¯. After training, each teacher node j has the most correlated student node j. We check the correlation rank of j, normalized to [0, 1] (0=rank first), back at initialization and at different epochs, and average them over teacher nodes to yield mean rank r¯. Small r¯ means that student nodes that initially correlate well with the teacher keeps the lead toward the end of training.
1For fj = [fj (x1), . . . , fj (xn)] and fj , jj = ~fjT ~fj  [-1, 1], where ~fj = (fj - mean(fj ))/std(fj ).
8

Gaussian FC with BN

Gaussian CNN with BN

Gaussian FC without BN

Gaussian CNN without BN

Figure 8: Correlation ¯ and mean rank r¯ over training on GAUS. ¯ steadily grows and r¯ quickly improves over time. Layer-0 (the lowest layer that is closest to the input) shows best match with teacher nodes and best mean rank. BatchNorm helps achieve both better correlation and lower r¯, in particular for the CNN case.

CIFAR10 FC with BN

CIFAR10 CNN with BN

CIFAR10 FC without BN

CIFAR10 CNN without BN

Figure 9: Same experiment setting as in Fig. 8 on CIFAR-10. BatchNorm helps achieve lower r¯.

(a)

Gaussian [50-75-100-125]

With BN

Gaussian [10-15-20-25]

(b)

CNN, In nite Gaussian Dataset

CNN, Finite Gaussian Dataset

No BN

Epoch

Epoch

Epoch

Epoch

Figure 10: Ablation studies on GAUS. (a) ¯ converges much faster in small models (10-15-20-25)

than in large model (50-75-100-125). BatchNorm hurts in small models. (b) ¯ stalls using finite

samples.

9

Layer-0

* at initialization

* after optimization

H* after optimization

Layer-1

Layer-2

Layer-3

Figure 11: Visualization of (transpose of) H and  matrix before and after optimization (using GAUS).
Student node indices are reordered according to teacher-student node correlations. After optimization, student
node who has high correlation with the teacher node also has high  entries. Such a behavior is more prominent in H matrix that combines  and the activation patterns D of student nodes (Sec. 2).

Normalized Corr

1.0

node_multi = 1

0.9

1.0

node_multi = 2

0.9

1.0

node_multi = 5

0.9

1.0 0.9

node_multi = 1 layer-0 layer-1

1.0

node_multi = 2

0.9

1.0

node_multi = 5

0.9

Normalized Corr

Normalized Corr

Normalized Corr

Normalized Corr

Normalized Corr

0.8 0.7

layer-0

0.8

layer-1

0.7

layer-0

0.8

layer-1

0.7

layer-0 layer-1

0.8 0.7

layer-2 layer-3

0.8 0.7

layer-0

0.8

layer-1

0.7

layer-0 layer-1

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.6

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.5 0 20 40 60 80 100 0.5 0 20 40 60 80 100 0.5 0 20 40 60 80 100 0.5 0 20 40 60 80 100 0.5 0 20 40 60 80 100 0.5 0 20 40 60 80 100

Epoch

Epoch

Epoch

Epoch

Epoch

Epoch

1.0

node_multi = 10

1.0

node_multi = 20

1.0

node_multi = 50

1.0

node_multi = 10

1.0

node_multi = 20

1.0

node_multi = 50

Normalized Corr

Normalized Corr

Normalized Corr

Normalized Corr

Normalized Corr

0.9

0.9

0.9

0.9

0.9

0.9

0.8

layer-0

0.8

layer-0

0.8

layer-0

0.8

layer-0

0.8

layer-0

0.8

layer-0

0.7

layer-1

0.7

layer-1

0.7

layer-1

0.7

layer-1

0.7

layer-1

0.7

layer-1

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.6

layer-2 layer-3

0.5 0 20 40Epoch60 80 100 0.5 0 20 40Epoch60 80 100 0.5 0 20 40Epoch60 80 100 0.5 0 20 40Epoch60 80 100 0.5 0 20 40Epoch60 80 100 0.5 0 20 40Epoch60 80 100

Normalized Corr

Figure 12: Effect of different degrees of over-parameterization. Left panel: Teacher FC (10-15-2025) without batchnorm, right panel: teacher CNN (10-15-20-25) with batchnorm.

5.2 Results Experiments are summarized in Fig. 8 and Fig. 9. ¯ indeed grows during training, in particular for low layers that are closer to the input, where ¯ moves towards 1. Furthermore, the final winning student nodes also have a good rank at the early stage of training, in particular after the first epoch, which is consistent with late-resetting used in [8]. BatchNorm helps a lot, in particular for the CNN case with GAUS dataset. For CIFAR-10, the final evaluation accuracy (see Appendix) learned by the student is often  1% higher than the teacher. Using BatchNorm accelerates the growth of accuracy, improves r¯, but seems not to accelerate the growth of ¯.
The theory also predicts that the top-down modulation  helps the convergence. For this, we plot jj at different layers during optimization on GAUS. For better visualization, we align each student node index j with a teacher node j according to highest . Despite the fact that correlations are computed from the low-layer weights, it matches well with the top-layer modulation (identity matrix structure in Fig. 11). Besides, we also perform ablation studies on GAUS.
Size of teacher network. As shown in Fig. 10(a), for small teacher networks (FC 10-15-20-25), the convergence is much faster and training without BatchNorm is faster than training with BatchNorm. For large teacher networks, BatchNorm definitely increases convergence speed and growth of ¯.
Degree of over-parameterization. Fig. 12 shows the effects of different degree of overparameterization (1×, 2×, 5×, 10×, 20× and 50×). We initialize 32 different teacher network (10-15-20-25) with different random seed, and plot ± standard derivation with shaded area. We can clearly see that ¯ grows more stably and converges to higher values with over-parameterization. On the other hand, 20× and 50× are slower in convergence due to excessive parameters.
Finite versus Infinite Dataset. We also repeat the experiments with a pre-generated finite dataset of GAUS in the CNN case (Fig. 10(b)), and find that the convergence of node similarity stalls after a few iterations. This is because some nodes receive very few data points in their activated regions, which is not a problem for infinite dataset. We suspect that this is probably the reason why CIFAR-10, as a finite dataset, does not show similar behavior as GAUS.
6 Conclusion and Future Work
In this paper we propose a new theoretical framework that uses teacher-student setting to understand the training dynamics of multi-layered ReLU network. With this framework, we are able to conceptually explain many puzzling phenomena in deep networks, such as why over-parameterization helps generalization, why the same network can fit to both random and structured data, why lottery
10

tickets [7, 8] exist. We backup these intuitive explanations by Theorem 4 and Theorem 5, which collectively show that student nodes that are initialized to be close to the teacher nodes converge to them with a faster rate, and the fan-out weights of irrelevant nodes converge to zero. As the next steps, we aim to extend Theorem 5 to general multi-layer setting (when both L and H are present), relax Assumption 3 and study more BatchNorm effects than what Theorem 3 suggests.
7 Acknowledgement
The first author thanks Simon Du, Jason Lee, Chiyuan Zhang, Rong Ge, Greg Yang, Jonathan Frankle and many others for the informal discussions.
References
[1] Dario Amodei, Sundaram Ananthanarayanan, Rishita Anubhai, Jingliang Bai, Eric Battenberg, Carl Case, Jared Casper, Bryan Catanzaro, Qiang Cheng, Guoliang Chen, et al. Deep speech 2: End-to-end speech recognition in english and mandarin. In International conference on machine learning, pages 173­182, 2016.
[2] Sanjeev Arora, Zhiyuan Li, and Kaifeng Lyu. Theoretical analysis of auto rate-tuning by batch normalization. arXiv preprint arXiv:1812.03981, 2018.
[3] Marco Baity-Jesi, Levent Sagun, Mario Geiger, Stefano Spigler, G Ben Arous, Chiara Cammarota, Yann LeCun, Matthieu Wyart, and Giulio Biroli. Comparing dynamics: Deep neural networks versus glassy systems. ICML, 2018.
[4] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.
[5] Laurent Dinh, Razvan Pascanu, Samy Bengio, and Yoshua Bengio. Sharp minima can generalize for deep nets. In Proceedings of the 34th International Conference on Machine LearningVolume 70, pages 1019­1028. JMLR. org, 2017.
[6] Simon S Du, Jason D Lee, Yuandong Tian, Barnabas Poczos, and Aarti Singh. Gradient descent learns one-hidden-layer cnn: Don't be afraid of spurious local minima. ICML, 2018.
[7] Jonathan Frankle and Michael Carbin. The lottery ticket hypothesis: Training pruned neural networks. ICLR, 2019.
[8] Jonathan Frankle, Gintare Karolina Dziugaite, Daniel M Roy, and Michael Carbin. The lottery ticket hypothesis at scale. arXiv preprint arXiv:1903.01611, 2019.
[9] Song Han, Jeff Pool, John Tran, and William Dally. Learning both weights and connections for efficient neural network. In Advances in neural information processing systems, pages 1135­1143, 2015.
[10] Babak Hassibi, David G Stork, and Gregory J Wolff. Optimal brain surgeon and general network pruning. In IEEE international conference on neural networks, pages 293­299. IEEE, 1993.
[11] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 770­778, 2016.
[12] Geoffrey Hinton, Li Deng, Dong Yu, George Dahl, Abdel-rahman Mohamed, Navdeep Jaitly, Andrew Senior, Vincent Vanhoucke, Patrick Nguyen, Brian Kingsbury, et al. Deep neural networks for acoustic modeling in speech recognition. IEEE Signal processing magazine, 29, 2012.
[13] Sepp Hochreiter and Ju¨rgen Schmidhuber. Flat minima. Neural Computation, 9(1):1­42, 1997.
[14] Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. ICML, 2015.
[15] Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Peter Tang. On large-batch training for deep learning: Generalization gap and sharp minima. ICLR, 2017.
11

[16] Jonas Kohler, Hadi Daneshmand, Aurelien Lucchi, Ming Zhou, Klaus Neymeyr, and Thomas Hofmann. Towards a theoretical understanding of batch normalization. arXiv preprint arXiv:1805.10694, 2018.
[17] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097­1105, 2012.
[18] David Krueger, Nicolas Ballas, Stanislaw Jastrzebski, Devansh Arpit, Maxinder S Kanwal, Tegan Maharaj, Emmanuel Bengio, Asja Fischer, and Aaron Courville. Deep nets don't learn via memorization. ICLR Workshop, 2017.
[19] Yann LeCun, John S Denker, and Sara A Solla. Optimal brain damage. In Advances in neural information processing systems, pages 598­605, 1990.
[20] Chunyuan Li, Heerad Farkhoor, Rosanne Liu, and Jason Yosinski. Measuring the intrinsic dimension of objective landscapes. ICLR, 2018.
[21] Hao Li, Zheng Xu, Gavin Taylor, Christoph Studer, and Tom Goldstein. Visualizing the loss landscape of neural nets. In Advances in Neural Information Processing Systems, pages 6389­ 6399, 2018.
[22] Zachary C Lipton. Stuck in a what? adventures in weight space. arXiv preprint arXiv:1602.07320, 2016.
[23] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words and phrases and their compositionality. In Advances in neural information processing systems, pages 3111­3119, 2013.
[24] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013.
[25] Behnam Neyshabur, Srinadh Bhojanapalli, David McAllester, and Nati Srebro. Exploring generalization in deep learning. In Advances in Neural Information Processing Systems, pages 5947­5956, 2017.
[26] Behnam Neyshabur, Zhiyuan Li, Srinadh Bhojanapalli, Yann LeCun, and Nathan Srebro. Towards understanding the role of over-parametrization in generalization of neural networks. arXiv preprint arXiv:1805.12076, 2018.
[27] Behnam Neyshabur, Ryota Tomioka, and Nathan Srebro. In search of the real inductive bias: On the role of implicit regularization in deep learning. ICLR Workshop, 2015.
[28] David Rolnick, Andreas Veit, Serge Belongie, and Nir Shavit. Deep learning is robust to massive label noise. arXiv preprint arXiv:1705.10694, 2017.
[29] Levent Sagun, Leon Bottou, and Yann LeCun. Eigenvalues of the hessian in deep learning: Singularity and beyond. ICLR, 2017.
[30] Levent Sagun, Utku Evci, V Ugur Guney, Yann Dauphin, and Leon Bottou. Empirical analysis of the hessian of over-parametrized neural networks. ICLR 2018 Workshop Contribution, arXiv preprint arXiv:1706.04454, 2018.
[31] David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go with deep neural networks and tree search. nature, 529(7587):484, 2016.
[32] David Silver, Julian Schrittwieser, Karen Simonyan, Ioannis Antonoglou, Aja Huang, Arthur Guez, Thomas Hubert, Lucas Baker, Matthew Lai, Adrian Bolton, et al. Mastering the game of go without human knowledge. Nature, 550(7676):354, 2017.
[33] Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.
[34] Stefano Spigler, Mario Geiger, Ste´phane d'Ascoli, Levent Sagun, Giulio Biroli, and Matthieu Wyart. A jamming transition from under-to over-parametrization affects loss landscape and generalization. arXiv preprint arXiv:1810.09665, 2018.
[35] Yuandong Tian. A theoretical framework for deep locally connected relu network. arXiv preprint arXiv:1809.10829, 2018.
12

[36] Yuandong Tian and Yan Zhu. Better computer go player with neural network and long-term prediction. ICLR, 2016.
[37] Lei Wu, Zhanxing Zhu, et al. Towards understanding generalization of deep learning: Perspective of loss landscapes. arXiv preprint arXiv:1706.10239, 2017.
[38] Greg Yang, Jeffrey Pennington, Vinay Rao, Jascha Sohl-Dickstein, and Samuel S Schoenholz. A mean field theory of batch normalization. ICLR, 2019.
[39] Chiyuan Zhang, Samy Bengio, Moritz Hardt, Benjamin Recht, and Oriol Vinyals. Understanding deep learning requires rethinking generalization. ICLR, 2017.
[40] Chiyuan Zhang, Samy Bengio, Moritz Hardt, and Yoram Singer. Identity crisis: Memorization and generalization under extreme overparameterization. arXiv preprint arXiv:1902.04698, 2019.
[41] Hattie Zhou, Janice Lan, Rosanne Liu, and Jason Yosinski. Deconstructing lottery tickets: Zeros, signs, and the supermask. arXiv preprint arXiv:1905.01067, 2019.
13

Population Loss

Notation

Activation

Gating (ReLU: 0/1)

Teacher Network (Fixed parameters)

(Over-parameterized) Student Network (Learnable Parameters)

Gradient Update:

Gradient

Figure 13: Teacher-Student Setting, loss function and notations.

(a)

(b)

BatchNorm

Projected Gradient
Figure 14: BatchNorm explanation

subspace

8 Appendix: Proofs

8.1 Theorem 1

Proof. The first part of gradient backpropagated to node j is:

gj1(x) = fj (x) jj (x)fj (x)

(10)

j

= fj (x) jj (x)fj (x) wjk fk (x)

j

k





(11)

=

fj (x) jj (x)fj (x)wjk  fk (x)

k

j

(12)

Therefore, for the gradient to node k, we have:

gk1(x) = fk(x) wjkgj1(x)
j


(13) 

= fk(x)  wjkfj (x)jj (x)fj (x)wjk  fk (x)
k jj

(14)

kk (x)
And similar for kk (x). Therefore, by mathematical induction, we know that all gradient at nodes in different layer follows the same form.

8.2 Theorem 2

Proof. Using Thm. 1, we can write down weight update for weight wjk that connects node j and node k:

w jk =

wjk Ex fj (x)jj (x)fj (x)fk(x)fk (x)

j  ,k

jj  kk

-

wj k Ex fj(x)jj (x)fj (x)fk(x)fk (x)

(15)

j ,k

jj kk

14

(a)

(b)

Linear

BatchNorm

ReLU

Linear

ReLU

BatchNorm

Figure 15: Different BatchNorm Configuration.

Note that j, k, j and k run over all parents and children nodes on the teacher side. This formulation works for over-parameterization (e.g., j and j can run over different nodes). Applying
Assumption 1 and rearrange terms in matrix form yields Eqn. 6.

8.3 Theorem 3

Proof. Given a batch with size N , denote pre-batchnorm activations as f = [fj(x1), . . . , fj(xN )]T

and gradients as g = [gj(x1), . . . , gj(xN )]T (See Fig. 14(a)). ~f = (f - µ)/ is its whitened version,

and

c0~f + c1

is

the

final

output

of

BN.

Here

µ

=

1 N

i fj (xi)

and

2

=

1 N

i(fj(xi) - µ)2 and

c1, c0 are learnable parameters. With vector notation, the gradient update in BN has a compact form

with clear geometric meaning:

Lemma 1 (Backpropagation of Batch Norm [35]). For a top-down gradient g, BN layer gives the

following gradient update (Pf,1 is the orthogonal complementary projection of subspace {f , 1}):

gf

=

J BN (f )g

=

c0 

Pf,1g,

gc = S(f )T g

(16)

Intuitively, the back-propagated gradient JBN (f )g is zero-mean and perpendicular to the input activation f of BN layer, as illustrated in Fig. 14. Unlike [16, 38] that analyzes BN in an approximate manner, in Thm. 1 we do not impose any assumptions.

Given Lemma 1, we can prove Thm. 3. For Fig. 15(a), using the property that Ex gjlinfjlin = 0
(the expectation is taken over batch) and the weight update rule w jk = Ex gjlinfk (over the same batch), we have:





1 d wj 2 = 2 dt

wjkw jk = Ex 

wjkfk(x)gjlin(x) = Ex fjlin(x)gjlin(x) = 0 (17)

kch(j)

kch(j)

For Fig. 15(b), note that Ex gjlinfjlin = Ex gjrlfjrl fjlin = Ex gjrlfjrl = 0 and conclusion follows.

8.4 Lemmas

For simplicity, in the following, we use wj = wj - wj.

Lemma 2 (Bottom Bounds). Assume all wj = wj = 1. Denote

pjj  wj djj , pjj  wj djj , pjj  pjj - pjj

(18)

If Assumption 2 holds, we have:

pjj  (1 + Kd)djj wj

(19)

If Assumption 3 also holds, then:

djj  d(1 + Kd wj )(1 + Kd wj )djj

(20)

Proof. We have for j = j :

pjj = wj djj - wj djj

(21)

= wj (djj - djj ) + (wj - wj )djj

(22)

 wj djj - djj + wj - wj djj

(23)

 djj Kd wj + djj wj

(24)

 (1 + Kd)djj wj

(25)

15

Figure 16: Explanation of Lemma. 4.

If Assumption 3 also holds, we have:

djj  djj (1 + Kd wj )

(26)

 ddjj(1 + Kd wj

(27)

 ddjj (1 + Kd wj )(1 + Kd wj )

(28)

Lemma 3 (Top Bounds). Denote

qjj  vj ljj , qjj  vj ljj , qjj  qjj - qjj

(29)

If Assumption 2 holds, we have:

qjj  (1 + Kl)ljj wj

(30)

If Assumption 3 also holds, then:

ljj  l(1 + Kl wj )(1 + Kl wj )ljj

(31)

Proof. The proof is similar to Lemma 2.

Lemma 4 (Quadratic fall-off for diagonal elements of L). For node j, we have:

ljj - ljj  C0ljj wj 2

(32)

Proof. The intuition here is that both the volume of the affected area and the weight difference are proportional to wj . ljj - ljj is their product and thus proportional to wj 2. See Fig. 16.

8.5 Theorem 4

Proof. First of all, note that

wj

=

2 sin

j 2



2

sin

0 2

.

So given 0, we also have a bound for

wj .

When  =  = 11T , the matrix form can be written as the following:

w j = Pwj wjhjj +

Pwj wj hjj - wj hjj = Pwj pjj +

Pwj pjj

j =j

j =j

(33)

by using Pwj wj  0 (and thus hjj doesn't matter). Since wj is conserved, it suffices to check whether the projected weight vector Pwj wj of wj onto the complementary space of the ground truth node wj, goes to zero:

Pwj w j = Pwj Pwj pjj +

Pwj Pwj pjj

j =j

(34)

16

Denote j = (wj, wj) and a simple calculation gives that sin j = Pwj wj . First we have:

Pwj Pwj wj = Pwj (I - wj wjT )wj = -Pwj wj wjT wj = - cos j Pwj wj

(35)

From Lemma 2, we knows that

pjj  (1 + Kd)djj wj  d(1 + Kd) [1 + 2Kd sin(0/2)]2 djj wj

(36)

Note that here we have wj

=

2

sin

j 2

=

sin

j

/

cos

j 2



sin

j /

cos

0 2

.

We discuss finite step

with very small learning rate  > 0:

sin jt+1 = Pwj wjt+1 = Pwj wjt + Pwj w jt

(37)

 (1 - djj cos jt ) sin jt +  dMd djj sin jt

(38)

j =j

since Pwj = Pwj = 1. Here

Md

=

(1

+

Kd)

[1

+

2Kd

sin(0/2)]2

/

cos

0 2

(39)

is an iteration independent constant. We set  = cos 0 - (m - 1) dMd. If  > 0, denote a constant d¯ = [1 + 2Kd sin(0/2)] minj djj0 and from Lemma 2 we know djj  d¯ for all j. Then given the inductive hypothesis that sin jt  (1 - d¯)t-1 sin 0, we have:

sin jt+1  (1 - d¯)t sin 0

(40)

Therefore, sin jt  0, which means that wj  wj.

A few remarks:
The projection operator Pwj . Note that Pwj is important. Intuitively, without the projection, if the same proof logic worked, one could have concluded that w converges to any w, where  is a constant scaling factor, which is obviously wrong.
Indeed, without Pwj , there would be a term wjhjj -wjhjj on RHS. This term breaks into wj(hjj - hjj)+(wj-wj)hjj. Although there could exist C so that hjj -hjj  C wj , unlike Lemma 4, C may not be small, and convergence is not guaranteed.

8.6 Theorem 5
Proof. First, only for j  [u], we have their ground truth value wj. For j  [r], we assign wj = wj0, i.e., their initial values. As we will see, this will make things easier. From the assumption, we know that sin j  sin 0 for j  [u]. In addition, denote that vj0  Bv for j  [u]. Denote Bv as the bound for all vj . Now suppose we can find a  > 0 if the following set of equations are satisfied:

  (Bv - Bv) cos 0 - d(Bv + Bv) max(Bd,u, Bd,r) > 0

(41)

  1 - l max(Bl,u, Bl,r) -  > 0

(42)

17

Here

d¯

=

(1

-

Kd

Cd,j

)

min
j

djj0

>

0

(43)

¯l =

(1

-

KlCl,j

)

min
j

ljj0

>

0

(44)

¯ = min(d¯, ¯l)

(45)

 = 2C0 sin(0/2)(1 + Bv)

(46)

Cd,u = 2Kd sin(0/2)

(47)

Cd,r =

d

Kd

Bd,r (Bv ¯(2

+ -

Bv )Bv ¯)

(48)

Mduu

=

(1

+

Kd)(1

+

Cd,u)2/

cos

0 2

(49)

Mdur = (1 + Kd)(1 + Cd,u)(1 + Cd,r)

(50)

Mdru

=

(1

+

Kd)(1

+

Cd,u)(1

+

Cd,r

)/

cos

0 2

(51)

Mdrr = (1 + Kd)(1 + Cd,r)2

(52)

Bd,u = (m - 1)Mduu + (n - m)Mdur

(53)

Bd,r = (m - 1)Mdru + (n - m)Mdrr

(54)

and similarly we can define Cl and Ml etc. If we can find such a  > 0 then the dynamics converges. Here all C are close to 0 and M are close to 1.

Note that if d and l are small, it is obvious to see there exists a feasible  > 0 (e.g.,  = 1).

To prove it, we maintain the following induction hypothesis for iteration t :

djjt  dMd,jj djjt , ljjt  lMl,jj ljjt, j = j

(W-Separation)

sin jt  (1 - d¯)t-1 sin 0, j  [u]

(Wu-Contraction)

vjt  (1 - ¯l)t-1Bv, j  [u],

vjt  (1 - ¯l)t-1Bv, j  [r] (V -Contraction)

Besides, the following condition is involved (but it is not part of induction hypothesis):

wjt - wj0  Cd,r, j  [r]

(Wr -Bound)

djjt  djj0(1 - KdCd,j )  d¯ > 0, ljjt  ljj0(1 - KlCl,j )  ¯l > 0

(55)

The proof can be decomposed in the following three lemma.

Lemma 5 (Top-layer contraction). If (W-Separation) holds for t, then (V -Contraction)) holds for iteration t + 1.

Lemma 6 (Bottom-layer contraction). If (V -Contraction) holds for t, then (Wu-Contraction) holds for t + 1 and (Wr-Bound) holds for t + 1.
Lemma 7 (Weight separation). If (W-Separation) holds for t, (Wr-Bound) holds for t + 1 and (Wu-Contraction) holds for t + 1, then (W-Separation) holds for t + 1.

As suggested by Fig. 17, if all the three lemmas are true then the induction hypothesis are true.

In the following, we will prove the three lemmas.

8.6.1 Lemma 5

Proof. On the top-layer, we have V = LV  - LV . Denote that V = row of the matrix V . For each component, we can write:

v1 . . . , where vj is the j-th vn

v j = I(j  [u])qjj - qjj +

qjj +

qjj

j =j,j [u]

j =j,j [r]

(56)

18

Iteration t Wu-Contraction V-Contraction W-Separation Wr-Bound

Iteration t + 1 Wu-Contraction V-Contraction W-Separation Wr-Bound Figure 17: Proof sketch of Thm. 5.

Top-level contraction
Bottom-level contraction
Weight Separation

Note that there is no projection (if there is any, the projection should be in the columns rather than the rows).

If (W-Separation) is true, we know that for j = j ,

qjj  lMl,uuljj vj , qjj  lMl,urljj vj , j  [u]

(57)

qjj  lMl,ruljj vj , qjj  lMl,rrljj vj , j  [r]

(58)

Now we discuss j  [u] and j  [r]:

Relevant nodes. For j  [u], the first two terms are:

qjj = -ljj vj + (ljj - ljj )vj

(59)

From Lemma 4 we know that:

(ljj - ljj )vj  Cljj wj 2 vj  2C sin(0/2)(1 + Bv)ljj wj = ljj wj

(60)

Therefore using (V -Contraction) and (Wu-Contraction) at iteration t, we have:

vjt+1

 (1 - ljj ) vjt + ljj wjt +  lMl,uuljj

vjt +  lMl,urljj

vjt

j =j,j [u]

j =j,j [r]

 (1 - ¯l)t+1Bv

(61)

Since  satisfies Eqn. 42. Irrelevant nodes. Note that for j  [r], we don't have the term qjj. Therefore, we have:

vjt+1

 (1 - ljj ) vjt +  lMl,ruljj

vjt +  lMl,rrljj

vjt

j =j,j [u]

j =j,j [r]

 (1 - ljj ) vjt + ljj vjt +  lMl,ruljj

vjt +  lMl,rrljj

vjt

j =j,j [u]

j =j,j [r]

 (1 - ¯l)t+1Bv

(62)

8.6.2 Lemma 6

Proof. Similar to the proof of Thm. 4, for node j, in the lower-layer, we have:

w j = I(j  [u])Pwj p~jj + Pwj

p~jj + Pwj

p~ j j

j =j,j [u]

j [r],j =j

(63)

where hjj = djj vjT vj and p~jj = pjj vjT vj = wj hjj .

Due to (W-Separation) and wj = 1, we know that for j = j :

p~jj  dMd,uudjj wj p~jj  dMd,rudjj wj

vj vj , p~jj  dMd,urdjj wj vj vj , p~jj  dMd,rrdjj wj

vj vj , j  [u] (64) vj vj , j  [r] (65)

19

Note that if vj (for j  [r]) doesn't converge to zero, then due to Eqn. 65, there is always residue and wj won't converge to wj. Now we discuss two cases: Relevant nodes. For j  [u], similar to Eqn. 35 we have:

sin jt+1  (1 - djj vjt 2 cos jt ) sin jt +  vjt dMd,uudjj

vjt sin jt

j =j,j[u]

+  vjt dMd,urdjj

vjt

j =j,j[r]

(66)

Since (Wu-Contraction) and (V -Contraction) holds for time t, we know that:

sin jt+1  (1 - d¯)t+1 sin 0

(67)

since Eqn. 41 holds.

Irrelevant nodes. In this case, we cannot prove for j  [r], wj converges to any determined target. Instead, we show that wj won't move too much from its initial location wj0, which is also set to be wj, before its corresponding vj converges to zero. This is important to ensure that (W-Separation) remains correct thorough-out the iterations.

For any j  [u], using (Wu-Contraction) and (V -Contraction), we know that the distance between the current wj and its initial value is

wjt+1 - wj0

t

t



w jt  

p~tjj +

p~ tj j

t =0

t =0 j =j,j [u]

j [r],j =j

(68)

t

  dBd,u(Bv + Bv)Bv (1 - ¯)2t

(69)

t =0

=

dBd,r(Bv + Bv)Bv ¯(2 - ¯)

=

Cd,r

(70)

Therefore, we prove that (Wr-Bound) holds for iteration t + 1.

8.7 Lemma 7
Proof. Simply followed from combining Lemma 3, Lemma 2 and weight bounds (Wu-Contraction) and (V -Contraction).

9 More experiments

20

Conv0

Conv1

Conv2

Conv3

Conv4

Conv5

Conv6

Conv7

20.0 17.5

65.62% 12 10

75.00% 25

79.30% 35 30

97.27% 70 60

98.63% 60 50

100.00% 50 40

99.22%

40

100.00%

15.0 12.5 10.0 7.5 5.0 2.5

8 6 4 2

20 15 10 5

25 20 15 10 5

50 40 30 20 10

40 30 20 10

30 20 10

30 20 10

0.01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50

(a) VGG11

Conv0

Conv1

Conv2

Conv3

Conv4

Conv5

Conv6

Conv7

30 25 20 15 10 5

68.75%

14

12

10

8

6

4

2

51.56% 40
30
20
10

69.53%

20

15

10

5

82.81% 25 20 15 10 5

80.86% 35 30 25 20 15 10 5

96.88%

70

60

50

40

30

20

10

98.63% 60 50 40 30 20 10

100.00%

01.00 0.75 0.50 Co0n.2v58 0.00 0.25 0.50 01.00 0.75 0.50 Co0n.2v59 0.00 0.25 0.50

70

99.02% 50

100.00%

60

50

40

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50

40

30

30

20

20

10

10

01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50

(b) VGG13

25 20

Conv0

76.56% 8

Conv1

40.62%

30

25

Conv2

66.41%

20.0 17.5

15.0

Conv3

71.88% 40 35 30

Conv4

76.56% 30 25

Conv5

78.91%

40 35

30

Conv6

95.70%

80

Conv7

99.02%

15 10 5

6

20

12.5

25

20

25

60

4 2

15

10.0 7.5

10

5.0

5

2.5

20 15 10 5

15 10 5

20 15 10 5

40 20

01.00 0.75 0.50 Co0n.2v58 0.00 0.25 0.50 01.00 0.75 0.50 Co0n.2v59 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2150 0.00 0.25 0.50 0.01.00 0.75 0.50Con0.v2151 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2152 0.00 0.25 0.50

80 60 40 20

97.07%

80

70

60

50

40

30

20

10

100.00% 70 60 50 40 30 20 10

99.02%

60

50

40

30

20

10

99.61% 60 50 40 30 20 10

100.00%

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50

01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50

(c) VGG16

Conv0

Conv1

Conv2

Conv3

Conv4

Conv5

Conv6

Conv7

40 30 20 10

81.25% 20 15 10 5

54.69% 70 60 50 40 30 20 10

71.88% 25 20 15 10 5

64.84% 80 70 60 50 40 30 20 10

75.39% 60 50 40 30 20 10

76.17% 50 40 30 20 10

77.34% 40 30 20 10

89.45%

01.00 0.75 0.50 Co0n.2v58 0.00 0.25 0.50 01.00 0.75 0.50 Co0n.2v59 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2150 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2151 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2152 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2153 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2154 0.00 0.25 0.50 01.00 0.75 0.50Con0.v2155 0.00 0.25 0.50

80 70 60 50

98.05%

80

60

97.07% 80
60

96.48%

80

60

99.22%

80

70

60

50

99.22%

80

60

99.41%

80

70

60

50

99.22% 70 60 50

100.00%

40 30

40

40

40

40 30

40

40 30

40 30

20 10

20

20

20

20 10

20

20 10

20 10

01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50 01.00 0.75 0.50 0.25 0.00 0.25 0.50

(d) VGG19

Figure 18: BatchNorm bias distribution of pre-trained VGG11/13/16/19 on ImageNet. Orange/blue are positive/negative biases. The first plot corresponds to the lowest layer (closest to the input).

Loss in Evaluation

Normalized Corr

6

1.0

layer-0

layer-1

4

0.8

layer-2

layer-3

2

0.6

0 0

20 40 60 80 100 0.4 0

20

40

60 80 100

Epoch

Epoch

Loss in Evaluation

5

4

50

3

40

2

30

1

20

00

10 20 40 60 80 100

Epoch

Accuracy in Evaluation Normalized Corr

1.0

layer-0

layer-1

0.8

layer-2

layer-3

0.6

0.4 0

20 40 60 80 100

Epoch

Loss in Evaluation

6

1.0

Normalized Corr

0.8

4

0.6

2

0.4

0.2

0 0

20 40 60

80 100 0.0 0

Epoch

20 40 60 Epoch

layer-0 layer-1 layer-2 layer-3 80 100

Loss in Evaluation

40 30 20 10 0
0

80 60 40 20 20 40 60 80 100 Epoch

Accuracy in Evaluation Normalized Corr

1.0

0.8

0.6

0.4

layer-0 layer-1

0.2

layer-2 layer-3

0.0 0

20 40 60 80 100

Epoch

Figure 19: Loss and correlation between teacher and student nodes over optimization, all using BatchNorm.

Gaussian (left) versus CIFAR10 (right). FC (top) versus CNN (bottom). Layer-0 is the lowest layer (closest

to the input). The mean best correlation steadily goes up over time.

Loss in Evaluation

Normalized Corr

6

1.0

layer-0

layer-1

4

0.8

layer-2

layer-3

2

0.6

0 0

20

40Epoch60

80 100

0.4 0

20

40 Epoch60

80 100

Loss in Evaluation

4

50

3

40

2

30

1

20

0

10

0 20 40Epoch60 80 100

Accuracy in Evaluation Normalized Corr

1.0

layer-0

layer-1

0.8

layer-2

layer-3

0.6

0.4 0

20 40 Epoch60 80 100

6 5

1.0 0.8

layer-0 layer-1

Normalized Corr

4 3 2 1

0.6

layer-2 layer-3

0.4

0.2

0 20 40 60 80 100 0.0 0

20 40 60

80 100

Epoch

Epoch

Loss in Evaluation

30 20 10 0
0

80 60 40 20
20 40 60 80 100 Epoch

Accuracy in Evaluation Normalized Corr

1.0

0.8

0.6

0.4

layer-0 layer-1

0.2

layer-2 layer-3

0.0 0

20 40 60 80 100

Epoch

Figure 20: Same plots as Fig. 19 but trained without BatchNorm.

Loss in Evaluation

21

Top-% of student nodes

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

Top-% of student nodes

Top-% of student nodes

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

Top-% of student nodes

Top-% of student nodes

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Epoch (0=initialization)

Top-% of student nodes

Top-% of student nodes

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Epoch (0=initialization)

Top-% of student nodes

Figure 21: Mean/Median rank at different epoch of the final winning student nodes that best match the teacher nodes after the training with BatchNorm. Gaussian (left) and CIFAR10 (right). FC (top) and CNN (bottom). For training without BatchNorm, see Fig. 23.

Top-% of student nodes

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

Top-% of student nodes

Top-% of student nodes

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

Top-% of student nodes

Top-% of student nodes

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Epoch (0=initialization)

Top-% of student nodes

Top-% of student nodes

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Baseline epoch (0=initialization)

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

00 1 2 3 4 5 6 7 8 9 Epoch (0=initialization)

Top-% of student nodes

Figure 22: Mean/Median rank at different epoch of the final winning student nodes that best match the teacher nodes after the training using BatchNorm. Gaussian (left) versus CIFAR10 (right). FC (top) versus CNN (bottom).

Top-% of student nodes

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

Top-% of student nodes

Top-% of student nodes

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

Top-% of student nodes

Top-% of student nodes

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

M50ean
40

Rank

of

final

winner

of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

Top-% of student nodes

Top-% of student nodes

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

M5e0dian
40

Rank

of

final

winner of students
layer-0 layer-1

30

layer-2 layer-3

20

10

0 0 B1ase2line3epo4ch 5(0=6initi7aliza8tio9n)

Top-% of student nodes

Figure 23: Mean/Median rank at different epoch of the final winning student nodes that best match the teacher nodes after the training without BatchNorm. Gaussian (left) versus CIFAR10 (right). FC (top) versus CNN (bottom).

22

Loss in Evaluation

6

1.0

Normalized Corr

4

0.8

2

0.6

0 0

10

20

30

40 0.4 0

Epoch

layer-0 layer-1 layer-2 layer-3

10

20

30

40

Epoch

Normalized Corr

6

1.0

layer-0

layer-1

4

0.8

layer-2

layer-3

2

0.6

0 0

20 40 60 80 100 0.4 0

20

40

60 80 100

Epoch

Epoch

Loss in Evaluation

Loss in Evaluation

5

1.0

Normalized Corr

4 3

0.8

2

0.6

1

0 0

10

20

30

40 0.4 0

Epoch

layer-0 layer-1 layer-2 layer-3

10

20

30

40

Epoch

Normalized Corr

6

1.0

layer-0

layer-1

4

0.8

layer-2

layer-3

2

0.6

0 0

20 40 60 80 100 0.4 0

20

40 60 80 100

Epoch

Epoch

Loss in Evaluation

Figure 24: Gaussian data with small (10-15-20-25) and large (50-75-100-125) FC models. Small models (top) versus large models (bottom). With BN (left) versus Without BN (right).

Loss in Evaluation

6

1.0

Normalized Corr

5

0.8

4

0.6

3

0.4

2 1
0

10

Ep2o0ch

30

0.2 40 0.0 0

6

1.0

Normalized Corr

5

0.8

4

0.6

3

0.4

2 1
0

10

20

30

0.2 40 0.0 0

Epoch

layer-0 layer-1 layer-2 layer-3

10

E2p0och

30

40

layer-0 layer-1 layer-2 layer-3

10

20

30

40

Epoch

Loss in Evaluation

Loss in Evaluation

6

1.0

Normalized Corr

0.8

4

0.6

2

0.4

layer-0 layer-1

0.2

0 0

20

40Epoch60

80 100

0.0 0

20

40 Epoch60

layer-2 layer-3 80 100

6 5

1.0 0.8

layer-0 layer-1

Normalized Corr

4 3 2 1

0.6

layer-2 layer-3

0.4

0.2

0 20 40 60 80 100 0.0 0

20

40 60 80 100

Epoch

Epoch

Loss in Evaluation

Figure 25: Gaussian CNN. With BN (top) versus Without BN (bottom). Finite Dataset (left) versus Infinite Dataset (right).

23

