SciPost Physics

Submission

QuCumber: wavefunction reconstruction with neural networks
Matthew J. S. Beach1,2, Isaac De Vlugt2, Anna Golubeva1,2, Patrick Huembeli1,3, Bohdan Kulchytskyy1,2, Xiuzhe Luo2, Roger G. Melko1,2*, Ejaaz Merali2, Giacomo Torlai1,2,4
1 Perimeter Institute for Theoretical Physics, Waterloo, Ontario N2L 2Y5, Canada 2 Department of Physics and Astronomy, University of Waterloo, Ontario N2L 3G1, Canada
3 ICFO-Institut de Ciencies Fotoniques, Barcelona Institute of Science and Technology, 08860 Castelldefels (Barcelona), Spain
4 Center for Computational Quantum Physics, Flatiron Institute, 162 5th Avenue, New York, NY 10010, USA * rgmelko@uwaterloo.ca
December 27, 2018

arXiv:1812.09329v1 [quant-ph] 21 Dec 2018

Abstract
As we enter a new era of quantum technology, it is increasingly important to develop methods to aid in the accurate preparation of quantum states for a variety of materials, matter, and devices. Computational techniques can be used to reconstruct a state from data, however the growing number of qubits demands ongoing algorithmic advances in order to keep pace with experiments. In this paper, we present an open-source software package called QuCumber that uses machine learning to reconstruct a quantum state consistent with a set of projective measurements. QuCumber uses a restricted Boltzmann machine to efficiently represent the quantum wavefunction for a large number of qubits. New measurements can be generated from the machine to obtain physical observables not easily accessible from the original data.

Contents

1 Introduction

2

2 Positive wavefunctions

3

2.1 Setup

3

2.2 Training

4

2.3 Reconstruction of physical observables

5

2.3.1 Diagonal observables

6

2.3.2 Off-diagonal observables

7

2.3.3 Entanglement entropy

8

3 Complex wavefunctions

9

3.1 Setup

11

3.2 Training

12

1

SciPost Physics
4 Conclusion A Glossary References

Submission
13 14 16

1 Introduction
Current advances in fabricating quantum technologies, as well as in reliable control of synthetic quantum matter, are leading to a new era of quantum hardware where highly pure quantum states are routinely prepared in laboratories. With the growing number of controlled quantum degrees of freedom, such as superconducting qubits, trapped ions, and ultracold atoms [1­4], reliable and scalable classical algorithms are required for the analysis and verification of experimentally prepared quantum states. Efficient algorithms can aid in extracting physical observables otherwise inaccessible from experimental measurements, as well as in identifying sources of noise to provide direct feedback for improving experimental hardware. However, traditional approaches for reconstructing unknown quantum states from a set of measurements, such as quantum state tomography, often suffer the exponential overhead that is typical of quantum many-body systems.
Recently, an alternative path to quantum state reconstruction was put forward, based on modern machine learning (ML) techniques [5­9]. The most common approach relies on a powerful generative model called a restricted Boltzmann machine (RBM) [10], a stochastic neural network with two layers of binary units. A visible layer v describes the physical degrees of freedom, while a hidden layer h is used to capture high-order correlations between the visible units. Given a set of neural network parameters , the RBM defines a probabilistic model described by the parametric distribution p(v). RBMs have been widely used in the ML community for the pre-training of deep neural networks [11], for compressing high-dimensional data into lower-dimensional representations [12], and more [13]. More recently, RBMs have been adopted by the physics community in the context of representing both classical and quantum many-body states [14­16]. They are currently being investigated for their representational power [17­19], their relationship with tensor networks and the renormalization group [20­24], and in other contexts in quantum many-body physics [25­27].
In this post, we present QuCumber: a quantum calculator used for many-body eigenstate reconstruction. QuCumber is an open-source Python package that implements neural-network quantum state reconstruction of many-body wavefunctions from measurement data. Some examples include magnetic spin projections, orbital occupation number, polarization of photons, or the logical state of qubits. Given a training dataset of measurements, QuCumber discovers the most likely quantum state compatible with the measurements by finding the optimal set of parameters  of an RBM. A properly trained RBM is an approximation of the unknown quantum state underlying the data. It can be used to calculate various physical observables of interest, including measurements that may not be possible in the original experiment.
This post is organized as follows. In Section 2, we introduce the reconstruction technique for the case where all coefficients of the wavefunction are real and positive. We discuss the required format for input data, as well as training of the RBM and the reconstruction of typical observables. In Section 3, we consider the more general case of a complex-valued
2

SciPost Physics

Submission

wavefunction. We illustrate a general strategy to extract the phase structure from data by performing appropriate unitary rotations on the state before measurements. We then demonstrate a practical reconstruction of an entangled state of two qubits. A list of useful terms and equations can be found at the end of the post in the Glossary.

2 Positive wavefunctions

We begin by presenting the application of QuCumber to reconstruct many-body quantum

states described by wavefunctions | with positive coefficients (x) = x|  0, where

|x = |x1, . . . , xN is a reference basis for the Hilbert space of N quantum degrees of free-

dom. The neural-network quantum state reconstruction requires raw data D = (x1, x2, . . . )

generated through projective measurements of the state | in the reference basis. These

measurements adhere to the probability distribution given by the Born rule, P (x) = |(x)|2.

Since the wavefunction is strictly positive, the quantum state is completely characterized by

the measurement distribution, i.e. (x) = P (x).

The positivity of the wavefunction allows a simple and natural connection between quan-

tum states and classical probabilistic models. QuCumber employs the probability distribution

p(x) of an RBM to approximate the distribution P (x) underlying the measurement data.

Using contrastive divergence (CD) [11], QuCumber trains the RBM to discover an optimal

set of parameters that minimize the Kullback-Leibler (KL) divergence between the two dis-

tributions. Upon successful training (p(x)  P (x)), we obtain a faithful representation of

the target quantum state,

(x)  p(x) (x) .

(1)

In the following, we demonstrate the application of QuCumber for the reconstruction of

the ground-state wavefunction of the one-dimensional transverse-field Ising model (TFIM).

The Hamiltonian is

H^ = -J ^iz^iz+1 - h ^ix ,

(2)

i

i

where ^ix/z are spin-1/2 Pauli operators acting on site i, and we assume open boundary conditions. For this example, we consider a chain with N = 10 spins at the quantum critical
point J = h = 1.

2.1 Setup
Given the small size of the system, the ground state | can be found with exact diagonalization. The training dataset D is generated by sampling the distribution P (z) = |(z)|2, obtaining a sequence of NS = 105 independent spin projections in the reference basis x = z.1 Each data point in D consists of an array jz = (1z, . . . , Nz ) with shape (N,) and should be passed to QuCumber as a numpy array or torch tensor. For example, jz = np.array([1,0,1,1,0,1,0,0,0,1]), where we use jz = 0, 1 to represent a spin-down and spin-up state respectively. Therefore, the entire input data set is contained in an array with shape (N_S, N).
1 The training dataset can be downloaded from https://github.com/PIQuIL/QuCumber/blob/master/ examples/Tutorial1 TrainPosRealWavefunction/tfim1d data

3

SciPost Physics

Submission

Aside from the training data, QuCumber also allows us to import an exact wavefunction. This can be useful for monitoring the quality of the reconstruction during training. In our example, we evaluate the fidelity between the reconstructed state (x) and the exact wavefunction (x). The training dataset, train_data, and the exact ground state, true_psi, are loaded with the data loading utility as follows:
import qucumber.utils.data as data train_path = "tfim1d_data.txt" psi_path = "tfim1d_psi.txt" train_data , true_psi = data.load_data(train_path , psi_path)
If psi_path is not provided, QuCumber will load only the training data. Next, we initialize an RBM quantum state (x) with random weights and zero biases
using the constructor PositiveWavefunction:
from qucumber.nn_states import PositiveWavefunction state = PositiveWavefunction(num_visible=10, num_hidden =10)
The number of visible units (num_visible) must be equal to the number of physical spins N , while the number of hidden units (num_hidden) can be adjusted to systematically increase the representational power of the RBM.
The quality of the reconstruction will depend on the structure underlying the specific quantum state and the ratio of visible to hidden units,  = num_hidden/num_visible. In practice, we find that  = 1 often leads to good approximations of positive wavefunctions [5]. However, in the general case, the value of  required for a given wavefunction should be explored and adjusted by the user.
2.2 Training
Once an appropriate representation of the quantum state has been defined, QuCumber trains the RBM through the function PositiveWavefunction.fit. Several input parameters need to be provided aside from the training dataset (train_data). These include the number of training iterations (epochs), the number of samples used for the positive/negative phase of CD (pos_batch_size/neg_batch_size), the learning rate (lr) and the number of sampling steps in the negative phase of CD (k). The last argument (callbacks) allows the user to pass a set of additional functions to be evaluated during training.
As an example of a callback, we show the MetricEvaluator, which evaluates a function log_every epochs during training. Given the small system size and the knowledge of the true ground state, we can evaluate the fidelity between the RBM state and the true ground-state wavefunction (true_psi). Similarly, we can calculate the KL divergence between the RBM distribution p(x), and the data distribution P (x), which should approach zero for a properly trained RBM. For the current example, we monitor the fidelity and KL divergence (defined in qucumber.utils.training_statistics):
from qucumber.callbacks import MetricEvaluator import qucumber.utils.training_statistics as ts log_every = 10 space = state.generate_hilbert_space (10) callbacks = [
MetricEvaluator( log_every ,
4

SciPost Physics

Submission

{"Fidelity": ts.fidelity , "KL": ts.KL}, target_psi=true_psi , space=space , verbose=True ) ]
With verbose=True, the program will print the epoch number and all callbacks every log_every epochs. Now that the metrics to monitor during training have been chosen, we can invoke the optimization with the fit function of PositiveWavefunction.
state.fit( train_data , epochs =500 , pos_batch_size =100 neg_batch_size =100 , lr =0.01 k=5, callbacks=callbacks ,
)
Figure 1 shows the convergence of the fidelity and KL divergence during training. The convergence time will, in general, depend on the choice of hyperparameters.
The network parameters , together with the callbacks, can be saved (or loaded) to a file:
state.save( " filename . pt " , metadata ={ "fidelity": callbacks[0].Fidelity , "KL": callbacks [0].KL },
) state . load (" filename . pt ")
With this we have demonstrated to most basic aspects of QuCumber regarding training a model and verifying its accuracy. We note that in this example the evaluation utilized the knowledge of the exact ground state and the calculation of the KL divergence, which is tractable only for small system sizes. However, we point out that QuCumber is capable of carrying out the reconstruction of much larger systems. In such cases, users must rely on other estimators to evaluate the training, such as expectation values of physical observables (magnetization, energy, etc). In the following, we show how to compute diagonal and offdiagonal observables in QuCumber.
2.3 Reconstruction of physical observables
In this section, we discuss how to calculate the average value of a generic physical observable O^ from a trained RBM. We start with the case of observables that are diagonal in the reference basis where the RBM was trained. We then discuss the more general cases of off-diagonal observables and entanglement entropies.

5

SciPost Physics

Submission

Fidelity KL Divergence

1.0 0.9 0.8 0.7 0.6
0

100 200 300 400 500
Epoch

1.0
0.5
0.0 0

100 200 300 400 500
Epoch

Figure 1: The fidelity (left) and the KL divergence (right) during training for the reconstruction of the ground state of the one-dimensional TFIM.

2.3.1 Diagonal observables
We begin by considering an observable with only diagonal matrix elements, | O^ | = O where for convenience we denote the reference basis x = z as  unless otherwise stated. The expectation value of O^ is given by

O^ =

1  |()|2



O|()|2 .

(3)

The expectation value can be approximated by a Monte Carlo estimator,

O^



1 NMC

NMC
Ok
k=1

,

(4)

where the spin configurations k are sampled from the RBM distribution p(). This process is particularly efficient given the bipartite structure of the network which allows the use of block Gibbs sampling.
A simple example for the TFIM is the average longitudinal magnetization per spin, ^z = j ^jz /N , which can be calculated directly on the spin configuration sampled by the RBM (i.e., the state of the visible layer). The visible samples are obtained with the sample function of the RBM state object:
samples = state.sample(num_samples=1000, k=10)

which takes the total number of samples (num_samples) and the number of iterations (k) of a block Gibbs step as input. Once these samples are obtained, the magnetization can be calculated simply as
magnetization = samples.mul(2.0).sub(1.0). mean()

where we converted the binary samples of the RBM back into ±1 spins before taking the mean.

6

SciPost Physics

Submission

z x

1.0

0.8 0.8
0.6

0.6

0.4

0.4

0.2

0.5

1.0

1.5

2.0

h

0.5

1.0

1.5

2.0

h

Figure 2: Reconstruction of the magnetic observables for the TFIM chain with N = 10 spins. We show the average longitudinal (left) and transverse (right) magnetization per site obtained by sampling from a trained RBM. The dashed line denotes the results from exact diagonalization.

2.3.2 Off-diagonal observables

We turn now to the case of off-diagonal observables, where the expectation value assumes the

following form

O^ =

1  |()|2 

()( )O

.

(5)

This expression can once again be approximated with a Monte Carlo estimator

O^



1 NMC

NMC
O[Lk]
k=1

(6)

of the so-called local estimator of the observable:

O[Lk] =


( ) ()

O

.

(7)

As long as the matrix representation O is sufficiently sparse in the reference basis, the summation can be evaluated efficiently.

As an example, we consider the specific case of the transverse magnetization for the j-th spin, ^jx , with matrix elements

 ^jx  = j,1-j

i,j .

(8)

i=j

Therefore, the expectation values reduces to the Monte Carlo average of the local observable

(jx)[L]

=

(1, . . . , 1 - j, . . . , N ) (1, . . . , j, . . . , N )

.

(9)

evaluated on spin configurations k sampled from the RBM distribution p().
QuCumber provides an interface for sampling off-diagonal observables in the ObservableBase class. Thorough examples are available in the tutorial section in the documentation. 2 As an example, x can be written as an observable class with

2The observables tutorials are available at https://qucumber.readthedocs.io/en/stable/ examples /Tutorial3 DataGeneration CalculateObservables/tutorial sampling observables.html

7

SciPost Physics

Submission

class SigmaX(ObservableBase):
def apply(self , nn_state , samples): psi = nn_state.psi(samples) psi_ratio_sum = torch.zeros_like(psi)
for i in range(samples.shape[-1]): # sum over spin sites flip_spin(i, samples) # flip the spin at site i # add ratio psi_(-i) / psi to the running sum psi_ratio = nn_state.psi(samples) psi_ratio = cplx.elementwise_division(psi_ratio , psi) psi_ratio_sum.add_(psi_ratio) flip_spin(i, samples) # flip it back
# take real part and divide by number of spins return psi_ratio_sum [0].div_(samples.shape[-1])
The value of the observable is computed with
SigmaX.statistics_from_samples(state , samples)
Similarly, the user can define other observables like the energy. The reconstruction of two magnetic observables for the TFIM is shown in Fig. 2, where a
different RBM was trained for each value of the transverse field h. In the left plot, we show the average longitudinal magnetization per site, which can be calculated directly from the configurations sampled by the RBM. In the right plot, we show the off-diagonal observable of transverse magnetization. In both cases, QuCumber successfully discovers an optimal set of parameters  that accurately approximate the ground-state wavefunction underlying the data.

2.3.3 Entanglement entropy
A quantity of significant interest in quantum many-body systems is the amount of entanglement between a subregion A and its complement A¯. Numerically, measurement of bipartite entanglement entropy is commonly accessed through the computation of the second R´enyi entropy [28]. When one has access to a pure state wavefunction (x), R´enyi entropies can be estimated through the "Swap" operator. It is a type of an off-diagonal observable that acts on an extended product space consisting of independent copies of the wavefunction, (x)  (x), referred to as "replicas".
As the name suggests, the action of the Swap operator is to swap the spin configurations in region A between the replicas,

SwapA|A, A¯ 1  |A, A¯ 2 = |A, A¯ 1  |A, A¯ 2.

(10)

Here the subcript of the ket indicates the replica index, while the two labels inside a ket, such
as A, A¯, describe the spins configurations within the subregion and its complement. In QuCumber, the Swap operator is implemented as a routine within the entanglement
observable unit:

def swap(s1 , s2 , A): for a in A:

8

SciPost Physics

Submission

_s = s1[:, a].clone() s1[:, a] = s2[:, a] s2[:, a] = _s return s1 , s2
where s1 and s2 are batches of samples produced from each replica. While ideally those samples should be entirely independent, in order to save computational costs, QuCumber just splits a given batch into two equal parts and treats them as if they were independent samples. This is implemented within the RenyiEntropy observable,
class RenyiEntropy(ObservableBase): def apply(self , nn_state , samples , A): _ns = samples.shape[0] // 2 samples1 = samples[:_ns , :] samples2 = samples[_ns : _ns * 2, :]
The rest of the implementation is very similar to that for the transverse magnetization observable from the last section, once the amplitude of a sample is substituted with the product of amplitudes drawn from each replica.
psi_ket1 = nn_state.psi(samples1) psi_ket2 = nn_state.psi(samples2) psi_ket = cplx.elementwise_mult(psi_ket1 , psi_ket2)

3 Complex wavefunctions

For positive wavefunctions, the probability distribution underlying the outcomes of projective measurements in the reference basis contains all possible information about the unknown quantum state. However, in the more general case of a wavefunction with a non-trivial sign or phase structure, this is not the case. In this section, we consider a target quantum state where the wavefunction coefficients in the reference basis can be complex-valued, () = ()ei(). We continue to choose the reference basis as  = z. We first need to generalize the RBM representation of the quantum state to capture a generic complex wavefunction. To this end, we introduce an additional RBM with marginalized distribution pµ() parameterized by a new set of network weights and biases µ. We use this to define the quantum state as:

µ() = p()eiµ()/2

(11)

where µ() = log(pµ()) [5]. In this case, the reconstruction requires a different type of

measurement setting. It is easy to see that projective measurements in the reference basis do

not convey any information on the phases (), since P () = |()|2 = 2().

The general strategy to learn a phase structure is to apply a unitary transformation U

to the state | before the measurements, such that the resulting measurement distribution

P () = | ()|2 of the rotated state  () = | U | contains fingerprints of the phases

() (Fig. 3). In general, different rotations must be independently applied to gain full

information on the phase structure. We make the assumption of a tensor product structure

of the rotations, U =

N j=1

U^j

.

This is equivalent to a local change of basis from |

to

{|b = |1b1, . . . , NbN }, where the vector b identifies the local basis bj for each site j. The

9

SciPost Physics

Submission

target wavefunction in the new basis is given by

(b) = b| = b| |
2 qubits  = U (b, )() , 

and the resulting measurement distribution is

Pb(b) =

2
U (b, )() .



a

b

()

()

() U

0

01100 . . .

0

H

(12)
(13)
( b) = h |U | i
10110 . . .

1

11010 . . .

P ( ) = | ( )|2

1

10001 . . .

P ( b) = | ( b)|2 / cos

Figure 3: Unitary rotations for two qubits. (left) Measurements on the reference basis. (right) Measurement in the rotated basis. The unitary rotation (the Hadamard gate on qubit 0) is applied after state preparation and before the projective measurement.

To clarify the procedure, let us consider the simple example of a quantum state of two

qubits:

| =

01 ei01 |01 ,

0,1

(14)

and rotation U = H^ 0  I^1, where I^ is the identity operator and

H^ = 1 2

1 1

1 -1

(15)

is called the Hadamard gate. This transformation is equivalent to rotating the qubit 0 from the reference 0z basis the the 0x basis. A straightforward calculation leads to the following probability distribution of the projective measurement in the new basis |0x, 1 :

Pb(0x, 1)

=

201

+ 211 4

+

1

- 20x 2

01

11

cos() ,

(16)

where  = 01 -11. Therefore, the statistics collected by measuring in this basis implicitly contains partial information on the phases. To obtain the full phases structure, additional
transformations are required, one example being the rotation from the reference basis to the jy local basis, realized by the elementary gate

K^ = 1 2

1 1

-i i

.

(17)

10

SciPost Physics

Submission

3.1 Setup
We now proceed to use QuCumber to reconstruct a complex-valued wavefunction. For simplicity, we restrict ourselves to two qubits and consider the general case of a quantum state with random amplitudes 01 and random phases 01. This example is available in the online tutorial. 3 We begin by importing the required packages:
from qucumber.nn_states import ComplexWavefunction import qucumber.utils.unitaries as unitaries import qucumber.utils.cplx as cplx
Since we are dealing with a complex wavefunction, we load the corresponding module ComplexWavefunction to build the RBM quantum state µ(). Furthermore, the following additional utility modules are required: the utils.cplx backend for complex algebra, and the utils.unitaries module which contains a set of elementary local rotations. By default, the set of unitaries include local rotations to the x and y basis, implemented by the H^ and K^ gates respectively.
We continue by loading the data in QuCumber, which is done using the load_data function of the data utility:
train_path = "qubits_train.txt" train_bases_path = "qubits_train_bases.txt" psi_path = "qubits_psi.txt" bases_path = "qubits_bases.txt"

train_samples , true_psi , train_bases , bases = data.load_data( train_path , psi_path , train_bases_path , bases_path
)
As before, we may load the true target wavefunction from qubits_psi.txt, which can be used to calculate the fidelity and KL divergence. In contrast with the positive case, we now have measurements performed in different bases. Therefore, the training data consists of an array of qubits projections (0b0, 1b1) in qubits_train_samples.txt, together with the corresponding bases (b0, b1) where the measurement was taken, in qubits_train_bases.txt. Finally, QuCumber loads the set of all the bases appearing the in training dataset, stored in qubits_bases.txt. This is required to properly configure the various elementary unitary rotations that need to be applied to the RBM state during the training. For this example, we generated measurements in the following bases:

(b0, b1) = (z, z) , (x, z) , (z, x) , (y, z) , (z, y)

(18)

Finally, before the training, we initialize the set of unitary rotations and create the RBM state object. In the case of the provided dataset, the unitaries are the H^ and K^ gates. The required dictionary can be created with unitaries.create_dict(). By default, when unitaries.create_dict() is called, it will contain the identity, the H^ gate, and the K^ gate, with the keys Z, X, and Y, respectively. It is possible to add additional gates by specifying them as

U = torch.tensor([[<re_part >], [<im_part >]], dtype=torch.double) unitary_dict = unitaries.create_dict(<unitary_name >=U)

3The tutorial for complex wavefunctions can be found at https://qucumber.readthedocs.io/en/ stable/ examples/Tutorial2 TrainComplexWavefunction/tutorial qubits.html

11

SciPost Physics

Submission

where re_part, im_part, and unitary_name are to be specified by the user. We then initialize the complex RBM object with
state = ComplexWavefunction( num_visible =2 num_hidden=2, unitary_dict=unitary_dict
)
The key difference between positive and complex wavefunction reconstruction is the requirement of additional measurements in different basis. Despite this, loading the data, initializing models, and training the RBMs are all very similar to the positive case, as we now discuss.
3.2 Training
Like in the case of a positive wavefunction, for the complex case QuCumber optimizes the network parameters to minimize the KL divergence between the data and the RBM distribution. When measuring in multiple bases, the optimization now runs over the set of parameters (, µ) and minimizes the sum of KL divergences between the data distribution P (b) and the RBM distribution |µ(b)|2 for each bases b appearing in the training dataset [5]. For example, if a given training sample is measured in the basis (x, z), QuCumber applies the appropriate unitary rotation U = H^ 0  I^1 to the RBM state before collecting the gradient signal.
Similar to the case of positive wavefunction, we generate the Hilbert space (to compute fidelity and KL divergence) and initialize the callbacks
state.space = nn_state.generate_hilbert_space(nv) callbacks = [
MetricEvaluator( log_every , {"Fidelity": ts.fidelity , "KL": ts.KL}, target_psi=true_psi , bases=bases , verbose=True , space=state.space ,
) ]
The training is carried out by calling the fit function of ComplexWavefunction, given the set of hyperparameters
state.fit( train_samples , epochs =100 , pos_batch_size =10 , neg_batch_size =10 , lr =0.05 , k=5, input_bases=train_bases , callbacks=callbacks ,
)
In Fig. 4 we show the total KL divergence and the fidelity with the true two-qubit state during training. After successfully training a QuCumber model, we can once again compute expectation values of physical observables, as discussed in Section 2.3.
12

SciPost Physics

Submission

1.0

0.8

0.4

Fidelity KL Divergence

0.6
0.2 0.4

0.2

0.0

0

20 40 60 80 100

0

20 40 60 80 100

Epoch

Epoch

Figure 4: Training a complex RBM with QuCumber on random two-qubit data. We show the fidelity (left), and KL divergence (right), as a function of the training epochs.

4 Conclusion
We have introduced the open source software package QuCumber, a quantum calculator used for many-body eigenstate reconstruction. QuCumber is capable of taking input data representing projective measurements of a quantum wavefunction, and reconstructing the wavefunction using a restricted Boltzmann machine (RBM).
Once properly trained, QuCumber can produce a new set of measurements, sampled stochastically from the RBM. These samples, generated in the reference basis, can be used to verify the training of the RBM against the original data set. More importantly, they can be used to calculate expectation values of many physical observables. In fact, any expectation value typically estimated by conventional Monte Carlo methods can be implemented as an estimator in QuCumber. Such estimators may be inaccessible in the reference basis, for example. Or, they may be difficult or impossible to implement in the setup for which the original data was obtained. This is particularly relevant for experiments, where it is easy to imagine many possible observables that are inaccessible, due to fundamental or technical challenges.
Future versions of QuCumber, as well as the next generation of quantum state reconstruction software, may explore different generative models, such as variational autoencoders or generative adversarial networks. In addition, future techniques may include hybridization between machine learning and other well-established methods in computational quantum many-body physics, such as variational Monte Carlo and tensor networks.

Acknowledgements
We acknowledge M. Albergo, G. Carleo, J. Carrasquilla, D. Sehayek, and L. Hayward Sierens for stimulating discussions. We thank the Perimeter Institute for Theoretical Physics for the continuing support of PIQuIL.
Author contributions Authors are listed alphabetically. For an updated record of individual contributions, consult the repository at https://github.com/PIQuIL/QuCumber/ graphs/contributors.

13

SciPost Physics

Submission

Funding information This research was supported by the Natural Sciences and Engineering Research Council of Canada (NSERC), the Canada Research Chair program, and the Perimeter Institute for Theoretical Physics. We also gratefully acknowledge the support of NVIDIA Corporation with the donation of the Titan Xp GPU used in this work. Research at Perimeter Institute is supported by the Government of Canada through Industry Canada and by the Province of Ontario through the Ministry of Research & Innovation. P. H. acknowledges support from ICFOstepstone, funded by the Marie Sklodowska-Curie Co-funding of regional, national and international programmes (GA665884) of the European Commission, as well as by the Severo Ochoa 2016­2019' program at ICFO (SEV­2015­0522), funded by the Spanish Ministry of Economy, Industry, and Competitiveness (MINECO).

A Glossary

This section contains an overview of terms discussed in the document which are relevant for RBMs. For more detail we refer the reader to the code documentation on https://qucumber. readthedocs.io/en/stable/, and References [11, 29].

· Batch: A subset of data upon which the gradient is computed and the network parameters are adjusted accordingly. A smaller batch size often results in a more stochastic trajectory, while a large batch size more closely approximates the exact gradient and has less variance.

· Biases: Adjustable parameters in an RBM, denoted by bj and ci in Eq. (19).

· Contrastive divergence: An approximate maximum-likelihood learning algorithm for RBMs [11]. CD estimates the gradient of the effective energy (19) with respect to model parameters by using Gibbs sampling to compare the generated and target distributions.

· Energy: The energy of the joint configuration (v, h) of a RBM is defined as follows:

nv

nh

E(v, h) = - bjvj - cihi -

hiWij vj .

j=1

i=1

ij

(19)

· Effective energy: Obtained from the energy by tracing out the hidden units h; often called the "free energy" in machine learning literature.







nv

nh

nv

E(v) = - bjvj - log 1 + exp  Wijvj + ci .

j=1

i=1

j

(20)

· Epoch: A single pass through an entire training set. For example, with a training set of 1,000 samples and a batch size of 100, one epoch consists of 10 updates of the parameters.
· Hidden units: There are nh units in the hidden layer of the RBM, denoted by the vector h = (h1, . . . , hnh). The number of hidden units can be adjusted to increase the representational capacity of the RBM.

14

SciPost Physics

Submission

· Hyperparameters: A set of parameters that are not adjusted by a neural network during training. Examples include the learning rate, number of hidden units, batch size, and number of training epochs.

· Joint distribution: The RBM assigns a probability to each joint configuration (v, h) according to the Boltzmann distribution:

p(v, h)

=

1 Z

e-E(v,h)

.

(21)

· KL divergence: The Kullback-Leibler divergence, or relative entropy, is a measure of the "distance" between two probability distributions P and Q, defined as:

KL(P || Q) =

P

(v)

log

P (v) Q(v)

.

(22)

v

The KL divergence between two identical distributions is zero. Note that it is not symmetric between P and Q.

· Learning rate: The step size used in the gradient descent algorithm for the optimization of the network parameters. A small learning rate may result in better optimization but will take more time to converge. If the learning rate is too high, training might not converge or will find a poor optimum.

· Marginal distribution: Obtained by marginalizing out the hidden layer from the joint

distribution via

p(v)

=

1 Z

h

e-E(v,h)

=

1 Z

e-E

(v)

.

(23)

· QuCumber : A quantum calculator used for many-body eigenstate reconstruction.

· Parameters: The set of weights and biases  = {W , b, c} characterizing the RBM energy function. These are adjusted during training.

· Partition function: The normalizing constant of the Boltzmann distribution. It is obtained by tracing over all possible pairs of visible and hidden vectors:

Z =

e-E(v,h).

v,h

(24)

· Restricted Boltzmann Machine: A two-layer network with bidirectionally connected stochastic processing units. "Restricted" refers to the connections (or weights) between the visible and hidden units: each visible unit is connected with each hidden unit, but there are no intra-layer connections.
· Visible units: There are nv units in the visible layer of the RBM, denoted by the vector v = (v1, . . . , vnv ). These units correspond to the physical degrees of freedom. In the cases considered in this paper, the number of visible units is equal to the number of spins N .
· Weights: Wij is the symmetric connection or interaction between the visible unit vj and the hidden unit hi.

15

SciPost Physics

Submission

References
[1] A. Kandala, A. Mezzacapo, K. Temme, M. Takita, M. Brink, J. M. Chow and J. M. Gambetta, Hardware-efficient variational quantum eigensolver for small molecules and quantum magnets, Nature 549(7671), 242 (2017), doi:10.1038/nature23879.
[2] N. Moll, P. Barkoutsos, L. S. Bishop, J. M. Chow, A. Cross, D. J. Egger, Stefan Filipp, A. Fuhrer, J. M. Gambetta, M. Ganzhorn, A. Kandala, A. Mezzacapo et al., Quantum optimization using variational algorithms on near-term quantum devices, Quantum Sci. Technol. 3(3), 030503 (2018), doi:10.1088/2058-9565/aab822.
[3] H. Bernien, S. Schwartz, A. Keesling, H. Levine, A. Omran, H. Pichler, S. Choi, A. S. Zibrov, M. Endres, M. Greiner, V. Vuleti´c and M. D. Lukin, Probing manybody dynamics on a 51-atom quantum simulator, Nature 551(7682), 579 (2017), doi:10.1038/nature24622.
[4] J. Zhang, G. Pagano, P. W. Hess, A. Kyprianidis, P. Becker, H. Kaplan, A. V. Gorshkov, Z.-X. Gong and C. Monroe, Observation of a many-body dynamical phase transition with a 53-qubit quantum simulator, Nature 551(7682), 601 (2017), doi:10.1038/nature24654.
[5] G. Torlai, G. Mazzola, J. Carrasquilla, M. Troyer, R. Melko and G. Carleo, Neural-network quantum state tomography, Nature Physics 14(5), 447 (2018), doi:10.1038/s41567-018-0048-5.
[6] G. Torlai and R. G. Melko, Latent Space Purification via Neural Density Operators, Phys. Rev. Lett. 120(24), 240503 (2018), doi:10.1103/PhysRevLett.120.240503.
[7] J. Carrasquilla, G. Torlai, R. G. Melko and L. Aolita, Reconstructing quantum states with generative models (2018), ArXiv: 1810.10584.
[8] D. T. Lennon, H. Moon, L. C. Camenzind, L. Yu, D. M. Zumbu¨hl, G. A. D. Briggs, M. A. Osborne, E. A. Laird and N. Ares, Efficiently measuring a quantum device using machine learning (2018), ArXiv: 1810.10042.
[9] C. Kim, J. K. Rhee, W. Lee and J. Ahn, Mixed Quantum State Dynamics Estimation with Artificial Neural Network, In 2018 International Conference on Information and Communication Technology Convergence (ICTC), pp. 740­747, doi:10.1109/ICTC.2018.8539575 (2018).
[10] P. Smolensky, Information Processing in Dynamical Systems: Foundations of Harmony Theory, In Parallel Distributed Processing: Explorations in the Microstructure of Cognition, Volume 1: Foundations, pp. 194­281. MIT Press, ISBN 0-262-68053-X (1986).
[11] G. E. Hinton, Training Products of Experts by Minimizing Contrastive Divergence, Neural Computation 14(8), 1771 (2002), doi:10.1162/089976602760128018.
[12] G. E. Hinton and R. R. Salakhutdinov, Reducing the Dimensionality of Data with Neural Networks, Science 313(5786), 504 (2006), doi:10.1126/science.1127647.
[13] Y. LeCun, Y. Bengio and G. Hinton, Deep learning, Nature 521(7553), 436 (2015), doi:10.1038/nature14539.
16

SciPost Physics

Submission

[14] G. Torlai and R. G. Melko, Learning thermodynamics with Boltzmann machines, Phys. Rev. B 94(16), 165134 (2016), doi:10.1103/PhysRevB.94.165134.
[15] G. Carleo and M. Troyer, Solving the quantum many-body problem with artificial neural networks, Science 355(6325), 602 (2017), doi:10.1126/science.aag2302.
[16] G. Carleo, Y. Nomura and M. Imada, Constructing exact representations of quantum many-body systems with deep neural networks, Nature Communications 9(1), 5322 (2018), doi:10.1038/s41467-018-07520-3.
[17] X. Gao and L.-M. Duan, Efficient representation of quantum many-body states with deep neural networks, Nature Communications 8(1), 662 (2017), doi:10.1038/s41467-01700705-2.
[18] K. Choo, G. Carleo, N. Regnault and T. Neupert, Symmetries and Many-Body Excitations with Neural-Network Quantum States, Phys. Rev. Lett. 121(16), 167204 (2018), doi:10.1103/PhysRevLett.121.167204.
[19] I. Glasser, N. Pancotti, M. August, I. D. Rodriguez and J. I. Cirac, Neural-Network Quantum States, String-Bond States, and Chiral Topological States, Phys. Rev. X 8(1), 011006 (2018), doi:10.1103/PhysRevX.8.011006.
[20] P. Mehta and D. J. Schwab, An exact mapping between the Variational Renormalization Group and Deep Learning (2014), ArXiv: 1410.3831.
[21] M. Koch-Janusz and Z. Ringel, Mutual information, neural networks and the renormalization group, Nature Physics 14(6), 578 (2018), doi:10.1038/s41567-018-0081-4.
[22] S. Iso, S. Shiba and S. Yokoo, Scale-invariant feature extraction of neural network and renormalization group flow, Phys. Rev. E 97(5), 053304 (2018), doi:10.1103/PhysRevE.97.053304.
[23] P. M. Lenggenhager, Z. Ringel, S. D. Huber and M. Koch-Janusz, Optimal Renormalization Group Transformation from Information Theory (2018), ArXiv: 1809.09632.
[24] J. Chen, S. Cheng, H. Xie, L. Wang and T. Xiang, Equivalence of restricted Boltzmann machines and tensor network states, Phys. Rev. B 97(8), 085104 (2018), doi:10.1103/PhysRevB.97.085104.
[25] Y. Nomura, A. S. Darmawan, Y. Yamaji and M. Imada, Restricted boltzmann machine learning for solving strongly correlated quantum systems, Phys. Rev. B 96, 205152 (2017), doi:10.1103/PhysRevB.96.205152.
[26] S. Weinstein, Neural networks as "hidden" variable models for quantum systems (2018), ArXiv: 1807.03910.
[27] Y. Zheng, H. He, N. Regnault and B. A. Bernevig, Restricted boltzmann machines and matrix product states of 1d translational invariant stabilizer codes (2018), arXiv: 1812.08171.
[28] M. B. Hastings, I. Gonz´alez, A. B. Kallin and R. G. Melko, Measuring renyi entanglement entropy in quantum monte carlo simulations, Phys. Rev. Lett. 104, 157201 (2010), doi:10.1103/PhysRevLett.104.157201.
17

SciPost Physics

Submission

[29] G. E. Hinton, A practical guide to training restricted boltzmann machines, In Neural networks: Tricks of the trade, pp. 599­619. Springer, doi:10.1007/978-3-642-35289-8 32 (2012).

18

