arXiv:1802.01528v3 [cs.LG] 2 Jul 2018

The Matrix Calculus You Need For Deep Learning
Terence Parr and Jeremy Howard
July 3, 2018
(We teach in University of San Francisco's MS in Data Science program and have other nefarious projects underway. You might know Terence as the creator of the ANTLR parser generator. For more material, see Jeremy's fast.ai courses and University of San Francisco's Data Institute inperson version of the deep learning course.) HTML version (The PDF and HTML were generated from markup using bookish)
Abstract This paper is an attempt to explain all the matrix calculus you need in order to understand the training of deep neural networks. We assume no math knowledge beyond what you learned in calculus 1, and provide links to help you refresh the necessary math where needed. Note that you do not need to understand this material before you start learning to train and use deep learning in practice; rather, this material is for those who are already familiar with the basics of neural networks, and wish to deepen their understanding of the underlying math. Don't worry if you get stuck at some point along the way--just go back and reread the previous section, and try writing down and working through some examples. And if you're still stuck, we're happy to answer your questions in the Theory category at forums.fast.ai. Note: There is a reference section at the end of the paper summarizing all the key matrix calculus rules and terminology discussed here.
1

Contents

1 Introduction

3

2 Review: Scalar derivative rules

4

3 Introduction to vector calculus and partial derivatives

5

4 Matrix calculus

6

4.1 Generalization of the Jacobian . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

4.2 Derivatives of vector element-wise binary operators . . . . . . . . . . . . . . . . . . . . . . . . 9

4.3 Derivatives involving scalar expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

4.4 Vector sum reduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

4.5 The Chain Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

4.5.1 Single-variable chain rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

4.5.2 Single-variable total-derivative chain rule . . . . . . . . . . . . . . . . . . . . . . . . . 18

4.5.3 Vector chain rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

5 The gradient of neuron activation

23

6 The gradient of the neural network loss function

25

6.1 The gradient with respect to the weights . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

6.2 The derivative with respect to the bias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

7 Summary

29

8 Matrix Calculus Reference

29

8.1 Gradients and Jacobians . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

8.2 Element-wise operations on vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

8.3 Scalar expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

8.4 Vector reductions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

8.5 Chain rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

9 Notation

31

10 Resources

32

2

1 Introduction

Most of us last saw calculus in school, but derivatives are a critical part of machine learning, particularly deep neural networks, which are trained by optimizing a loss function. Pick up a machine learning paper or the documentation of a library such as PyTorch and calculus comes screeching back into your life like distant relatives around the holidays. And it's not just any old scalar calculus that pops up--you need differential matrix calculus, the shotgun wedding of linear algebra and multivariate calculus.

Well... maybe need isn't the right word; Jeremy's courses show how to become a world-class deep learning practitioner with only a minimal level of scalar calculus, thanks to leveraging the automatic differentiation built in to modern deep learning libraries. But if you really want to really understand what's going on under the hood of these libraries, and grok academic papers discussing the latest advances in model training techniques, you'll need to understand certain bits of the field of matrix calculus.

For example, the activation of a single computation unit in a neural network is typically calculated

using the dot product (from linear algebra) of an edge weight vector w with an input vector x plus

a scalar bias (threshold): z(x) =

n i

wixi

+b

=

w

· x + b.

Function

z(x)

is

called

the

unit's

affine

function and is followed by a rectified linear unit, which clips negative values to zero: max(0, z(x)).

Such a computational unit is sometimes referred to as an "artificial neuron" and looks like:

Neural networks consist of many of these units, organized into multiple collections of neurons called layers. The activation of one layer's units become the input to the next layer's units. The activation of the unit or units in the final layer is called the network output.
Training this neuron means choosing weights w and bias b so that we get the desired output for all N inputs x. To do that, we minimize a loss function that compares the network's final activation(x) with the target(x) (desired output of x) for all input x vectors. To minimize the loss, we use some variation on gradient descent, such as plain stochastic gradient descent (SGD), SGD with momentum, or Adam. All of those require the partial derivative (the gradient) of activation(x) with respect to the model parameters w and b. Our goal is to gradually tweak w and b so that the overall loss function keeps getting smaller across all x inputs.
If we're careful, we can derive the gradient by differentiating the scalar version of a common loss
3

function (mean squared error):

|x|

1 N

(target(x) - activation(x))2 = 1 N

(target(x) - max(0,

wixi + b))2

x

x

i

But this is just one neuron, and neural networks must train the weights and biases of all neurons in all layers simultaneously. Because there are multiple inputs and (potentially) multiple network outputs, we really need general rules for the derivative of a function with respect to a vector and even rules for the derivative of a vector-valued function with respect to a vector.

This article walks through the derivation of some important rules for computing partial derivatives with respect to vectors, particularly those useful for training neural networks. This field is known as matrix calculus, and the good news is, we only need a small subset of that field, which we introduce here. While there is a lot of online material on multivariate calculus and linear algebra, they are typically taught as two separate undergraduate courses so most material treats them in isolation. The pages that do discuss matrix calculus often are really just lists of rules with minimal explanation or are just pieces of the story. They also tend to be quite obscure to all but a narrow audience of mathematicians, thanks to their use of dense notation and minimal discussion of foundational concepts. (See the annotated list of resources at the end.)

In contrast, we're going to rederive and rediscover some key matrix calculus rules in an effort to explain them. It turns out that matrix calculus is really not that hard! There aren't dozens of new rules to learn; just a couple of key concepts. Our hope is that this short paper will get you started quickly in the world of matrix calculus as it relates to training neural networks. We're assuming you're already familiar with the basics of neural network architecture and training. If you're not, head over to Jeremy's course and complete part 1 of that, then we'll see you back here when you're done. (Note that, unlike many more academic approaches, we strongly suggest first learning to train and use neural networks in practice and then study the underlying math. The math will be much more understandable with the context in place; besides, it's not necessary to grok all this calculus to become an effective practitioner.)

A note on notation: Jeremy's course exclusively uses code, instead of math notation, to explain concepts since unfamiliar functions in code are easy to search for and experiment with. In this paper, we do the opposite: there is a lot of math notation because one of the goals of this paper is to help you understand the notation that you'll see in deep learning papers and books. At the end of the paper, you'll find a brief table of the notation used, including a word or phrase you can use to search for more details.

2 Review: Scalar derivative rules
Hopefully you remember some of these main scalar derivative rules. If your memory is a bit fuzzy on this, have a look at Khan academy vid on scalar derivative rules.

4

Rule
Constant Multiplication by constant Power Rule Sum Rule Difference Rule Product Rule Chain Rule

f (x)
c cf

Scalar derivative notation

with respect to x

0

c

df dx

Example

d dx

99

=

0

d dx

3x

=

3

xn f +g f -g fg f (g(x))

nxn-1

df dx

+

dg dx

df dx

-

dg dx

f

dg dx

+

df dx

g

df (u) du

du dx

,

let

u

=

g(x)

d dx

x3

=

3x2

d dx

(x2

+

3x)

=

2x

+

3

d dx

(x2

-

3x)

=

2x

-

3

d dx

x2x

=

x2

+

x2x

=

3x2

d dx

ln(x2)

=

1 x2

2x

=

2 x

There are other rules for trigonometry, exponentials, etc., which you can find at Khan Academy differential calculus course.

When a function has a single parameter, f (x), you'll often see f and f (x) used as shorthands for

d dx

f

(x).

We

recommend

against

this

notation

as

it

does

not

make

clear

the

variable

we're

taking

the derivative with respect to.

You

can

think

of

d dx

as

an

operator

that

maps

a

function

of

one

parameter

to

another

function.

That

means

that

d dx

f

(x)

maps

f (x)

to

its

derivative

with

respect

to

x,

which

is

the

same

thing

as

df (x) dx

.

Also,

if

y

= f (x), then

dy dx

=

df (x) dx

=

d dx

f

(x).

Thinking of

the derivative as an operator

helps to simplify complicated derivatives because the operator is distributive and lets us pull out

constants. For example, in the following equation, we can pull out the constant 9 and distribute

the derivative operator across the elements within the parentheses.

d 9(x + x2) = 9 d (x + x2) = 9( d x + d x2) = 9(1 + 2x) = 9 + 18x

dx

dx

dx dx

That procedure reduced the derivative of 9(x + x2) to a bit of arithmetic and the derivatives of x and x2, which are much easier to solve than the original derivative.

3 Introduction to vector calculus and partial derivatives

Neural network layers are not single functions of a single parameter, f (x). So, let's move on to

functions of multiple parameters such as f (x, y). For example, what is the derivative of xy (i.e.,

the multiplication of x and y)? In other words, how does the product xy change when we wiggle

the variables? Well, it depends on whether we are changing x or y. We compute derivatives with

respect to one variable (parameter) at a time, giving us two different partial derivatives for this two-

parameter

function

(one

for

x

and

one

for

y).

Instead

of

using

operator

d dx

,

the

partial

derivative

operator

is

 x

(a

stylized

d

and

not

the

Greek

letter

).

So,

 x

xy

and

 y

xy

are

the

partial

derivatives

of

xy;

often,

these

are

just

called

the

partials.

For

functions

of

a

single

parameter,

operator

 x

is

equivalent

to

d dx

(for

sufficiently

smooth

functions).

However,

it's

better

to

use

d dx

to

make

it

clear

you're referring to a scalar derivative.

The partial derivative with respect to x is just the usual scalar derivative, simply treating any other variable in the equation as a constant. Consider function f (x, y) = 3x2y. The partial derivative

5

with respect to x is written

 x

3x2y.

There are three constants from the perspective of

 x

:

3, 2,

and

y.

Therefore,

 x

3yx2

=

3y

 x

x2

=

3y2x

=

6yx.

The

partial

derivative

with

respect

to

y

treats

x like a constant:

 y

3x2y

=

3x2

 y

y

=

3x2

 

y y

= 3x2 × 1 = 3x2.

It's a good idea to derive these

yourself before continuing otherwise the rest of the article won't make sense. Here's the Khan

Academy video on partials if you need help.

To make it clear we are doing vector calculus and not just multivariate calculus, let's consider what

we

do

with

the

partial

derivatives

f (x,y) x

and

f (x,y) y

(another

way

to

say

 x

f

(x,

y)

and

 y

f

(x,

y))

that we computed for f (x, y) = 3x2y. Instead of having them just floating around and not organized

in any way, let's organize them into a horizontal vector. We call this vector the gradient of f (x, y)

and write it as:

f (x, y) = [ f (x, y) , f (x, y) ] = [6yx, 3x2]

x

y

So the gradient of f (x, y) is simply a vector of its partials. Gradients are part of the vector calculus world, which deals with functions that map n scalar parameters to a single scalar. Now, let's get crazy and consider derivatives of multiple functions simultaneously.

4 Matrix calculus

When we move from derivatives of one function to derivatives of many functions, we move from
the world of vector calculus to matrix calculus. Let's compute partial derivatives for two functions, both of which take two parameters. We can keep the same f (x, y) = 3x2y from the last section, but let's also bring in g(x, y) = 2x + y8. The gradient for g has two entries, a partial derivative for
each parameter:

g(x, y) 2x y8 x

= + =2 +0=2×1=2

x

x x x

and

g(x, y) = 2x + y8 = 0 + 8y7 = 8y7

y

y y

giving us gradient g(x, y) = [2, 8y7].

Gradient vectors organize all of the partial derivatives for a specific scalar function. If we have two functions, we can also organize their gradients into a matrix by stacking the gradients. When we do so, we get the Jacobian matrix (or just the Jacobian) where the gradients are rows:

J=

f (x, y) g(x, y)

=

f (x,y)
x g(x,y)
x

f (x,y)
y g(x,y)

=

6yx 2

3x2 8y7

y

Welcome to matrix calculus!

Note that there are multiple ways to represent the Jacobian. We are using the so-called numerator layout but many papers and software will use the denominator layout. This is just

6

transpose of the numerator layout Jacobian (flip it around its diagonal):
6yx 2 3x2 8y7

4.1 Generalization of the Jacobian

So far, we've looked at a specific example of a Jacobian matrix. To define the Jacobian matrix more generally, let's combine multiple parameters into a single vector argument: f (x, y, z)  f (x). (You will sometimes see notation x for vectors in the literature as well.) Lowercase letters in bold font such as x are vectors and those in italics font like x are scalars. xi is the ith element of vector x and is in italics because a single vector element is a scalar. We also have to define an orientation for vector x. We'll assume that all vectors are vertical by default of size n × 1:

x1 

x2 

x

=

  

...

  

xn

With multiple scalar-valued functions, we can combine them all into a vector just like we did with the parameters. Let y = f (x) be a vector of m scalar-valued functions that each take a vector x of length n = |x| where |x| is the cardinality (count) of elements in x. Each fi function within f returns a scalar just as in the previous section:

y1 = f1(x) y2 = f2(x)
... ym = fm(x)
For instance, we'd represent f (x, y) = 3x2y and g(x, y) = 2x + y8 from the last section as

y1 = f1(x) = 3x21x2 y2 = f2(x) = 2x1 + x82

(substituting x1 for x, x2 for y)

It's very often the case that m = n because we will have a scalar function result for each element of the x vector. For example, consider the identity function y = f (x) = x:

y1 = f1(x) = x1 y2 = f2(x) = x2
...
yn = fn(x) = xn

So we have m = n functions and parameters, in this case. Generally speaking, though, the Jacobian matrix is the collection of all m × n possible partial derivatives (m rows and n columns), which is the stack of m gradients with respect to x:

 f1(x) 



 x

f1(x)





 x1

f1(x)

 x2

f1

(x)

...

 xn

f1

(x)



y x

=

 f2(x) 

 

...

 

=

  

 x

f2(x)

 

... 

=

  

 x1

f2(x)

 x2

f2

(x)

...

...

 xn

f2

(x)

  





fm(x)

 x

fm(x)

 x1

fm

(x)

 x2

fm

(x)

...



 xn

fm(x)

7

Each

 x

fi

(x)

is

a

horizontal

n-vector

because

the

partial

derivative

is

with

respect

to

a

vector,

x,

whose length is n = |x|. The width of the Jacobian is n if we're taking the partial derivative with

respect to x because there are n parameters we can wiggle, each potentially changing the function's

value. Therefore, the Jacobian is always m rows for m equations. It helps to think about the

possible Jacobian shapes visually:

scalar f
vector
f

scalar x
f x
f x

vector x
f x
f x

The Jacobian of the identity function f (x) = x, with fi(x) = xi, has n functions and each function has n parameters held in a single vector x. The Jacobian is, therefore, a square matrix since m = n:



 x

f1(x)





 x1

f1

(x)

 x2

f1

(x)

...



 xn

f1

(x)



y

=

 

 x

f2(x)

 

=

 

 x1

f2

(x)

 x2

f2

(x)

...



 xn

f2

(x)

 

x  . . . 



...







 x

fm(x)

 x1

fm

(x)

 x2

fm(x)

...

 xn

fm

(x)



 x1

x1

 x2

x1

...



 xn

x1



=

 

 x1

x2

 x2

x2

...



 xn

x2

 



...







 x1

xn

 x2

xn

...



 xn

xn

 (and since xj xi = 0 for j = i)



 x1

x1

0

...

0 =



 x2

x2

...

...

0
0   

0

0

...



 xn

xn

1 0 . . . 0

0 1 . . . 0

=  

...

  

0 0 ... 1

= I (I is the identity matrix with ones down the diagonal)

8

Make sure that you can derive each step above before moving on. If you get stuck, just consider each element of the matrix in isolation and apply the usual scalar derivative rules. That is a generally useful trick: Reduce vector expressions down to a set of scalar expressions and then take all of the partials, combining the results appropriately into vectors and matrices at the end.
Also be careful to track whether a matrix is vertical, x, or horizontal, xT where xT means x transpose. Also make sure you pay attention to whether something is a scalar-valued function, y = ... , or a vector of functions (or a vector-valued function), y = ... .

4.2 Derivatives of vector element-wise binary operators

Element-wise binary operations on vectors, such as vector addition w + x, are important because we can express many common vector operations, such as the multiplication of a vector by a scalar, as element-wise binary operations. By "element-wise binary operations" we simply mean applying an operator to the first item of each vector to get the first item of the output, then to the second items of the inputs for the second item of the output, and so forth. This is how all the basic math operators are applied by default in numpy or tensorflow, for example. Examples that often crop up in deep learning are max(w, x) and w > x (returns a vector of ones and zeros).

We can generalize the element-wise binary operations with notation y = f (w) g(x) where m = n = |y| = |w| = |x|. (Reminder: |x| is the number of items in x.) The symbol represents any element-wise operator (such as +) and not the  function composition operator. Here's what equation y = f (w) g(x) looks like when we zoom in to examine the scalar equations:

y1 f1(w) g1(x)

y2 f2(w) g2(x)

  

...

  

=

  

...

  

yn

fn(w) gn(x)

where we write n (not m) equations vertically to emphasize the fact that the result of element-wise operators give m = n sized vector results.

Using the ideas from the last section, we can see that the general case for the Jacobian with respect to w is the square matrix:



 w1

(f1(w)

Jw

=

y w

=

 

 w1

(f2(w)







 w1

(fn(w)

g1(x)) g2(x))

 w2

(f1(w)

 w2

(f2(w)

...

g1(x)) . . . g2(x)) . . .



 wn

(f1(w)



 wn

(f2(w)

gn(x))



 w2

(fn(w)

gn(x))

...



 wn

(fn(w)

and the Jacobian with respect to x is:

 g1(x))

g2(x))

 



 gn(x))



 x1

(f1

(w)

Jx

=

y x

=

 

 x1

(f2

(w)





 x1

(fn

(w)

g1(x))

 x2

(f1(w)

g2(x))

 x2

(f2(w)

g1(x))

...

 xn

(f1(w)

g2(x))

...

 xn

(f2(w)

...

gn(x))

 x2

(fn(w)

gn(x))

...

 xn

(fn(w)

 g1(x))

g2(x))

 



 gn(x))

9

That's quite a furball, but fortunately the Jacobian is very often a diagonal matrix, a matrix that is zero everywhere but the diagonal. Because this greatly simplifies the Jacobian, let's examine in detail when the Jacobian reduces to a diagonal matrix for element-wise operations.

In

a

diagonal

Jacobian,

all

elements

off

the

diagonal

are

zero,



 wj

(fi(w)

gi(x)) = 0 where j = i.

(Notice that we are taking the partial derivative with respect to wj not wi.) Under what conditions

are those off-diagonal elements zero? Precisely when fi and gi are contants with respect to wj,

 wj

fi(w)

=



 wj

gi

(x)

=

0.

Regardless of the operator,

if those partial derivatives go to zero,

the

operation goes to zero, 0 0 = 0 no matter what, and the partial derivative of a constant is zero.

Those partials go to zero when fi and gi are not functions of wj. We know that element-wise

operations imply that fi is purely a function of wi and gi is purely a function of xi. For example,

w + x sums wi + xi. Consequently, fi(w) gi(x) reduces to fi(wi) gi(xi) and the goal becomes

 wj

fi(wi)

=

 wj

gi(xi)

=

0.

fi(wi) and

gi(xi) look

like constants

to

the

partial

differentiation

op-

erator with respect to wj when j = i so the partials are zero off the diagonal. (Notation fi(wi) is

technically an abuse of our notation because fi and gi are functions of vectors not individual elements. We should really write something like f^i(wi) = fi(w), but that would muddy the equations

further, and programmers are comfortable overloading functions, so we'll proceed with the notation

anyway.)

We'll take advantage of this simplification later and refer to the constraint that fi(w) and gi(x) access at most wi and xi, respectively, as the element-wise diagonal condition.

Under

this

condition,

the

elements

along

the

diagonal

of

the

Jacobian

are

 wi

(fi

(wi)

gi(xi)):



 w1

(f1

(w1

)

y



=

 

w 



0

g1(x1))



 w2

(f2

(w2)

g2(x2))

0

...

 wn

(fn

(wn

)


     gn(xn))

(The large "0"s are a shorthand indicating all of the off-diagonal are 0.)

More succinctly, we can write:

y







= diag w

w1 (f1(w1)

g1(x1)), w2 (f2(w2)

g2(x2)), . . . , wn (fn(wn)

gn(xn))

and

y







= diag x

x1 (f1(w1)

g1(x1)), x2 (f2(w2)

g2(x2)), . . . , xn (fn(wn)

gn(xn))

where diag(x) constructs a matrix whose diagonal elements are taken from vector x.

Because we do lots of simple vector arithmetic, the general function f (w) in the binary elementwise operation is often just the vector w. Any time the general function is a vector, we know that fi(w) reduces to fi(wi) = wi. For example, vector addition w + x fits our element-wise

10

diagonal condition because f (w) + g(x) has scalar equations yi = fi(w) + gi(x) that reduce to just yi = fi(wi) + gi(xi) = wi + xi with partial derivatives:





wi (fi(wi) + gi(xi)) = wi (wi + xi) = 1 + 0 = 1





xi (fi(wi) + gi(xi)) = xi (wi + xi) = 0 + 1 = 1

That

gives

us

(w+x) w

=

(w+x) x

=

I,

the

identity

matrix,

because

every

element

along

the

diagonal

is 1. I represents the square identity matrix of appropriate dimensions that is zero everywhere but

the diagonal, which contains all ones.

Given the simplicity of this special case, fi(w) reducing to fi(wi), you should be able to derive the Jacobians for the common element-wise binary operations on vectors:

Op Partial with respect to w

+

(w+x) w

=

diag(. . .

(wi+xi) wi

. . .)

=

diag(1)

=

I

-

(w-x) w

=

diag(. . .

(wi-xi) wi

. . .)

=

diag(1)

=

I



(wx) w

=

diag(. . .

(wi×xi) wi

. . .)

=

diag(x)

(w x) w

=

diag(. . .

(wi/xi) wi

. . .)

=

diag(. . .

1 xi

. . .)

Op Partial with respect to x

+

(w+x) x

=

I

-

(w-x) x

=

diag(. . .

(wi-xi) xi

. . .)

=

diag(-1)

=

-I



(wx) x

=

diag(w)

(w x) x

=

diag(. . .

-wi x2i

. . .)

The  and operators are element-wise multiplication and division;  is sometimes called the

Hadamard product. There isn't a standard notation for element-wise multiplication and division so

we're using an approach consistent with our general binary operation notation.

4.3 Derivatives involving scalar expansion

When we multiply or add scalars to vectors, we're implicitly expanding the scalar to a vector

and then performing an element-wise binary operation. For example, adding scalar z to vector x,

y = x + z, is really y = f (x) + g(z) where f (x) = x and g(z) = 1z. (The notation 1 represents

a vector of ones of appropriate length.) z is any scalar that doesn't depend on x, which is useful

because

then

z xi

=0

for

any

xi

and

that

will

simplify

our

partial

derivative computations.

(It's

okay to think of variable z as a constant for our discussion here.) Similarly, multiplying by a scalar,

11

y = xz, is really y = f (x)  g(z) = x  1z where  is the element-wise multiplication (Hadamard product) of the two vectors.

The partial derivatives of vector-scalar addition and multiplication with respect to vector x use our element-wise rule:

y



= diag x

. . . xi (fi(xi)

gi(z)) . . .

This follows because functions f (x) = x and g(z) = 1z clearly satisfy our element-wise diagonal condition for the Jacobian (that fi(x) refer at most to xi and gi(z) refers to the ith value of the 1z vector).

Using the usual rules for scalar partial derivatives, we arrive at the following diagonal elements of the Jacobian for vector-scalar addition:

 xi (fi(xi) + gi(z))

=

(xi + z) xi

=

xi xi

+

z xi

=

1+0

=

1

So,

 x

(x

+

z)

=

diag(1)

=

I.

Computing the partial derivative with respect to the scalar parameter z, however, results in a vertical vector, not a diagonal matrix. The elements of the vector are:

 z (fi(xi) + gi(z))

=

(xi + z) z

=

xi z

+

z z

=

0+

1

=

1

Therefore,

 z

(x

+

z

)

=

1.

The diagonal elements of the Jacobian for vector-scalar multiplication involve the product rule for scalar derivatives:

 xi (fi(xi)  gi(z))

=

z xi xi

+ z xi xi

=

0+z

=

z

So,

 x

(xz)

=

diag(1z)

=

Iz.

The partial derivative with respect to scalar parameter z is a vertical vector whose elements are:

 z (fi(xi)  gi(z))

=

z xi z

+

z xi z

=

xi

+0

=

xi

This

gives

us

 z

(xz)

=

x.

4.4 Vector sum reduction
Summing up the elements of a vector is an important operation in deep learning, such as the network loss function, but we can also use it as a way to simplify computing the derivative of vector dot product and other operations that reduce vectors to scalars.
12

Let y = sum(f (x)) =

n i=1

fi(x).

Notice

we

were

careful

here

to

leave

the

parameter

as

a

vector

x

because each function fi could use all values in the vector, not just xi. The sum is over the results

of the function and not the parameter. The gradient (1 × n Jacobian) of vector summation is:

y x

=

y x1

,

y x2

,

.

.

.

,

y xn

=

 x1

i fi(x),

 x2

i fi(x),

...,

 xn

i fi(x)

=

i



fi(x) x1

,

i

fi(x) x2

,

...,

fi(x) i xn

(move derivative inside )

(The summation inside the gradient elements can be tricky so make sure to keep your notation consistent.)

Let's look at the gradient of the simple y = sum(x). The function inside the summation is just fi(x) = xi and the gradient is then:

y =

i



fi(x) x1

,

i



fi(x) x2

,

...,

fi(x) i xn

=

Because

 xj

xi

=

0

for

j

=

i,

we

can

simplify

to:

i

xi x1

,

i

xi x2

,

...,

xi i xn

y =

 

x1 x1

,

x2 x2

,

...,

xn xn

= 1, 1, . . . , 1 = 1T

Notice that the result is a horizontal vector full of 1s, not a vertical vector, and so the gradient is 1T . (The T exponent of 1T represents the transpose of the indicated vector. In this case, it flips a vertical vector to a horizontal vector.) It's very important to keep the shape of all of your vectors and matrices in order otherwise it's impossible to compute the derivatives of complex functions.

As another example, let's sum the result of multiplying a vector by a constant scalar. If y = sum(xz) then fi(x, z) = xiz. The gradient is:

y x

=

i

 x1

xiz,

i

 x2

xiz

,

...,

i

 xn

xiz

=

 x1

x1z

,

 x2

x2z

,

...,



 xn

xn

z

= z, z, . . . , z

The derivative with respect to scalar variable z is 1 × 1:

y z

=

 z

n i=1

xiz

=

i

 z

xiz

= i xi

= sum(x)

13

4.5 The Chain Rules

We can't compute partial derivatives of very complicated functions using just the basic matrix calculus rules we've seen so far. For example, we can't take the derivative of nested expressions like sum(w + x) directly without reducing it to its scalar equivalent. We need to be able to combine our basic vector rules using what we can call the vector chain rule. Unfortunately, there are a number of rules for differentiation that fall under the name "chain rule" so we have to be careful which chain rule we're talking about. Part of our goal here is to clearly define and name three different chain rules and indicate in which situation they are appropriate. To get warmed up, we'll start with what we'll call the single-variable chain rule, where we want the derivative of a scalar function with respect to a scalar. Then we'll move on to an important concept called the total derivative and use it to define what we'll pedantically call the single-variable total-derivative chain rule. Then, we'll be ready for the vector chain rule in its full glory as needed for neural networks.

The chain rule is conceptually a divide and conquer strategy (like Quicksort) that breaks complicated expressions into subexpressions whose derivatives are easier to compute. Its power derives from the fact that we can process each simple subexpression in isolation yet still combine the intermediate results to get the correct overall result.

The chain rule comes into play when we need the derivative of an expression composed of nested

subexpressions.

For example,

we need the chain rule when confronted with expressions like

d dx

sin(x2).

The outermost expression takes the sin of an intermediate result, a nested subexpression that

squares x. Specifically, we need the single-variable chain rule, so let's start by digging into that in

more detail.

4.5.1 Single-variable chain rule

Let's start with the solution to the derivative of our nested expression:

d dx

sin(x2)

=

2xcos(x2).

It

doesn't take a mathematical genius to recognize components of the solution that smack of scalar

differentiation rules,

d dx

x2

=

2x

and

d du

sin(u)

=

cos(u).

It looks like the solution is to multiply

the derivative of the outer expression by the derivative of the inner expression or "chain the pieces

together," which is exactly right. In this section, we'll explore the general principle at work and

provide a process that works for highly-nested expressions of a single variable.

Chain rules are typically defined in terms of nested functions, such as y = f (g(x)) for single-variable chain rules. (You will also see the chain rule defined using function composition (f  g)(x), which is the same thing.) Some sources write the derivative using shorthand notation y = f (g(x))g (x), but that hides the fact that we are introducing an intermediate variable: u = g(x), which we'll see shortly. It's better to define the single-variable chain rule of f (g(x)) explicitly so we never take the derivative with respect to the wrong variable. Here is the formulation of the single-variable chain rule we recommend:
dy dy du =
dx du dx
To deploy the single-variable chain rule, follow these steps:

14

1. Introduce intermediate variables for nested subexpressions and subexpressions for both binary and unary operators; e.g., × is binary, sin(x) and other trigonometric functions are usually unary because there is a single operand. This step normalizes all equations to single operators or function applications.
2. Compute derivatives of the intermediate variables with respect to their parameters.
3. Combine all derivatives of intermediate variables by multiplying them together to get the overall result.
4. Substitute intermediate variables back in if any are referenced in the derivative equation.

The third step puts the "chain" in "chain rule" because it chains together intermediate results. Multiplying the intermediate derivatives together is the common theme among all variations of the chain rule.
Let's try this process on y = f (g(x)) = sin(x2):

1. Introduce intermediate variables. Let u = x2 represent subexpression x2 (shorthand for u(x) = x2). This gives us:

u = x2

(relative to definition f (g(x)), g(x) = x2)

y = sin(u) (y = f (u) = sin(u))

The order of these subexpressions does not affect the answer, but we recommend working in the reverse order of operations dictated by the nesting (innermost to outermost). That way, expressions and derivatives are always functions of previously-computed elements.

2. Compute derivatives.

du dx

=

2x

dy du

=

cos(u)

(Take derivative with respect to x) (Take derivative with respect to u not x)

3. Combine.

dy dy du

=

= cos(u)2x

dx du dx

4. Substitute. dy = dy du = cos(x2)2x = 2xcos(x2) dx du dx

Notice how easy it is to compute the derivatives of the intermediate variables in isolation! The
chain rule says it's legal to do that and tells us how to combine the intermediate results to get 2xcos(x2).

You can think of the combining step of the chain rule in terms of units canceling. If we let y be miles,

x

be

the

gallons

in

a

gas

tank,

and

u

as

gallons

we

can

interpret

dy dx

=

dy du du dx

as

miles tank

=

miles gallon

gallon tank

.

The gallon denominator and numerator cancel.

15

Another way to to think about the single-variable chain rule is to visualize the overall expression as a dataflow diagram or chain of operations (or abstract syntax tree for compiler people):

Changes to function parameter x bubble up through a squaring operation then through a sin

operation to change result y.

You can think of

du dx

as "getting changes from x to u" and

dy du

as

"getting changes from u to y." Getting from x to y requires an intermediate hop. The chain rule

is,

by

convention,

usually

written

from

the

output

variable

down

to

the

parameter(s),

dy dx

=

dy du

du dx

.

But, the x-to-y perspective would be more clear if we reversed the flow and used the equivalent

dy dx

=

du dx

dy du

.

Conditions under which the single-variable chain rule applies. Notice that there is a single dataflow path from x to the root y. Changes in x can influence output y in only one way. That is the condition under which we can apply the single-variable chain rule. An easier condition to remember, though one that's a bit looser, is that none of the intermediate subexpression functions, u(x) and y(u), have more than one parameter. Consider y(x) = x + x2, which would become y(x, u) = x + u after introducing intermediate variable u. As we'll see in the next section, y(x, u) has multiple paths from x to y. To handle that situation, we'll deploy the single-variable total-derivative chain rule.

As an aside for those interested in automatic differentiation, papers and library documentation use terminology forward differentiation and backward differentiation (for use in the back-propagation algorithm). From a dataflow perspective, we are computing a forward differentiation because it follows the normal data flow direction. Backward differentiation, naturally, goes the other direction and we're asking how a change in the output would affect function parameter x. Because backward differentiation can determine changes in all function parameters at once, it turns out to be much more efficient for computing the derivative of functions with lots of parameters. Forward differentiation, on the other hand, must consider how a change in each parameter, in turn, affects the function output y. The following table emphasizes the order in which partial derivatives are computed for the two techniques.

Forward differentiation from x to y Backward differentiation from y to x

dy dx

=

du dy dx du

dy dx

=

dy du du dx

Automatic differentiation is beyond the scope of this article, but we're setting the stage for a future article.

Many

readers

can

solve

d dx

sin(x2)

in

their

heads,

but

our

goal

is

a

process

that

will

work

even

for

very complicated expressions. This process is also how automatic differentiation works in libraries

like PyTorch. So, by solving derivatives manually in this way, you're also learning how to define

functions for custom neural networks in PyTorch.

16

With deeply nested expressions, it helps to think about deploying the chain rule the way a compiler
unravels nested function calls like f4(f3(f2(f1(x)))) into a sequence (chain) of calls. The result of calling function fi is saved to a temporary variable called a register, which is then passed as a parameter to fi+1. Let's see how that looks in practice by using our process on a highly-nested equation like y = f (x) = ln(sin(x3)2):

1. Introduce intermediate variables.
u1 = f1(x) = x3 u2 = f2(u1) = sin(u1) u3 = f3(u2) = u22 u4 = f4(u3) = ln(u3)(y = u4)

2. Compute derivatives.

d ux

u1

=

d x

x3

= 3x2

d u1

u2

=

d u1

sin(u1)

=

cos(u1)

d u2

u3

=

d u2

u22

= 2u2

d u3

u4

=

d u3

ln(u3

)

=

1 u3

3. Combine four intermediate values.

dy dx

=

du4 dx

=

du4 du3

du3 du2

du2 du1

du1 dx

=

1 u3

2u2cos(u1)3x2

=

6u2x2cos(u1) u3

4. Substitute.

dy dx

=

6sin(u1)x2cos(x3) u22

=

6sin(x3)x2cos(x3) sin(u1)2

=

6sin(x3)x2cos(x3) sin(x3)2

=

6x2cos(x3) sin(x3)

Here is a visualization of the data flow through the chain of operations from x to y:

At this point, we can handle derivatives of nested expressions of a single variable, x, using the chain rule but only if x can affect y through a single data flow path. To handle more complicated expressions, we need to extend our technique, which we'll do next.
17

4.5.2 Single-variable total-derivative chain rule

Our single-variable chain rule has limited applicability because all intermediate variables must be functions of single variables. But, it demonstrates the core mechanism of the chain rule, that of multiplying out all derivatives of intermediate subexpressions. To handle more general expressions such as y = f (x) = x + x2, however, we need to augment that basic chain rule.

Of

course,

we

immediately

see

dy dx

=

d dx

x

+

d dx

x2

=

1 + 2x,

but

that

is

using

the

scalar

addition

derivative rule, not the chain rule. If we tried to apply the single-variable chain rule, we'd get

the wrong answer. In fact, the previous chain rule is meaningless in this case because derivative

operator

d dx

does

not

apply

to

multivariate

functions,

such

as

u2

among

our

intermediate

variables:

u1(x)

= x2

u2(x, u1) = x + u1

(y = f (x) = u2(x, u1))

Let's

try

it

anyway

to

see

what

happens.

If

we

pretend

that

du2 du1

= 0+1 = 1

and

du1 dx

= 2x,

then

dy dx

=

du2 dx

=

du2 du1

du1 dx

=

2x

instead

of

the

right

answer

1 + 2x.

Because u2(x, u) = x + u1 has multiple parameters, partial derivatives come into play. Let's blindly apply the partial derivative operator to all of our equations and see what we get:

u1(x) x

=

u2(x,u1) u1

=

u2(x,u1)

x

2x

 u1

(x

+

u1)

=

0

+

1

=

1

 x

(x

+

u1)

=

1

+

0

=

1

(same

as

du1(x) dx

)

(something's not quite right here!)

Ooops!

The

partial

u2(x,u1) x

is

wrong

because

it

violates

a

key

assumption

for

partial

derivatives.

When taking the partial derivative with respect to x, the other variables must not vary as x varies.

Otherwise, we could not act as if the other variables were constants. Clearly, though, u1(x) = x2

is a function of x and therefore varies with x.

u2(x,u1) x

=

1+0

because

u1(x) x

=

0.

A quick look

at the data flow diagram for y = u2(x, u1) shows multiple paths from x to y, thus, making it clear

we need to consider direct and indirect (through u1(x)) dependencies on x:

A change in x affects y both as an operand of the addition and as the operand of the square operator. Here's an equation that describes how tweaks to x affect the output:
y^ = (x + x) + (x + x)2
Then, y = y^ - y, which we can read as "the change in y is the difference between the original y and y at a tweaked x."
18

If we let x = 1, then y = 1+12 = 2. If we bump x by 1, x = 1, then y^ = (1+1)+(1+1)2 = 2+4 = 6. The change in y is not 1, as u2/u1 would lead us to believe, but 6 - 2 = 4!

Enter

the

"law"

of

total

derivatives,

which

basically

says

that

to

compute

dy dx

,

we

need

to

sum

up

all possible contributions from changes in x to the change in y. The total derivative with respect to

x assumes all variables, such as u1 in this case, are functions of x and potentially vary as x varies.

The total derivative of f (x) = u2(x, u1) that depends on x directly and indirectly via intermediate

variable u1(x) is given by:

dy = f (x) = u2(x, u1) = u2 x + u2 u1 = u2 + u2 u1

dx x

x

x x u1 x x u1 x

Using this formula, we get the proper answer:

dy = f (x) = u2 + u2 u1 = 1 + 1 × 2x = 1 + 2x dx x x u1 x That is an application of what we can call the single-variable total-derivative chain rule:

f (x, u1, . . . , un) = f + f u1 + f u2 + . . . + f un = f + n f ui

x

x u1 x u2 x

un x x i=1 ui x

The total derivative assumes all variables are potentially codependent whereas the partial derivative assumes all variables but x are constants.

There is something subtle going on here with the notation. All of the derivatives are shown as partial derivatives because f and ui are functions of multiple variables. This notation mirrors that of MathWorld's notation but differs from Wikipedia, which uses df (x, u1, . . . , un)/dx instead (possibly to emphasize the total derivative nature of the equation). We'll stick with the partial derivative notation so that it's consistent with our discussion of the vector chain rule in the next section.

In practice, just keep in mind that when you take the total derivative with respect to x, other variables might also be functions of x so add in their contributions as well. The left side of the equation looks like a typical partial derivative but the right-hand side is actually the total derivative. It's common, however, that many temporary variables are functions of a single parameter, which means that the single-variable total-derivative chain rule degenerates to the single-variable chain rule.

Let's look at a nested subexpression, such as f (x) = sin(x + x2). We introduce three intermediate variables:

u1(x)

= x2

u2(x, u1) = x + u1

u3(u2) = sin(u2)

(y = f (x) = u3(u2))

and partials:

u1 x

= 2x

u2 x

=

x x

+

u2 u1

u1 x

= 1 + 1 × 2x

= 1 + 2x

f (x) x

=

u3 x

+

u3 u2

u2 x

=

0

+

cos(u2

)

u2 x

=

cos(x + x2)(1 + 2x)

19

where

both

u2 x

and

f (x) x

have

ui x

terms

that

take

into

account

the

total

derivative.

Also

notice

that

the

total

derivative

formula

always

sums

versus,

say,

multiplies

terms

f ui

ui x

.

It's tempting to think that summing up terms in the derivative makes sense because, for example,

y = x + x2 adds two terms. Nope. The total derivative is adding terms because it represents a

weighted sum of all x contributions to the change in y. For example, given y = x × x2 instead

of y = x + x2, the total-derivative chain rule formula still adds partial derivative terms. (x × x2

simplifies to x3 but for this demonstration, let's not combine the terms.) Here are the intermediate

variables and partial derivatives:

u1(x)

= x2

u2(x, u1) = xu1

(y = f (x) = u2(x, u1))

u1 x

= 2x

u2 x

= u1

(for

u2

=

x + u1,

u2 x

=

1)

u2 u1

=x

(for

u2

=

x + u1,

u2 u1

=

1)

The form of the total derivative remains the same, however:

dy dx

=

u2 x

+

u2 u1

du1 x

=

u1

+ x2x

=

x2

+ 2x2

=

3x2

It's the partials (weights) that change, not the formula, when the intermediate variable operators change.

Those readers with a strong calculus background might wonder why we aggressively introduce intermediate variables even for the non-nested subexpressions such as x2 in x + x2. We use this process for three reasons: (i) computing the derivatives for the simplified subexpressions is usually trivial, (ii) we can simplify the chain rule, and (iii) the process mirrors how automatic differentiation works in neural network libraries.

Using the intermediate variables even more aggressively, let's see how we can simplify our single-

variable

total-derivative

chain

rule

to

its

final

form.

The

goal

is

to

get

rid

of

the

f x

sticking

out

on

the front like a sore thumb:

f (x, u1, . . . , un) = f + n f ui

x

x i=1 ui x

We can achieve that by simply introducing a new temporary variable as an alias for x: un+1 = x. Then, the formula reduces to our final form:

f (u1, . . . , un+1)

n+1
=

f

ui

x

i=1 ui x

This chain rule that takes into consideration the total derivative degenerates to the single-variable

chain rule when all intermediate variables are functions of a single variable. Consequently, you

can remember this more general formula to cover both cases. As a bit of dramatic foreshadowing,

notice

that

the

summation

sure

looks

like

a

vector

dot

product,

f u

·

u x

,

or

a

vector

multiply

f u

u x

.

Before we move on, a word of caution about terminology on the web. Unfortunately, the chain rule given in this section, based upon the total derivative, is universally called "multivariable chain rule"

20

in calculus discussions, which is highly misleading! Only the intermediate variables are multivariate

functions. The overall function, say, f (x) = x + x2, is a scalar function that accepts a single

parameter x. The derivative and parameter are scalars, not vectors, as one would expect with a

so-called multivariate chain rule. (Within the context of a non-matrix calculus class, "multivariate

chain rule" is likely unambiguous.) To reduce confusion, we use "single-variable total-derivative

chain rule" to spell out the distinguishing feature between the simple single-variable chain rule,

dy dx

=

dy du

du dx

,

and

this

one.

4.5.3 Vector chain rule

Now that we've got a good handle on the total-derivative chain rule, we're ready to tackle the chain rule for vectors of functions and vector variables. Surprisingly, this more general chain rule is just as simple looking as the single-variable chain rule for scalars. Rather than just presenting the vector chain rule, let's rediscover it ourselves so we get a firm grip on it. We can start by computing the derivative of a sample vector function with respect to a scalar, y = f (x), to see if we can abstract a general formula.

y1(x) y2(x)

=

f1(x) f2(x)

=

ln(x2) sin(3x)

Let's introduce two intermediate variables, g1 and g2, one for each fi so that y looks more like y = f (g(x)):

g1(x) g2(x)

=

x2 3x

f1(g) f2(g)

=

ln(g1) sin(g2)

The derivative of vector y with respect to scalar x is a vertical vector with elements computed using the single-variable total-derivative chain rule:

y =
x

f1(g) x
f2(g) x

=

f1 g1

g1 x

+

f1 g2

g2 x

f2 g1

g1 x

+

f2 g2

g2 x

=

1 g1

2x

+

0

=

2x x2

=

2 x

0 + cos(g2)3 3cos(3x) 3cos(3x)

Ok, so now we have the answer using just the scalar rules, albeit with the derivatives grouped into a vector. Let's try to abstract from that result what it looks like in vector form. The goal is to convert the following vector of scalar operations to a vector operation.

f1 g1

g1 x

+

f1 g2

g2 x

f2 g1

g1 x

+

f2 g2

g2 x

If we split the

fi gj gj x

terms,

isolating the

gj x

terms

into a vector,

we

get

a matrix by

vector

multiplication:

f1 f1 g1 g2 f2 f2 g1 g2

g1 x g2 x

f g =
g x

21

That means that the Jacobian is the multiplication of two other Jacobians, which is kinda cool. Let's check our results:

f g =

1 g1

g x 0

0 cos(g2)

2x 3

=

1 g1

2x

+

0

0 + cos(g2)3

=

2 x
3cos(3x)

Whew! We get the same answer as the scalar approach. This vector chain rule for vectors of functions and a single parameter appears to be correct and, indeed, mirrors the single-variable chain rule. Compare the vector rule:



f g

f (g(x)) =

x

g x

with the single-variable chain rule:

d

df dg

f (g(x)) =

dx

dg dx

To make this formula work for multiple parameters or vector x, we just have to change x to vector

x

in

the

equation.

The

effect

is

that

g x

and

the

resulting

Jacobian,

f x

,

are

now

matrices

instead

of vertical vectors. Our complete vector chain rule is:

 x

f

(g(x))

=

f g g x

(Note:

matrix

multiply

doesn't

commute;

order

of

f g g x

matters)

The beauty of the vector formula over the single-variable chain rule is that it automatically takes into consideration the total derivative while maintaining the same notational simplicity. The Jacobian contains all possible combinations of fi with respect to gj and gi with respect to xj. For completeness, here are the two Jacobian components in their full glory:

 f1

g1



 f2 f (g(x)) =  g1

f1 g2 f2 g2

... ...

f1   g1

gk f2



x1
 g2

gk   x1

g1 x2 g2 x2

...

g1 
xn

...

g2  xn 

x





...

 

...

 

fm g1

fm g2

...

fm gk

gk x1

gk x2

...

gk xn

where m = |f |, n = |x|, and k = |g|. The resulting Jacobian is m × n (an m × k matrix multiplied by a k × n matrix).

Even

within

this

f g g x

formula,

we

can

simplify

further

because,

for

many

applications,

the

Jaco-

bians are square (m = n) and the off-diagonal entries are zero. It is the nature of neural networks

that the associated mathematics deals with functions of vectors not vectors of functions. For ex-

ample, the neuron affine function has term sum(w  x) and the activation function is max(0, x);

we'll consider derivatives of these functions in the next section.

As we saw in a previous section, element-wise operations on vectors w and x yield diagonal matrices

with

elements

wi xi

because

wi

is

a

function

purely

of

xi

but

not

xj

for

j

=

i.

The

same

thing

happens

here when fi is purely a function of gi and gi is purely a function of xi:

f = diag( fi )

g

gi

g = diag( gi )

x

xi

22

In this situation, the vector chain rule simplifies to:

 f (g(x)) = diag( fi )diag( gi ) = diag( fi gi )

x

gi

xi

gi xi

Therefore, the Jacobian reduces to a diagonal matrix whose elements are the single-variable chain rule values.

After slogging through all of that mathematics, here's the payoff. All you need is the vector chain rule because the single-variable formulas are special cases of the vector chain rule. The following table summarizes the appropriate components to multiply in order to get the Jacobian.

 x

f

(g(x))

=

f g g x

scalar f
vector
f

scalar x

vector

scalar

u

u

f u u x

f

u

u

x

u f x u

f

u

u

x

vector x
vector u

f

u

u

x

f

u

u

x

5 The gradient of neuron activation

We now have all of the pieces needed to compute the derivative of a typical neuron activation for a single neural network computation unit with respect to the model parameters, w and b:
activation(x) = max(0, w · x + b)
(This represents a neuron with fully connected weights and rectified linear unit activation. There are, however, other affine functions such as convolution and other activation functions, such as exponential linear units, that follow similar logic.)

Let's

worry

about

max

later

and

focus

on

computing

 w

(w

·

x

+

b)

and

 b

(w

·

x

+

b).

(Recall

that

neural networks learn through optimization of their weights and biases.) We haven't discussed the

derivative of the dot product yet, y = f (w) · g(x), but we can use the chain rule to avoid having to

memorize yet another rule. (Note notation y not y as the result is a scalar not a vector.)

The dot product w · x is just the summation of the element-wise multiplication of the elements: ni (wixi) = sum(w  x). (You might also find it useful to remember the linear algebra notation

23

w · x = wT x.) We know how to compute the partial derivatives of sum(x) and w  x but haven't looked at partial derivatives for sum(w  x). We need the chain rule for that and so we can introduce an intermediate vector variable u just as we did using the single-variable chain rule:

u = wx y = sum(u)

Once we've rephrased y, we recognize two subexpressions for which we already know the partial derivatives:

u w

=

 w

(w



x)

=

diag(x)

y u

=

 u

sum(u)

= 1T

The vector chain rule says to multiply the partials:

y = y u = 1T diag(x) = xT w u w

To check our results, we can grind the dot product down into a pure scalar function:

y = w·x

=

y wj

=

 wj

i(wixi) =

ni (wixi)

i

 wj

(wixi)

=



 wj

(wj

xj

)

=

xj

Then:

y w

=

[x1, . . . , xn]

=

xT

Hooray! Our scalar results match the vector chain rule results.

Now, let y = w · x + b, the full expression within the max activation function call. We have two different partials to compute, but we don't need the chain rule:

y w

=

 w

w

·

x

+

 w

b

=

xT + 0T

= xT

y b

=

 b

w

·

x

+

 b

b

= 0+1

=1

Let's tackle the partials of the neuron activation, max(0, w · x + b). The use of the max(0, z) function call on scalar z just says to treat all negative z values as 0. The derivative of the max function is a piecewise function. When z  0, the derivative is 0 because z is a constant. When z > 0, the derivative of the max function is just the derivative of z, which is 1:



0

z0

max(0, z) = z

dz dz

=

1

z>0

An aside on broadcasting functions across scalars. When one or both of the max arguments are vectors, such as max(0, x), we broadcast the single-variable function max across the elements. This is an example of an element-wise unary operator. Just to be clear:

max(0, x1)

max(0,

x)

=

max(0,

 

...

x2) 


max(0, xn)

24

For the derivative of the broadcast version then, we get a vector of zeros and ones where:

 xi max(0, xi) =

0

dxi dxi

=1

xi  0 xi > 0



 x1

max(0,

x1)





max(0, x)

=

 

 x2

max(0,

x2)

 

x

 ... 







 xn

max(0,

xn

)

To get the derivative of the activation(x) function, we need the chain rule because of the nested subexpression, w · x + b. Following our process, let's introduce intermediate scalar variable z to represent the affine function giving:

z(w, b, x) = w · x + b

activation(z) = max(0, z)

The vector chain rule tells us:

activation activation z

=

w

z w

which we can rewrite as follows:

activation =
w

0

z w

=

0T

1

z w

=

z w

=

xT

z0 z>0

(we

computed

z w

= xT

previously)

and then substitute z = w · x + b back in:

activation 0T w · x + b  0

w

= xT w · x + b > 0

That equation matches our intuition. When the activation function clips affine function output z to 0, the derivative is zero with respect to any weight wi. When z > 0, it's as if the max function disappears and we get just the derivative of z with respect to the weights.

Turning now to the derivative of the neuron activation with respect to b, we get:

activation =
b

0

z b

=

0

1

z b

=

1

w·x+b0 w·x+b>0

Let's use these partial derivatives now to handle the entire loss function.

6 The gradient of the neural network loss function
Training a neuron requires that we take the derivative of our loss or "cost" function with respect to the parameters of our model, w and b. Because we train with multiple vector inputs (e.g., multiple images) and scalar targets (e.g., one classification per image), we need some more notation. Let
X = [x1, x2, . . . , xN ]T
25

where N = |X|, and then let

y = [target(x1), target(x2), . . . , target(xN )]T

where yi is a scalar. Then the cost equation becomes:

1 C(w, b, X, y) =
N

N

(yi - activation(xi))2

=

1 N

N
(yi - max(0, w · xi + b))2

i=1

i=1

Following our chain rule process introduces these intermediate variables:

u(w, b, x) = max(0, w · x + b)

v(y, u) = y - u

C (v )

=

1 N

N i=1

v2

Let's compute the gradient with respect to w first.

6.1 The gradient with respect to the weights

From before, we know:



0T w · x + b  0

u(w, b, x) =

w

xT w · x + b > 0

and

v(y, u) =



(y - u) = 0T -

u

u =-

=

w w

w w

0T -xT

w·x+b0 w·x+b>0

Then, for the overall gradient, we get:

 C (v ) =



1

N
v2

w

w N

i=1

= 1 N  v2 N w
i=1

1 N v2 v =
N v w
i=1

1 N v

=

2v

N

w

i=1

1N =

2v0T = 0T w · xi + b  0

N
i=1

-2vxT

w · xi + b > 0

26

=

1N N
i=1

0T -2(yi - u)xTi

w · xi + b  0 w · xi + b > 0

1 N 0T =

w · xi + b  0

N
i=1

-2(yi - max(0, w · xi + b))xTi

w · xi + b > 0

=

1N N
i=1

0T -2(yi - (w · xi + b))xTi

w · xi + b  0 w · xi + b > 0

=

0T

w · xi + b  0

-2 N

Ni=1(yi - (w · xi + b))xTi w · xi + b > 0

=

0T

w · xi + b  0

2 N

Ni=1(w · xi + b - yi)xTi w · xi + b > 0

To interpret that equation, we can substitute an error term ei = w · xi + b - yi yielding:

C 2 =
w N

N

eixTi

(for the nonzero activation case)

i=1

From there, notice that this computation is a weighted average across all xi in X. The weights are the error terms, the difference between the target output and the actual neuron output for each xi input. The resulting gradient will, on average, point in the direction of higher cost or loss because
large ei emphasize their associated xi. Imagine we only had one input vector, N = |X| = 1, then the gradient is just 2e1xT1 . If the error is 0, then the gradient is zero and we have arrived at the minimum loss. If e1 is some small positive difference, the gradient is a small step in the direction of x1. If e1 is large, the gradient is a large step in that direction. If e1 is negative, the gradient is reversed, meaning the highest cost is in the negative direction.

Of course, we want to reduce, not increase, the loss, which is why the gradient descent recurrence relation takes the negative of the gradient to update the current position (for scalar learning rate ):

C

wt+1

=

wt

-

 w

Because the gradient indicates the direction of higher cost, we want to update x in the opposite

direction.

6.2 The derivative with respect to the bias

To optimize the bias, b, we also need the partial with respect to b. Here are the intermediate variables again:

u(w, b, x) = max(0, w · x + b)

v(y, u) = y - u

C (v )

=

1 N

N i=1

v2

27

We computed the partial with respect to the bias for equation u(w, b, x) previously:

u 0 w · x + b  0 =
b 1 w · x + b > 0

For v, the partial is:

v(y, u) 

u u 0 w · x + b  0

= (y - u) = 0 - = - =

b

b

b b -1 w · x + b > 0

And for the partial of the cost function itself we get:

 C (v ) =



1

N
v2

b

b N

i=1

= 1 N  v2 N b
i=1

1 N v2 v =
N v b
i=1

1 N v

=

2v

N

b

i=1

1 N 0 w·x+b0

=

N
i=1

-2v

w·x+b>0

1N 0

w·x+b0

=

N
i=1

-2(yi - max(0, w · xi + b))

w·x+b>0

1N 0

w·x+b0

=

N
i=1

2(w · xi + b - yi)

w·x+b>0

=

0

w · xi + b  0

2 N

Ni=1(w · xi + b - yi) w · xi + b > 0

As before, we can substitute an error term:

C 2 N

= b N

ei (for the nonzero activation case)

i=1

The partial derivative is then just the average error or zero, according to the activation level. To update the neuron bias, we nudge it in the opposite direction of increased cost:

C bt+1 = bt -  b

28

In practice, it is convenient to combine w and b into a single vector parameter rather than having to deal with two different partials: w^ = [wT , b]T . This requires a tweak to the input vector x as well but simplifies the activation function. By tacking a 1 onto the end of x, x^ = [xT , 1], w · x + b becomes w^ · x^.
This finishes off the optimization of the neural network loss function because we have the two partials necessary to perform a gradient descent.

7 Summary
Hopefully you've made it all the way through to this point. You're well on your way to understanding matrix calculus! We've included a reference that summarizes all of the rules from this article in the next section. Also check out the annotated resource link below.
Your next step would be to learn about the partial derivatives of matrices not just vectors. For example, you can take a look at the matrix differentiation section of Matrix calculus.
Acknowledgements. We thank Yannet Interian (Faculty in MS data science program at University of San Francisco) and David Uminsky (Faculty/director of MS data science) for their help with the notation presented here.

8 Matrix Calculus Reference

8.1 Gradients and Jacobians

The gradient of a function of two variables is a horizontal 2-vector:

f (x, y) f (x, y)

f (x, y) = [

,

]

x

y

The Jacobian of a vector-valued function that is a function of a vector is an m × n (m = |f | and n = |x|) matrix containing all possible scalar partial derivatives:

 f1(x) 



 x

f1(x)





 x1

f1(x)

 x2

f1(x)

.

.

.

 xn

f1(x)



y x

=

  

f2(x) ...

  

=

  

 x

f2(x) ...

  

=

  

 x1

f2(x)

 x2

f2(x)

.

.

.

 xn

f2(x)

...

  





fm(x)

 x

fm(x)

 x1

fm(x)

 x2

fm(x)

.

.

.

 xn

fm(x)

The Jacobian of the identity function f (x) = x is I.

29

8.2 Element-wise operations on vectors

Define generic element-wise operations on vectors w and x using operator such as +:

y1 f1(w) g1(x)

y2 fn(w) g2(x)

  

...

  

=

  

...

  

yn

fn(w) gn(x)

The Jacobian with respect to w (similar for x) is:



 w1

(f1(w)

Jw

=

y w

=

 

 w1

(f2(w)







 w1

(fn(w)

g1(x)) g2(x))

 w2

(f1(w)

 w2

(f2(w)

...

g1(x)) . . . g2(x)) . . .



 wn

(f1(w)



 wn

(f2(w)

gn(x))



 w2

(fn(w)

gn(x))

...



 wn

(fn(w)

 g1(x))

g2(x))

 





gn(x))

Given the constraint (element-wise diagonal condition) that fi(w) and gi(x) access at most wi and xi, respectively, the Jacobian simplifies to a diagonal matrix:

y







= diag w

w1 (f1(w1)

g1(x1)), w2 (f2(w2)

g2(x2)), . . . , wn (fn(wn)

gn(xn))

Here are some sample element-wise operators:

Op Partial with respect to w Partial with respect to x

+

(w+x) w

=

I

-

(w-x) w

=

I



(wx) w

=

diag(x)

(w x) w

=

diag(. . .

1 xi

. . .)

(w+x) x

=

I

(w-x) x

=

-I

(wx) x

=

diag(w)

(w x) x

=

diag(. . .

-wi x2i

. . .)

8.3 Scalar expansion
Adding scalar z to vector x, y = x + z, is really y = f (x) + g(z) where f (x) = x and g(z) = 1z.  (x + z) = diag(1) = I x  (x + z) = 1 z
Scalar multiplication yields:  (xz) = Iz x  (xz) = x z

30

8.4 Vector reductions

The partial derivative of a vector sum with respect to one of the vectors is:

xy =

y x

=

For y = sum(x):

xy = 1T

y x1

,

y x2

,

.

.

.

,

y xn

=

i



fi(x) x1

,

i



fi(x) x2

,

...,

fi(x) i xn

For y = sum(xz) and n = |x|, we get:

xy = [z, z, . . . , z]

zy = sum(x)
Vector dot product y = f (w) · g(x) = the vector chain rule, we get:

n i

(wixi)

=

sum(w  x).

Substituting

u

=

wx

and

using

du dx

=

d dx

(w



x)

=

diag(w)

dy du

=

d du

sum(u)

=

1T

dy dx

=

dy du

×

du dx

=

1T

× diag(w)

=

wT

Similarly,

dy dw

=

xT .

8.5 Chain rules

The vector chain rule is the general form as it degenerates to the others. When f is a function of a single variable x and all intermediate variables u are functions of a single variable, the singlevariable chain rule applies. When some or all of the intermediate variables are functions of multiple variables, the single-variable total-derivative chain rule applies. In all other cases, the vector chain rule applies.

Single-variable rule Single-variable total-derivative rule Vector rule

df dx

=

df du du dx

f (u1,...,un) x

=

f u u x

 x

f

(g(x))

=

f g

g x

9 Notation

Lowercase letters in bold font such as x are vectors and those in italics font like x are scalars. xi is the ith element of vector x and is in italics because a single vector element is a scalar. |x| means
"length of vector x."

The T exponent of xT represents the transpose of the indicated vector.

b i=a

xi

is

just

a

for-loop

that

iterates

i

from

a

to

b,

summing

all

the

xi.

31

Notation f (x) refers to a function called f with an argument of x.

I represents the square "identity matrix" of appropriate dimensions that is zero everywhere but the diagonal, which contains all ones.

diag(x) constructs a matrix whose diagonal elements are taken from vector x.

The dot product w · x is the summation of the element-wise multiplication of the elements: ni (wixi) = sum(w  x). Or, you can look at it as wT x.

Differentiation

d dx

is

an

operator

that

maps

a

function

of

one

parameter

to

another

function.

That

means

that

d dx

f

(x)

maps

f (x)

to

its

derivative

with

respect

to

x,

which

is

the

same

thing

as

df (x) dx

.

Also,

if

y

=

f (x),

then

dy dx

=

df (x) dx

=

d dx

f

(x).

The

partial

derivative

of

the

function

with

respect

to

x,

 x

f

(x),

performs

the

usual

scalar

derivative

holding all other variables constant.

The gradient of f with respect to vector x, f (x), organizes all of the partial derivatives for a specific scalar function.

The Jacobian organizes the gradients of multiple functions into a matrix by stacking them:

J=

f1(x) f2(x)

The following notation means that y has the value a upon condition1 and value b upon condition2.

y = a condition1 b condition2

10 Resources
Wolfram Alpha can do symbolic matrix algebra and there is also a cool dedicated matrix calculus differentiator.
When looking for resources on the web, search for "matrix calculus" not "vector calculus." Here are some comments on the top links that come up from a Google search:
· https://en.wikipedia.org/wiki/Matrix calculus The Wikipedia entry is actually quite good and they have a good description of the different layout conventions. Recall that we use the numerator layout where the variables go horizontally and the functions go vertically in the Jacobian. Wikipedia also has a good description of total derivatives, but be careful that they use slightly different notation than we do. We always use the x notation not dx.
· http://www.ee.ic.ac.uk/hp/staff/dmb/matrix/calculus.html This page has a section on matrix differentiation with some useful identities; this person uses numerator layout. This might
32

be a good place to start after reading this article to learn about matrix versus vector differentiation. · https://www.colorado.edu/engineering/CAS/courses.d/IFEM.d/IFEM.AppC.d/IFEM.AppC.pdf This is part of the course notes for "Introduction to Finite Element Methods" I believe by Carlos A. Felippa. His Jacobians are transposed from our notation because he uses denominator layout. · http://www.ee.ic.ac.uk/hp/staff/dmb/matrix/calculus.html This page has a huge number of useful derivatives computed for a variety of vectors and matrices. A great cheat sheet. There is no discussion to speak of, just a set of rules. · https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf Another cheat sheet that focuses on matrix operations in general with more discussion than the previous item. · https://www.comp.nus.edu.sg/~cs5240/lecture/matrix-differentiation.pdf A useful set of slides. To learn more about neural networks and the mathematics behind optimization and back propagation, we highly recommend Michael Nielsen's book. For those interested specifically in convolutional neural networks, check out A guide to convolution arithmetic for deep learning. We reference the law of total derivative, which is an important concept that just means derivatives with respect to x must take into consideration the derivative with respect x of all variables that are a function of x.
33

