,sentence,label,data
0,To Index or not to Index: Time-Space Trade-Offs in Search Engines with Positional Ranking Functions,null,null
1,Diego Arroyuelo,null,null
2,"Dept. of Informatics, Univ. Técnica F. Santa María Yahoo! Labs Santiago, Chile",null,null
3,darroyue@inf.utfsm.cl,null,null
4,Senén González ,null,null
5,"University of Chile. Yahoo! Labs Santiago, Chile",null,null
6,sgonzale@dcc.uchile.cl,null,null
7,Mauricio Marin,null,null
8,"University of Santiago, Chile Yahoo! Labs Santiago, Chile",null,null
9,mmarin@yahoo-inc.com,null,null
10,Mauricio Oyarzún,null,null
11,"University of Santiago, Chile Yahoo! Labs Santiago, Chile",null,null
12,mauricio.silvaoy@usach.cl,null,null
13,Torsten Suel §,null,null
14,CSE Department Polytechnic Institute of NYU,null,null
15,"Brooklyn, NY, 11201",null,null
16,suel@poly.edu,null,null
17,ABSTRACT,null,null
18,"Positional ranking functions, widely used in web search engines, improve result quality by exploiting the positions of the query terms within documents. However, it is well known that positional indexes demand large amounts of extra space, typically about three times the space of a basic nonpositional index. Textual data, on the other hand, is needed to produce text snippets. In this paper, we study time-space tradeoffs for search engines with positional ranking functions and text snippet generation. We consider both index-based and non-index based alternatives for positional data. We aim to answer the question of whether one should index positional data or not.",null,null
19,"We show that there is a wide range of practical time-space trade-offs. Moreover, we show that both position and textual data can be stored using about 71% of the space used by traditional positional indexes, with a minor increase in query time. This yields considerable space savings and outperforms, both in space and time, recent alternatives from the literature. We also propose several efficient compressed text representations for snippet generation, which are able to use about half of the space of current state-of-the-art alternatives with little impact in query processing time.",null,null
20,Categories and Subject Descriptors,null,null
21,H.3.3 [Information Storage and Retrieval]: Information Search and Retrieval; H.2.4 [Systems]: Textual databases,null,null
22,Partially funded by Fondecyt Grant 1-110066. CONICYT Thesis Work Support Code 78100003. Partially supported by FONDEF D09I1185. §Supported by NFS Grants IIS-0803605 and IIS-1117829.,null,null
23,"Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SIGIR'12, August 12­16, 2012, Portland, Oregon, USA. Copyright 2012 ACM 978-1-4503-1472-5/12/08 ...$15.00.",null,null
24,General Terms,null,null
25,"Algorithms, Experimentation, Performance",null,null
26,Keywords,null,null
27,"Positional indexing, text compression, index compression, wavelet trees, snippet generation.",null,null
28,1. INTRODUCTION,null,null
29,"Web search has become an important part of day-to-day life, affecting even the way in which people think and remember things [35]. Indeed, web search engines are one of the most important tools that give access to the huge amount of information stored in the web. The success of a web search engine mostly depends on its efficiency and the quality of its ranking function. To achieve efficient processing of queries, search engines use highly optimized data structures, including inverted indexes [6, 10, 25]. State-ofthe-art ranking functions, on the other hand, combine simple term-based ranking schemes such as BM25 [10], link-based methods such as Pagerank [7] or Hits [24], and up to several hundred other features derived from documents and search query logs.",null,null
30,"Recent work has focused on positional ranking functions [32, 27, 36, 28, 33, 40, 10] that improve result quality by considering the positions of the query terms in the documents. Thus, documents where the query terms occur close to each other might be ranked higher, as this could indicate that the document is highly relevant for the query. To support such positional ranking, the search engine must have access to the position data. This is commonly done by building an index for all term positions within documents, called a positional index. The goal is to obtain an index that is efficient in terms of both index size and access time.",null,null
31,"As shown in [32], positional ranking can be carried out in two phases. First, a simple term-based ranking scheme (such as BM25) defined over a Boolean filter is used to determine a set of high-scoring documents, say, the top 200 documents. In the second phase, the term positions are used to rerank these documents by refining their score values. (Additional third or fourth phases may be used to do further reranking according to hundreds of additional features [38], but",null,null
32,255,null,null
33,"this is orthogonal to our work.) Once the final set of topscoring documents has been determined (say, the top 10), it is necessary to generate appropriate text snippets, typically text surrounding the term occurrences, to return as part of the result page. This requires access to the actual text in the indexed web pages. It is well known [40, 21] that storing position data requires a considerable amount of space, typically about 3 to 5 times the space of an inverted index storing only document identifiers and term frequencies. Furthermore, storing the documents for snippet generation requires significant additional space.",null,null
34,"This paper focuses on alternative approaches to performing the above two-step document ranking process and the query snippet-generation phase. The aim is to optimize both space and query processing time. One important feature of position data is that it only needs to be accessed for a limited number of promising documents, say a few dozens or hundreds of documents. This access pattern differs from that for document identifiers and term frequencies, which are accessed more frequently, making access speed much more important. For position data, on the other hand, we could consider somewhat slower but smarter alternative representations without losing too much efficiency at query time [40].",null,null
35,"In this paper, we push this idea further and consider not storing the position data (i.e, the positional index) at all. Instead, we compute positions on the fly from a compressed representation of the text collection. We will study two alternative approaches to compressing the text collection: (1) wavelet trees [23], which are succinct data structures from the combinatorial pattern matching community, and (2) compressed document representations that support fast extraction of arbitrary documents. It has been shown that, compared to positional indexes, web-scale texts can often be compressed in much less space [21]. More importantly, these representations can be used for both positional reranking and snippet generation. One concern is how these alternatives impact query processing speed, and thus we will study the resulting trade-offs between running time and space requirement.",null,null
36,"Thus, to index or not to index position data, that is the research question that we hope to answer in this paper. To our knowledge, such alternative approaches for implementing positional ranking functions have not been rigorously compared before. Our main result is that we can store all the information needed for query processing (i.e., document identifiers, term frequencies, position data, and text) using space close to that of state-of-the-art positional indexes (which only store position data and thus cannot be used for snippet creation), with only a minor increase in query processing time. Thus, we provide new alternatives for practical compression of position and text data, outperforming recent approaches in [34].",null,null
37,"Following current practice in search engines [21, 14], we assume a scenario where there is enough space to maintain index data structures completely in main memory, in compressed form. In this scenario, large text collections are usually partitioned over a number of nodes in a cluster, such that each partition fits into the memory of its node. This paper focuses on how to organize data within each partition, as also assumed in previous work such as [21, 14].",null,null
38,2. BACKGROUND AND RELATED WORK,null,null
39,"Let D ,"" {D1, . . . , DN } be a document collection of size N ,""",null,null
40,"where each document is represented as a sequence Di[1..ni] of ni terms from a vocabulary  ,"" {1, . . . , V }. Notice that every term is represented by an integer, hence the documents are just arrays of integers. We also identify each document Di with a unique document identifier (docID) i. Given a term t   and a document Di  D, the in-document positions of t in Di is the set {j|Di[j] "", t}.",null,null
41,"Throughout this paper, we assume that all term separators (like spaces, `,', `;', `.', etc.) have been removed from the text. Also, we assume that all terms in the vocabulary have been represented in a case-insensitive way. This is in order to facilitate the search operations that we need to carry out over the documents in order to compute (on the fly) the positions of a given query term. To be able to retrieve the original text (with separators and the original case) one can use the presentation layer introduced by Farin~a et al. [17, Section 4]. This also supports removing stopwords and the use of stemming, among other vocabulary techniques. This extra layer requires extra space on top of that of the compressed text, as well as extra time to obtain the original text. However, this scheme must be used on all the alternatives that we consider in this paper, and thus we disregard the overhead introduced by the presentation layer and focus only on the low-level details of compression (but keeping in mind that the original text can still be retrieved).",null,null
42,2.1 Inverted Index Compression,null,null
43,"The efficiency of query processing in search engines relies on inverted indexes. These data structures store a set of inverted lists I1, . . . , IV , which are accessed through a vocabulary table. The list It maintains a posting for each document containing the term t  . Usually, a posting in an inverted list consists of a docID, a term frequency, and the in-document positions of the term. (In real systems, the docIDs, term frequencies and in-document positions are often stored separately.) Indexes whose postings store indocument positions are called positional inverted indexes.",null,null
44,"We assume that an inverted list It is divided into blocks of 128 documents each -- the particular choice of 128 documents per block is an implementation issue. Given a block of It, the term-position data for all the documents in that block are stored in a separate block of variable size. The inverted lists of the query terms are used to produce the result for the query. Since the query results are usually large, the result set must be ranked by relevance.",null,null
45,"For large document collections, the data stored in inverted indexes requires considerable amounts of space. Hence, the indexes must be compressed. To support efficient query processing (such as DAAT [10], WAND [9] or BMW OR [15]) and effective compression in the inverted lists, we sort them by increasing docID. Let dt[1..|It|] denote the sorted list of docIDs for the inverted list It. Then, we replace dt[1] with dt[1] - 1, and dt[i] with dt[i] - dt[i - 1] - 1 for i ,"" 2, . . . , |It|. In the case of frequencies, every fi is replaced with fi - 1, since fi > 0 always holds. For the positions, each pi,j is replaced with pi,j - pi,j-1 - 1. Then these values are encoded with integer compression schemes that take advantage of the resulting smaller integers.""",null,null
46,"There has been a lot of progress on compressing docIDs and frequencies, with many compression methods available [41, 10]. Some of them achieve, in general, a very good compression ratio, but at the expense of a lower decompression speed [10], for example Elias  and  encodings",null,null
47,256,null,null
48,"[16], or Golomb/Rice parametric encodings [22], interpolative encoding [30]. Other methods achieve a (slightly) lower compression ratio, though with much higher decompression speed, for example VByte [39], S9 [3], and PForDelta [42], among others [10]. The best compression method depends on the scenario at hand.",null,null
49,2.2 Positional Indexes,null,null
50,"Unfortunately, the scenario is not the same for compressing term positions, which is a problem where it has been difficult to make much progress. For instance, previous work [40] concludes that term positions in the documents do not follow simple distributions that could be used to improve compression (as is the case of, for instance, docIDs and frequencies). As a result, a positional index is about 3 to 5 times larger than a docID/frequency index, and becomes a bottleneck in index compression. Another important conclusion from [40] is that we may only have to access a limited amount of position data per query, and thus it might be preferable to use a method that compresses well even if its speed is slightly lower.",null,null
51,"Positions in inverted indexes are used mainly in two applications, phrase searching and positional ranking schemes. In this paper we study positional ranking, where the positions of the query terms within the documents are used to improve the performance of a standard ranking such as BM25. The rationale is that documents where the query terms appear close together could be more relevant for the query, so they should get a better score. Although we focus only on positional ranking functions, the compression schemes used in this paper allow for phrase searching as well. This scenario is left for future work.",null,null
52,"A recent work on positional indexing is that of Shan et al [34]. They propose to use the flat position indexes [11, 14] as an alternative of positional inverted indexes. The result is that docIDs, term frequencies and position data can be stored in space close to that of positional inverted lists, yielding a reduction of space usage. However, this index does not store the text, which makes it less suitable in scenarios where text snippets must be generated.",null,null
53,2.3 Snippet Generation,null,null
54,"Besides providing a ranking of the most relevant documents for a query, search engines must show query snippets and support accessing the ""in-cache"" version of the documents. Each snippet shows a portion of the result document, in order to help the user judge its likely relevance before accessing it. Turpin et al. [37] introduce a method to compress the text collection and support fast text extraction to generate snippets. However, to achieve fast extraction, they must use a compression scheme that uses more space than usual compressors. In a more recent work, Ferragina and Manzini [21] study how to store very large text collections in compressed form, such that the documents can be accessed when needed, and show how different compressors behave in such a scenario. One of their main concerns was how compressors can capture redundancies that arise very far apart in very long texts. Their results show that such large texts can often be compressed to just 5% of their original size.",null,null
55,2.4 Compressed Text Self-Indexes,null,null
56,Succinct or compressed data structures use as little space as possible to support operations as efficiently as possible.,null,null
57,"Thus, large data sets (like graphs, trees, and text collections)",null,null
58,"can be manipulated in main memory, avoiding the secondary",null,null
59,"storage. In particular, we are interested in compressed data",null,null
60,structures for text sequences. A compressed self-index is a,null,null
61,"data structure that represents a text in compressed space,",null,null
62,"supports indexed search capabilities on the text, and is able",null,null
63,to obtain any text substring efficiently [31]. It can be seen,null,null
64,as compression tools with indexed search capabilities.,null,null
65,"Given a sequence T [1..n] over an alphabet  ,"" {1, . . . , V },""",null,null
66,"we define operation rankc(T, i), for c  , as the number of",null,null
67,"occurrences of c in T [1..i]. Operation selectc(T, j) is defined",null,null
68,as the position of the j-th occurrence of c in T . A wavelet,null,null
69,tree [23] (WT for short) is a succinct data structure that sup-,null,null
70,"ports rank and select operations, among many virtues [19].",null,null
71,"A WT representing a text T is a balanced binary search tree where each node v represents a contiguous interval v ,",null,null
72,[i..j] of the sorted set . The tree root represents the whole,null,null
73,"vocabulary. v is divided at node v into two subsets, such",null,null
74,that,null,null
75,the,null,null
76,left,null,null
77,child,null,null
78,vl,null,null
79,of,null,null
80,v,null,null
81,represents,null,null
82,vl,null,null
83,",",null,null
84,[i..,null,null
85,i+j 2,null,null
86,"],",null,null
87,and,null,null
88,the,null,null
89,right child vr,null,null
90,represents vr,null,null
91,",",null,null
92,[,null,null
93,i+j 2,null,null
94,+ 1..j].,null,null
95,Each tree leaf,null,null
96,"represents a single vocabulary term. Hence, there are V",null,null
97,"leaves and the tree has height O(log V ). For simplicity, in",null,null
98,the following we assume that V is a power of two. Let T v be the subsequence of T formed by the symbols,null,null
99,"in v. Hence, T root , T . Node v stores a bit sequence Bv such that Bv[l] ,"" 1 if T v[l]  vr , and Bv[l] "","" 0 otherwise. Given a WT node v of depth i, Bv[j] "","" 1 iff the i-th mostsignificant bit in the encoding of T v[j] is 1. In this way,""",null,null
100,"given a term c  , the corresponding leaf in the tree can",null,null
101,be found by using the binary encoding of c. Every node v stores Bv augmented with a data structure for rank/select,null,null
102,"over bit sequences [31]. The number of bits of the vectors Bv stored at each tree level sum up to n, and including the",null,null
103,"data structure every level requires n + o(n) bits. Thus, the",null,null
104,"overall space is n log V + o(n log V ) bits [23, 31].",null,null
105,"Since a WT replaces the text it represents, we must be able",null,null
106,"to retrieve T [i], for 1  i  n. The idea is to navigate the",null,null
107,"tree from the root to the leaf corresponding to the unknown T [i]. To do so, we start from the root, and check if Broot[i] ,",null,null
108,"0. If so, the leaf of T [i] is contained in the left subtree vl",null,null
109,"of the root. Hence, we move to vl looking for the symbol at position rank0(Broot, i). Otherwise, we move to vr looking for the symbol at position rank1(Broot, i). This process is",null,null
110,"repeated recursively, until we reach the leaf of T [i], and runs",null,null
111,in O(log V ) time as we can implement the rank operation,null,null
112,"on bit vectors in constant time. To compute rankc(T, i), for",null,null
113,"any c  , we proceed mostly as before, using the binary",null,null
114,encoding of c to find the corresponding tree leaf. On the,null,null
115,"other hand, to support selectc(T, j), for any c  , we must",null,null
116,navigate the upward path from the leaf corresponding to,null,null
117,term c. Both operations can be implemented in O(log V ),null,null
118,time; see [31] for details.,null,null
119,"The space required by a WT is, in practice, about 1.1­1.2",null,null
120,"times the space of the text [12]. In our application to IR,",null,null
121,"this would produce an index larger than the text itself, which",null,null
122,"is excessive. To achieve compression, we can generate the",null,null
123,Huffman codes for the terms in  (this is a word-oriented,null,null
124,Huffman coding [29]) and use these codes to determine the,null,null
125,"corresponding tree leaf for each term. Hence, the tree is not",null,null
126,"balanced anymore, but has a Huffman tree shape [12] such",null,null
127,that frequent terms will be closer to the tree root than less,null,null
128,frequent ones. This achieves a total space of n(H0(T ) + 1) +,null,null
129,"o(n(H0(T ) + 1)) bits, where H0(T )  log V is the zero-order",null,null
130,257,null,null
131,"empirical entropy of T [26]. In practice, the space is about 0.6 to 0.7 times the text size [12]. However, notice that we have no good worst-case bounds for the operations, as the length of the longest Huffman code assigned to a symbol could be O(V ).",null,null
132,2.5 Self-Indexes for IR Applications,null,null
133,"There have been some recent attempts to apply alternative indexing techniques, such as self-indexes, in large-scale IR systems. In particular, we mention the work by Brisaboa et al. [8] and Arroyuelo et al. [5, 4]. The former [8] concludes that WT are competitive when compared with an inverted index for finding all the occurrences of a given query term within a single text. The latter [5, 4] extends [8] by supporting more IR-like operations on a WT. The result is that a WT can represent a document collection using n(H0 (T ) + 1) + o(n(H0(T ) + 1)) bits while supporting all the functionality of an inverted index. The experimental results in [5] compare with an inverted index storing just docIDs, which of course yields a smaller index. However, WTs also store extra information, such as the term frequencies and, most important for us here, the compressed text and thus the term-position data.",null,null
134,"Recent work [21] also tried to use (among other alternatives) a compressed self-index to compress web-scale texts, in order to allow decompression of arbitrary documents. Their conclusion is that compressed self-indexes still need a lot of progress in order to be competitive with standard compression tools, both in compression ratio and decompression speed. A contribution of our present work is a compressed self-index that is able to store web-scale texts and is competitive with the best state-of-the-art compressors. We think that this is a step forward in closing the gap between theory and practice in this area [20].",null,null
135,3. CONTRIBUTIONS,null,null
136,"In this paper we study what are the best ways to organize in-document positions and textual data, in order to efficiently support positional ranking and snippet generation in text search engines. One of our main conclusions is that some compressed representations of the textual data -- which are needed to support snippet generation -- can also be used to efficiently obtain the term positions needed by positional ranking methods. Therefore, no positional index is needed in many cases, thus saving considerable space at little cost in terms of running time.",null,null
137,Our main contributions can be summarized as follows:,null,null
138,"1. A study of several trade-offs for compressing position data. Rather than storing a positional index, we propose to compute the term positions from a compressed representation of the text. We explore and propose several compression alternatives. Our results significantly enhance current trade-offs between running time and memory space usage, enabling in this way more design choices for web search engines. One of our most interesting results is that both position and textual data can be stored in about 71% the space of current positional inverted indexes.",null,null
139,"2. A study of several alternatives for compressing textual data, extending the alternatives studied in previous work [21]. In particular, we show that using the scheme",null,null
140,"in [37] (to compress text and support efficient snippet generation) before using a standard compressor yields good time-space trade-offs, extending the alternatives introduced in [18]. It is important to note that variants of the scheme in [37] have been adopted by some commercial search engines, which makes our results of practical interest.",null,null
141,"3. We propose several improvements over wavelet trees [23], in order to make them competitive for representing document collections. We show how to improve the compression ratio by compressing the sequence associated to every node of the tree with standard compressors. The result is a practical web-scale compressed self-index that is competitive with the best state-ofthe-art compressors.",null,null
142,4. COMPRESSING TERM-POSITION AND TEXTUAL DATA,null,null
143,"Compressing in-document positions, i.e., the positions where each term occur within a document, has been recognized as a difficult task [40, 21]. Indeed, positions have become a bottleneck for compression compared to docIDs and frequencies. Moreover, recent work shows that the textual data can be compressed better than positions [21]. There are two main reasons for this. First, positions have a different distribution than docIDs and frequencies [40]. Second, since positions are stored separately for each term (recall Section 2.1), the local context for terms that is exploited by text compression schemes is not available in the positional inverted lists. Usually, positions require about 3 to 5 times the space of an inverted index storing docIDs and frequencies. Thus, efficient compression of in-document positions is an important challenge.",null,null
144,"Positional inverted indexes are the standard solution to this problem [25, 10, 6]. In particular, [40] shows a detailed study of alternative ways to compress positional inverted indexes. However, it is not clear that using the methods in [40] is the best one can do. Notice that the in-document position data can be obtained (at query time) by searching for the query terms in the documents -- a simple scan of the document suffices. Since textual data can be compressed much better than positions, this could decrease the space usage of positions. However, the question is how this impacts query performance. We investigate this issue in this paper. We assume that positions are used to support positional ranking as described in [10, 40].",null,null
145,"Another important issue in web search engines is the ability to generate snippets for the query results that allow users to decide which of the result documents they should visit. In this context, snippets have been shown to improve the effectiveness of search engines. To provide snippets, a search engine must store a (simplified) version of the documents in the collection. In the case of web search engines, this means the entire textual web, which requires a considerable amount of resources. Thus, the textual data must be compressed [21].",null,null
146,4.1 Basic Query Processing Steps for Positional Ranking and Snippet Extraction,null,null
147,"From now on we assume a search engine where positional ranking is used to score documents, and where snippets must",null,null
148,258,null,null
149,"be generated for the top-scoring documents. Thus, solving a query involves the following steps:",null,null
150,"1. Query Processing Step: Given a user query, use an inverted index to get the top-k1 documents according to some standard ranking function (e.g., BM25).",null,null
151,"2. Positional Ranking Step: Given the top-k1 documents from the previous step, get the positions of the query terms within these documents. Then rerank the results using a positional ranking functions [10, 40].",null,null
152,"3. Snippet Generation Step: After the re-ranking of previous step, get snippets of length s for the top-k2 documents, for a given k2  k1.",null,null
153,"For instance, k1 , 200 (as in [40]) and k2 , 10 (as in most commercial search engines) are typical values for them. We assume s ,"" 10 in this paper. The different values for these parameters should be chosen according to the trade-off between query time and search effectiveness that we want to achieve. Step 2 is usually supported by a positional inverted index [25, 10, 40]. Step 3 is supported by compressing the document collection and supporting the extraction of arbitrary documents. Our focus here is on alternative ways to implement the last two steps.""",null,null
154,4.2 The Baseline: Positional Inverted Lists and Compressed Textual Data,null,null
155,This section describes and evaluates baseline approaches to support term positions indexing and snippet extraction.,null,null
156,4.2.1 Positional Inverted Lists,null,null
157,"Positional inverted lists (PILs, for short) are the standard approach for indexing in-document position data in search engines [25, 10, 6]. In particular, we assume the representation explained in Section 2.1. To obtain position data at query time, given the docIDs of the top-k1 results for a given query, we identify the PIL blocks containing the desired positional index entries. Then these blocks are fully decompressed, and the corresponding positions are obtained. A drawback here is that we need to decompress the entire PIL block, even if we only need a single entry in it. Thus, we might end up decompressing, in the worst case, k1 blocks in each of the inverted lists involved in the query. Afterwards, these positions are used to rerank the top-k1 documents, as in [40].",null,null
158,"The access pattern for position data is much sparser than that for docIDs and frequencies, since positions must be obtained only for the top-k1 documents. Thus, just a few positions are decompressed from the PIL in each query. Given this sparse access pattern and the high space requirement of positions (as discussed above), it is better to use compression methods with a good compression ratio, like Golomb/Rice compression. These are slower to decompress, yet the fact that only a few positions are decompressed should not impact in the overall query running time.",null,null
159,4.2.2 Compressed Textual Data,null,null
160,"To compress the text collection and support decompressing arbitrary documents, a simple alternative that is used by several state-of-the-art search engines -- for instance Lucene [13] -- is to divide the whole collection into smaller text blocks, which are then compressed separately. The block",null,null
161,"size offers a time-space trade-off: larger blocks yield better compression, although decompression time is increased. Given the popularity [13, 21] and simplicity of this approach, we use it as the baseline for the compressed text.",null,null
162,4.2.3 Baseline Experiments,null,null
163,Experimental Setup.,null,null
164,"We show now experiments for the baseline approaches. For this we use an HP ProLiant DL380 G7 (589152-001) server, with a Quadcore Intel(R) Xeon(R) CPU E5620 @ 2.40GHz processor, with 128KB of L1 cache, 1MB of L2 cache, 2MB of L3 cache, and 96GB of RAM, running version 2.6.34.8-68.fc13.i686.PAE of Linux kernel.",null,null
165,"We use the TREC GOV2 collection, with about 25.2 million documents and about 32.86 million terms in the vocabulary. We work just with the text content of the collection (that is, we ignore the html code from the documents). This requires about 127GB in ASCII format. When we represent the terms as integers, the resulting text uses 91,634 MB. We use a subset of 10,000 random queries from the query log provided with the TREC GOV2 collection. All methods were implemented using C++, and compiled with g++ 4.4.5, with the full optimization flag -O5.",null,null
166,Experiments for Step 1.,null,null
167,"In Table 1 we show the average query time (in milliseconds per query) for the initial query processing step (Step 1 of Section 4.1). We show results for two types of queries: traditional AND queries (using DAAT query processing and BM25 ranking) and the BMW OR approach from [15], which is one of the most efficient current solutions for disjunctive queries (using a two-layer approach, which yields slightly faster query times [15]). The index for docIDs and frequencies required 9,739 MB of space, using PForDelta compression for docIDs and S16 for frequencies. Notice that the",null,null
168,Table 1: Experimental results for the initial query processing step (Step 1) for AND and OR queries.,null,null
169,top-k1 DAAT AND (ms/q) BMW OR [15] (ms/q),null,null
170,50,null,null
171,14.75,null,null
172,100,null,null
173,14.77,null,null
174,150,null,null
175,14.80,null,null
176,200,null,null
177,14.81,null,null
178,300,null,null
179,14.81,null,null
180,35.70 43.39 47.90 51.74 58.19,null,null
181,"query time for AND is almost constant (within two decimal digits) with respect to k1. The process to obtain the topk1 documents uses a heap (of size k1). However, operating the heap takes negligible time, compared to the decompression of docIDs and the DAAT process. BMW OR, on the other hand, is an early-termination technique, and thus k1 impacts the query time.",null,null
182,Experiments for Step 2.,null,null
183,"In Table 2 (first two rows) we show experimental results for obtaining positions with the baseline PILs, using two compression schemes: Rice and S16, which offer the most interesting trade-offs [40]. We also show query times for different values of k1, namely 50, 100, 150, 200 and 300 (the experiments in [40] only use k1 ,"" 200). As we can see, Rice""",null,null
184,259,null,null
185,"requires only about 90% the space of S16, but takes twice as much time. Comparing the query times of Step 2 for Rice and S16 with the query times of Step 1 in Table 1, we can see that position extraction is a small fraction of the overall time. Hence, we can use Rice to compress PILs and obtain a better space usage with only a minor increase in query time. For Rice, PILs use 2.91 times the space of the inverted index that stores docIDs and frequencies. For S16, this number is 3.22.",null,null
186,Experiments for Step 3.,null,null
187,"Table 3 shows experimental results for the baseline for compressed textual data. Just as in [21], we divide the text into blocks of 0.2MB, 0.5MB or 1.0MB, and compress each block using different standard text compression tools. In particular, we show results for lzma (which gives very good results in [21]) and Google's snappy compressor [1], which is an LZ77 compressor that is optimized for speed rather than compression ratio. These two compressors offer the most interesting trade-offs among the alternatives we tried. As it can be seen, lzma achieves much better compression ratios than snappy. The compressed space achieved for the whole text is 8,133 MB for lzma and 27,388 MB for snappy.",null,null
188,"The differences in extraction time are also considerable, with snappy being much faster. Note that [21] reports a decompression speed of about 35MB/sec for lzma. However, to obtain a given document we must first decompress the entire block that contains it. Hence, most of the 35MB per second do not correspond to any useful data. In other words, this does not measure effective decompression speed for our scenario, and thus we report per-query times rather than MB/s for both methods.",null,null
189,4.3 Computing Positions and Snippets from the Compressed Document Collection,null,null
190,"We explore next the alternative of obtaining position data directly from the compressed text. This implies that in Step 2 of the query process, k1 documents must be decompressed, rather than only k2 in Step 3, as in the baseline.",null,null
191,Using Standard Text Compressors.,null,null
192,"Our first approach is to obtain positions using the baseline for generating snippets from Section 4.2.2. In rows 3 and 4 of Table 2 we show the time-space trade-offs for this approach, using lzma and snappy compressors, and blocks of size 0.2 MB. We conclude that using lzma we can store positions and text in about half the space of PIL(the latter just storing positions). However, this approach is two orders of magnitude slower than the positional index. If we use snappy instead, we obtain an index that is 21.86% larger than PIL (Rice), and running times to obtain positions that are about an order of magnitude slower (this might be acceptable in some cases). In the following, we try to improve on both of these techniques.",null,null
193,Zero-order Compressors with Fast Text Extraction.,null,null
194,"An alternative to compressing the text that could support faster position lookups is the approach from Turpin et al. [37]. The idea is to first sort the vocabulary according to the term frequencies, and then assign term identifiers according to this order. In this way, the term identifier 0 corresponds to the most frequent term in the collection, 1",null,null
195,"to the second most frequent term, and so on. The document collection is then represented as a single sequence of identifiers, where each term identifier is encoded using VByte [2]. Note that the 128 most frequent terms in the collection are thus encoded in a single byte. Actually, [37] uses a move-to-front strategy to store the encodings: the first time a term appears in a document, it is encoded with the original code assigned as before; the remaining appearances are represented as an offset to the previous occurrence of the term. We also use this approach in our experiments.",null,null
196,"By using an integer compression scheme (such as VByte) for the text, we are able to decompress any text portion very efficiently (no text blocks are needed this time). Table 2 shows the resulting trade-offs for this alternative (see the row for ""VByte""). Notice that we improve the query time significantly, making it competitive with PILs. The higher space usage is a concern, but note that we also represent the text within this space, not just the position data as in PILs. We also tried other compression schemes, such as PForDelta and S9, obtaining poorer compression ratios and similar decompression speed. The only method that improved the compression ratio is VNibble, a variant of VByte that represents any integer with a variable number of nibbles (i.e., half bytes). As in VByte, one bit of each nibble is used as a continuation bit, so only 3 bits of each nibble are used to represent the number. The results of Table 2 show space savings of about 10% over VByte. Also, notice that we are now able to use space close to that of snappy (with blocks of 0.2 MB), yet with a better query time.",null,null
197,"The fast query time is due to two facts. First, methods like VByte and VNibble are able to decompress hundred of million integers (which in our case correspond to terms) per second [41]. Second, VByte and VNibble are able to decompress just the desired documents, without negative impact on compressed size. However, this is basically zeroorder compression, and hence we are still far from the space usage of, for instance, lzma. We address this next.",null,null
198,Natural-Language Compression Boosters.,null,null
199,"To obtain higher-order compression, we propose to use a so-called natural-language compression booster [18]. The idea is to use first a zero-order compressor on the text, then this compressed text is further compressed using some standard compression scheme. It has been shown that this can yield better compression ratios than just just using a standard compression scheme [18] (especially for smaller block sizes). In our case, we propose using Turpin et al's approach [37] as booster (using VByte and VNibble as we explained above) on the sequence of term identifiers, rather than Word Huffman or End-Tagged as in [18]. Our experiments indicate that the former are faster and use only slightly more space than the latter.",null,null
200,"In Table 2 we show the trade-offs for this approach (see the rows for approach ""Compression Boosters""). We show results for blocks of size 0.001, 0.01, 0.05, and 0.2 MB of VByte and VNibble compressed text. Overall, the reduction in space usage (compared to the original VByte approach) is considerable. Compared to lzma (0.2 MB), the result is a reduction in space usage of 16.68% (12,486 MB vs 14,987 MB), but at the cost of twice the running time as the original lzma. When using smaller blocks, however, the time to obtain positions rapidly improves, while the size does not increase too much. For snappy, on the other hand, we obtain a",null,null
201,260,null,null
202,Approach,null,null
203,Positional indexes Text compressors Zero-order Compressors Compression Boosters,null,null
204,Compressed self-indexes,null,null
205,Table 2: Experimental results for extracting term-position data (Step 2).,null,null
206,Compression Scheme,null,null
207,Space Usage,null,null
208,Position extraction time (ms/q),null,null
209,(MB),null,null
210,"k1 , 50 k1 , 100 k1 , 150 k1 , 200 k1 , 300",null,null
211,PIL(Rice) PIL(S16),null,null
212,"28,373",null,null
213,1.28,null,null
214,2.22,null,null
215,3.05,null,null
216,3.27,null,null
217,5.57,null,null
218,"31,338",null,null
219,0.74,null,null
220,1.12,null,null
221,1.43,null,null
222,1.75,null,null
223,2.51,null,null
224,lzma (0.2 MB) snappy (0.2 MB),null,null
225,"14,987 34,576",null,null
226,137.60 260.36,null,null
227,9.47,null,null
228,18.00,null,null
229,375.21 25.95,null,null
230,482.09 33.49,null,null
231,684.94 47.74,null,null
232,VByte VNibble,null,null
233,"38,339",null,null
234,0.95,null,null
235,1.91,null,null
236,2.86,null,null
237,3.81,null,null
238,5.72,null,null
239,"34,570",null,null
240,1.86,null,null
241,3.71,null,null
242,5.57,null,null
243,6.75,null,null
244,8.10,null,null
245,VByte + lzma (0.2 MB) VByte + lzma (0.05 MB) VByte + lzma (0.01 MB) VByte + lzma (0.001 MB),null,null
246,"12,486 13,981 16,762 22,340",null,null
247,256.16 70.32 19.26 6.11,null,null
248,484.35 133.18 36.51 11.60,null,null
249,716.41 192.09 52.67 16.80,null,null
250,906.54 246.94 68.00 21.72,null,null
251,"1,284.87 351.71 97.04 31.10",null,null
252,VByte + snappy (0.2 MB) VByte + snappy (0.05 MB) VByte + snappy (0.01 MB) VByte + snappy (0.001 MB),null,null
253,"20,158 20,366 22,086 27,919",null,null
254,9.71,null,null
255,18.86,null,null
256,26.41,null,null
257,34.01,null,null
258,48.69,null,null
259,2.36,null,null
260,4.48,null,null
261,6.47,null,null
262,8.36,null,null
263,11.95,null,null
264,0.82,null,null
265,1.56,null,null
266,2.25,null,null
267,2.91,null,null
268,4.17,null,null
269,0.45,null,null
270,0.86,null,null
271,1.24,null,null
272,1.60,null,null
273,2.30,null,null
274,WT(7 KB) WT(1 KB),null,null
275,"40,534",null,null
276,1.94,null,null
277,3.68,null,null
278,5.30,null,null
279,6.85,null,null
280,9.80,null,null
281,"56,917",null,null
282,0.33,null,null
283,0.62,null,null
284,1.04,null,null
285,1.15,null,null
286,1.75,null,null
287,WT(7 KB) + lzma WT(1 KB) + lzma,null,null
288,"19,628 42,359",null,null
289,19.25 7.22,null,null
290,36.59 13.54,null,null
291,52.83 19.44,null,null
292,68.36 24.97,null,null
293,97.71 35.57,null,null
294,WT(7 KB) + snappy WT(1 KB) + snappy,null,null
295,"25,122 46,778",null,null
296,14.35 2.07,null,null
297,23.76 3.61,null,null
298,39.38 5.88,null,null
299,51.02 7.32,null,null
300,74.56 10.47,null,null
301,Table 3: Experimental results for compressing the document collection (Step 3).,null,null
302,Compressor Block size Space usage Compression Ratio Snippet extraction time (ms/q),null,null
303,(MB),null,null
304,(MB),null,null
305,"k2 , 10 k2 , 30 k2 , 50",null,null
306,lzma,null,null
307,0.2,null,null
308,"14,987",null,null
309,0.5,null,null
310,"13,489",null,null
311,1.0,null,null
312,"12,682",null,null
313,16.35 14.72 13.84,null,null
314,29,null,null
315,84,null,null
316,136,null,null
317,63,null,null
318,181,null,null
319,292,null,null
320,117,null,null
321,335,null,null
322,540,null,null
323,snappy,null,null
324,0.2,null,null
325,"34,576",null,null
326,0.5,null,null
327,"34,426",null,null
328,1.0,null,null
329,"34,390",null,null
330,37.73 37.57 37.53,null,null
331,2,null,null
332,6,null,null
333,9,null,null
334,5,null,null
335,14,null,null
336,23,null,null
337,10,null,null
338,28,null,null
339,46,null,null
340,"reduction of 41.69% in space for blocks of size 0.2 MB, with a very minor increase in query time. When we reduce the block size to 0.05 MB, the query time improves even more, and becomes competitive with the time to obtain positions from PIL (Rice). We note that using more advanced techniques from [40] we could obtain about 21 to 22 GB of space for PIL, making both techniques competitive in both space and time. However, VByte + snappy also contains the text within this space, allowing for use during snippet generation. Thus, we are able to store both text and positions in a representation that uses less space than PIL, which stores only positions.",null,null
341,4.4 A Compressed Self-Index for Positions and Snippets,null,null
342,"Let T be the text obtained from the concatenation (in arbitrary order) of the documents in the collection. We represent T with a WT to obtain term positions and text snippets. Given a position i in T , one can easily obtain both the docID of the document that contains T [i] and the starting",null,null
343,"position of a given document j by means of operations rank and select [5], assuming a table of document lengths.",null,null
344,Byte-Oriented Huffman WT.,null,null
345,"Instead of a bit-oriented WT (as the ones explained in Section 2.4), we use the byte-oriented representation from [8], using the Plain Huffman encoder, which is the most efficient alternative reported in there. The idea is to first assign a Huffman code to each vocabulary term [29]. Then, we store the most significant byte of the encoding of each term in array Broot. That is, each WT node v stores an array of bytes Bv, instead of bit arrays as in Section 2.4. Next, each term in the text is assigned to one of the children of the root, depending on the first byte in the encodings. Notice that in this way the WT is 256-ary. See [8] for details.",null,null
346,"To support rank and select, we use the simple approach from [8]. Given a WT node v, we divide the corresponding byte sequence Bv into superblocks of sb bytes each. For each superblock we store 256 superblock counters, one for each possible byte. These counters tell us how many occurrences",null,null
347,261,null,null
348,"of a given byte there are in the text up to the last position of the previous superblock. Also, each superblock is divided into blocks of b bytes each. Every such block also stores 256 block counters, similarly as before. The difference is that the values of these counters are local to the superblock, hence less bits are used for them. To compute rankc(T, i), we first compute the superblock j that contains i, and use the superblock counter for c to count how many c there are in T up to superblock j - 1. Then we compute the block i that contains i and add (to the previous value) the block counter for c. Finally, we must count the number of c within block i . This is done with a sequential scan over block i . This block/superblock structure allows for time-space trade-offs. In our experiments we use sb ,"" 216. Hence, superblock counters can be stored in 16 bits each. We consider b "","" 1 KB, b "", 3 KB and b , 7 KB. Operation select is implemented by binary searching the superblock/block counters; thus no extra information is stored for this [8].",null,null
349,"To obtain position data assume that, given docID i for a top-k1 document and a query term t, we want to obtain the positions of t within Di. A simple solution could be to extract document Di from the WT, and then search for t within it (as in Section 4.3). However, the decompression speed of a WT is much slower than that of the schemes used in Section 4.3, so we must use a more efficient way. An idea is to use operation select to find every occurrence of t within Di, hence working in time proportional to the number of occurrences of the term. Let d be the starting position for document Di in T . Hence, there are r  rankt(T, d) occurrences of t before document Di, and the first occurrence of t within Di is at position j  selectt(T, r + 1), the second occurrence at position j  selectt(T, r + 2), and so on. Overall, if o is the number of occurrences of t within Di, then we need 1 rank and o + 1 selects to find them.",null,null
350,"In Table 2 we show the experimental trade-offs for WT, for the different block sizes tested. As it can be seen, WT (7 KB) requires space close to (though slightly larger than) that of the VByte approach. WT (3 KB) and WT (1 KB) obtain better times, but requiring even more space. Moreover, WT (7 KB) is slower than PIL (Rice) and uses more space. The WT, on the other hand, includes the textual data, but still this space usage could leave it out of competition. Next, we introduce extra improvements to make them more competitive.",null,null
351,Achieving Higher-Order Compression with the WT.,null,null
352,"Basically, WTs are zero-order compressors, which explains their high space usage. To achieve higher-order compression, notice that Broot contains the most significant byte of the Huffman encodings of the original terms. Thus, the original text structure is at least partially preserved in the structure of Broot, which might thus be as compressible as the original text. A similar behavior can be observed in internal nodes. Thus, we propose to compress the blocks of Bv in each WT node v by using some standard compressor.",null,null
353,"Table 2 shows results for lzma and snappy, the best compressors we tried. Notice that WT (7 KB) + lzma achieves 19,628 MB, almost half the space used by WT (7 KB). The time to obtain positions becomes, on the other hand, an order of magnitude larger. WT (7 KB) + snappy achieves slightly better times, but using more space. Also, WT (7 KB) + lzma uses slightly less space than VByte + snappy (0.2 MB), but is somewhat slower. Overall, this significant reduction in space could make WTcompetitive.",null,null
354,5. EXPERIMENTAL RESULTS,null,null
355,"We now show the time-space trade-offs for the overall solution space we explored. We use here the same basic setup as in Section 4.2.3, with the same parameters (block sizes) for each alternative. We consider the most competitive indexing alternatives from previous sections for positions and snippet generation, described in Table 4. All results include the time and space of the inverted index to carry out Step 1 of the query process, as well as of all structures used in Steps 2 and 3.",null,null
356,Table 4: Glossary of the indexing schemes used in,null,null
357,Figure 1. All schemes include the inverted index.,null,null
358,Indexing Scheme Description,null,null
359,Scheme 1,null,null
360,WT for positions and text.,null,null
361,Scheme 2,null,null
362,WT compressed with lzma for,null,null
363,positions and text.,null,null
364,Scheme 3,null,null
365,WT compressed with snappy for,null,null
366,positions and text.,null,null
367,Scheme 4,null,null
368,Text compressed with VByte/,null,null
369,VNibble for positions and text.,null,null
370,Scheme 5,null,null
371,VByte compression booster on,null,null
372,snappy for positions and text.,null,null
373,Scheme 6,null,null
374,PIL (Rice) for positions and VByte/,null,null
375,VNibble for text.,null,null
376,"Note that only Scheme 6 stores an index for position data. Figure 1 shows the different trade-offs for DAAT AND queries with BM25 ranking. Conclusions for OR queries are similar to that for AND. We only show results for k1 ,"" 200 and k2  {10, 50}, which are representative of other values we tested.""",null,null
377,"As can be seen, Scheme 6, which uses PIL for positions and Turpin et al [37] for snippets, has one of the fastest query times among all alternatives, but space usage is high compared to other methods. This is because this scheme needs to store positions and text separately. The two points for Scheme 6 that are plotted correspond to using VByte (higher space usage) and VNibble.",null,null
378,"Scheme 1 also offers a competitive query time (among the fastest alternatives), but still uses a considerable amount of space. The time-space trade-offs for the schemes that use WT are obtained for different block sizes within the WT nodes (1 to 7 KB). Scheme 2 and Scheme 3 compress the byte sequences of each WT node (as proposed in Section 4.4). As can be seen, the space usage is improved significantly, in some cases by a factor of two. However, query time degrades, making these alternatives less compelling.",null,null
379,"Scheme 4 is very competitive in query time, but again its space usage is high. Scheme 5 corresponds to the compression boosters proposed in Section 4.3, and it obtains a very impressive trade-off. One of the most interesting settings is for blocks of size 0.05 MB. In this case, the overall space usage is 1.06 times the space of PIL (Rice), with a query time 1.21 times higher than Scheme 4 and 1.23 times higher than Scheme 6 (which uses PIL). For blocks of size 0.01 MB, Scheme 5 requires 1.12 times the space of PIL (Rice), with a query time that is 0.96 times the one of Scheme 4, and 0.98 the one of Scheme 6. Thus, using only slightly more space than PIL (Rice) (recall the results in Table 2), Scheme 5 includes everything needed for query processing: docIDs, frequencies, term positions, and the text needed to gener-",null,null
380,262,null,null
381,Overall query time (ms per query) Overall query time (ms per query),null,null
382,"Time-space trade-offs k1 ,"" 200, k2 "", 10",null,null
383,200,null,null
384,Scheme 1,null,null
385,Scheme 2,null,null
386,Scheme 3,null,null
387,Scheme 4,null,null
388,150,null,null
389,Scheme 5,null,null
390,Scheme 6,null,null
391,100,null,null
392,50,null,null
393,"Time-space trade-offs k1 ,"" 200, k2 "", 50",null,null
394,250 200 150 100,null,null
395,50,null,null
396,0 25 30 35 40 45 50 55 60 65 70 75 80,null,null
397,Index size (GB),null,null
398,0 25 30 35 40 45 50 55 60 65 70 75 80,null,null
399,Index size (GB),null,null
400,"Figure 1: Time-space trade-offs for the overall query process for the GOV2 collection, including positional ranking and snippet generation. The size of each alternative includes the size of inverted index with docIDs and frequencies, which for the TREC GOV2 collection requires 9,739MB.",null,null
401,"ate snippets. This is one of the most important conclusions in this paper, that ""not to index"" can be a real alternative for positional data in practical scenarios. As stated in Section 4.3, the space usage of PILs can be reduced to about 21 GB­22 GB for the TREC GOV2 collection [40]. However, we would still need to add the inverted index and the compressed text to that space in order to support all query processing steps.",null,null
402,"Finally, the smallest space alternatives we tested (which are not shown in Figure 1) are the ones that use the inverted index for query processing and lzma compression for positions and snippets. This achieves about 22,225 MB of space. This scheme includes everything needed for query processing, and uses only 78% the space of PIL. However, query processing time increases significantly, to more than 400 ms per query. This scheme could be useful in some cases where the available memory space is very restricted, such that a larger index would mean going to disk.",null,null
403,"A recent alternative [34] proposes to use flat positional indexes [11, 14] to support phrase querying; this index could also be used for positional ranking. This is basically a positional index from which docID and frequency information can also be obtained. The results reported for the GOV2 collection in [34] give an index of size 30,310 MB that includes docIDs and frequencies, but not the text needed for snippet generation, making this approach uncompetitive for our scenario.",null,null
404,6. CONCLUSIONS,null,null
405,"From our study we can conclude that there exists a wide range of practical time-space trade-offs, other than just the classical positional inverted indexes. We studied several alternatives, trying to answer the question of whether it is necessary to index position data or not. As one of the most relevant points in the trade-off, we propose a compressed document representation based on the approach in [37] combined with Google's snappy compression [1]. This allows us to compute position and snippet data using less space than a standard positional inverted index that only stores position data. Even if we include the space used for document identifiers and term frequencies, this approach uses just 1.12",null,null
406,"times the space of a positional inverted index, with the same or slightly better query time.",null,null
407,"This means that in many practical cases, ""not to index"" position data may be the most efficient approach. This provides new practical alternatives for positional index compression, a problem that has been considered difficult to address in previous work [40, 21]. Finally, we also showed that compressed self-indexes such as wavelet trees [23] can be competitive with the best solutions in some scenarios.",null,null
408,7. REFERENCES,null,null
409,[1] http://code.google.com/p/snappy/. [2] V. N. Anh and A. Moffat. Compressed inverted files,null,null
410,"with reduced decoding overheads. In Proc. of 21st Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 290­297, 1998. [3] V. N. Anh and A. Moffat. Inverted index compression using word-aligned binary codes. Inf. Retr., 8(1):151­166, 2005. [4] D. Arroyuelo, V. Gil-Costa, S. Gonz´alez, M. Marin, and M. Oyarzu´n. Distributed search based on self-indexed compressed text. Information Processing and Management, 2012. To appear. [5] D. Arroyuelo, S. Gonz´alez, and M. Oyarzu´n. Compressed self-indices supporting conjunctive queries on document collections. In SPIRE, LNCS 6393, pages 43­54, 2010. [6] R. Baeza-Yates and B. Ribeiro-Neto. Modern Information Retrieval - the Concepts and Technology Behind Search, Second Edition. Pearson Education Ltd., Harlow, England, 2011. [7] S. Brin and L. Page. The anatomy of a large-scale hypertextual web search engine. J. of Computer Networks, 30(1­7):107­117, 1998. [8] N. Brisaboa, A. Farin~a, S. Ladra, and G. Navarro. Implicit indexing of natural language text by reorganizing bytecodes. Information Retrieval, 2012. To appear. [9] A. Z. Broder, D. Carmel, M. Herscovici, A. Soffer, and J. Zien. Efficient query evaluation using a two-level",null,null
411,263,null,null
412,"retrieval process. In Proc. of 12th International Conference on Information and Knowledge Management, pages 426­434. ACM, 2003. [10] S. Bu¨ttcher, C. Clarke, and G. Cormack. Information Retrieval: Implementing and Evaluating Search Engines. MIT Press, 2010. [11] C. Clarke, G. Cormack, and F. Burkowski. An algebra for structured text search and a framework for its implementation. Computer Journal, 38(1):43­56, 1995.",null,null
413,"[12] F. Claude and G. Navarro. Practical rank/select queries over arbitrary sequences. In SPIRE, LNCS 5280, pages 176­187. Springer, 2008.",null,null
414,[13] D. Cutting. Apache Lucene. http://lucene.apache.org/.,null,null
415,"[14] J. Dean. Challenges in building large-scale information retrieval systems: invited talk. In WSDM, page 1, 2009.",null,null
416,"[15] S. Ding and T. Suel. Faster top-k document retrieval using block-max indexes. In Proc. of 34th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 993­1002, 2011.",null,null
417,"[16] P. Elias. Universal codeword sets and representations of the integers. IEEE Transactions on Information Theory, 21(2):194­203, 1975.",null,null
418,"[17] A. Farin~a, N. Brisaboa, G. Navarro, F. Claude, A. Places, and E. Rodr´iguez. Word-based self-indexes for natural language text. ACM Transactions on Information Systems (TOIS), 30(1):article 1, 2012.",null,null
419,"[18] A. Farin~a, G. Navarro, and J. Parama´. Boosting text compression with word-based statistical encoding. Computer Journal, 55(1):111­131, 2012.",null,null
420,"[19] P. Ferragina, R. Giancarlo, and G. Manzini. The myriad virtues of wavelet trees. Information and Computation, 207(8):849­866, 2009.",null,null
421,"[20] P. Ferragina, R. Gonz´alez, G. Navarro, and R. Venturini. Compressed text indexes: From theory to practice. ACM Journal of Experimental Algorithmics, 13, 2008.",null,null
422,"[21] P. Ferragina and G. Manzini. On compressing the textual web. In WSDM, pages 391­400, 2010.",null,null
423,"[22] S. Golomb. Run-length encoding. IEEE Transactions on Information Theory, 12(3):399­401, 1966.",null,null
424,"[23] R. Grossi, A. Gupta, and J. S. Vitter. High-order entropy-compressed text indexes. In SODA, pages 841­850, 2003.",null,null
425,"[24] J. M. Kleinberg. Authoritative sources in a hyperlinked environment. J. of ACM, 46(5):604­632, 1999.",null,null
426,"[25] C. Manning, P. Raghavan, and H. Schu¨tze. Introduction to Information Retrieval. Cambridge University Press, 2008.",null,null
427,"[26] G. Manzini. An analysis of the Burrows-Wheeler transform. J. ACM, 48(3):407­430, 2001.",null,null
428,"[27] D. Metzler and W. B. Croft. A markov random field model for term dependencies. In Proc. of 28th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, 2005.",null,null
429,"[28] G. Mishne and M. Rijke. Boosting web retrieval through query operations. In Proc. of 27th European Conference on IR Research, 2005.",null,null
430,"[29] A. Moffat. Word-based text compression. Software, Practice, and Experience, 19(2):185­198, 1989.",null,null
431,"[30] A. Moffat and L. Stuiver. Binary interpolative coding for effective index compression. Inf. Retr., 3(1):25­47, 2000.",null,null
432,"[31] G. Navarro and V. M¨akinen. Compressed full-text indexes. ACM Computing Surveys, 39(1), 2007.",null,null
433,"[32] Y. Rasolofo and J. Savoy. Term proximity scoring for keyword-based retrieval systems. In Proc. of 25th European Conference on IR Research, 2003.",null,null
434,"[33] R. Schenkel, A. Broschart, S. Hwang, M. Theobald, and G. Weikum. Efficient text proximity search. In 14th String Processing and Information Retrieval Symposium, 2007.",null,null
435,"[34] D. Shan, W. X. Zhao, J. He, R. Yan, H. Yan, and X. Li. Efficient phrase querying with flat position index. In CIKM, pages 2001­2004, 2011.",null,null
436,"[35] B. Sparrow, J. Liu, and M. Wegner. Google effects on memory: Cognitive consequences of having information at our fingerprints. Science, 333(6043):776­778, 2011.",null,null
437,"[36] T. Tao and C. Zhai. An exploration of proximity measures in information retrieval. In Proc. of 30th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, 2007.",null,null
438,"[37] A. Turpin, Y. Tsegay, D. Hawking, and H. Williams. Fast generation of result snippets in web search. In Proc. of 30th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 127­134, 2007.",null,null
439,"[38] L. Wang, J. J. Lin, and D. Metzler. A cascade ranking model for efficient ranked retrieval. In Proc. of 34th Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 105­114, 2011.",null,null
440,"[39] H. Williams and J. Zobel. Compressing integers for fast file access. Computer Journal, 42(3):193­201, 1999.",null,null
441,"[40] H. Yan, S. Ding, and T. Suel. Compressing term positions in web indexes. In Proc. of 32nd Annual Int. ACM SIGIR Conf. on Research and Development in Information Retrieval, pages 147­154, 2009.",null,null
442,"[41] H. Yan, S. Ding, and T. Suel. Inverted index compression and query processing with optimized document ordering. In WWW, pages 401­410, 2009.",null,null
443,"[42] M. Zukowski, S. H´eman, N. Nes, and P. Boncz. Super-scalar ram-cpu cache compression. In ICDE, page 59, 2006.",null,null
444,264,null,null
445,,null,null
